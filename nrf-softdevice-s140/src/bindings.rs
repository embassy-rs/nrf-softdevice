/*
 * Copyright (c) 2012 - 2019, Nordic Semiconductor ASA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 *
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 *
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#![allow(
    clippy::fn_to_numeric_cast,
    clippy::missing_safety_doc,
    clippy::redundant_static_lifetimes,
    clippy::useless_transmute
)]

pub type c_schar = i8;
pub type c_uchar = u8;
pub type c_char = u8;

pub type c_short = i16;
pub type c_ushort = u16;

pub type c_int = i32;
pub type c_uint = u32;

pub type c_long = i32;
pub type c_ulong = u32;

pub type c_longlong = i64;
pub type c_ulonglong = u64;

pub type c_void = core::ffi::c_void;

trait ToAsm {
    fn to_asm(self) -> u32;
}

fn to_asm<T: ToAsm>(t: T) -> u32 {
    t.to_asm()
}

impl ToAsm for u32 {
    fn to_asm(self) -> u32 {
        self
    }
}

impl ToAsm for u16 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl ToAsm for u8 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl ToAsm for i8 {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T> ToAsm for *const T {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T> ToAsm for *mut T {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<T: ToAsm> ToAsm for Option<T> {
    fn to_asm(self) -> u32 {
        match self {
            Some(x) => x.to_asm(),
            None => 0,
        }
    }
}

impl<X, R> ToAsm for unsafe extern "C" fn(X) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<X, Y, R> ToAsm for unsafe extern "C" fn(X, Y) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

impl<X, Y, Z, R> ToAsm for unsafe extern "C" fn(X, Y, Z) -> R {
    fn to_asm(self) -> u32 {
        self as u32
    }
}

/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize) };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize) };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const NRF_ERROR_BASE_NUM: u32 = 0;
pub const NRF_ERROR_SDM_BASE_NUM: u32 = 4096;
pub const NRF_ERROR_SOC_BASE_NUM: u32 = 8192;
pub const NRF_ERROR_STK_BASE_NUM: u32 = 12288;
pub const NRF_SUCCESS: u32 = 0;
pub const NRF_ERROR_SVC_HANDLER_MISSING: u32 = 1;
pub const NRF_ERROR_SOFTDEVICE_NOT_ENABLED: u32 = 2;
pub const NRF_ERROR_INTERNAL: u32 = 3;
pub const NRF_ERROR_NO_MEM: u32 = 4;
pub const NRF_ERROR_NOT_FOUND: u32 = 5;
pub const NRF_ERROR_NOT_SUPPORTED: u32 = 6;
pub const NRF_ERROR_INVALID_PARAM: u32 = 7;
pub const NRF_ERROR_INVALID_STATE: u32 = 8;
pub const NRF_ERROR_INVALID_LENGTH: u32 = 9;
pub const NRF_ERROR_INVALID_FLAGS: u32 = 10;
pub const NRF_ERROR_INVALID_DATA: u32 = 11;
pub const NRF_ERROR_DATA_SIZE: u32 = 12;
pub const NRF_ERROR_TIMEOUT: u32 = 13;
pub const NRF_ERROR_NULL: u32 = 14;
pub const NRF_ERROR_FORBIDDEN: u32 = 15;
pub const NRF_ERROR_INVALID_ADDR: u32 = 16;
pub const NRF_ERROR_BUSY: u32 = 17;
pub const NRF_ERROR_CONN_COUNT: u32 = 18;
pub const NRF_ERROR_RESOURCES: u32 = 19;
pub const BLE_CONN_HANDLE_INVALID: u32 = 65535;
pub const BLE_CONN_HANDLE_ALL: u32 = 65534;
pub const BLE_UUID_UNKNOWN: u32 = 0;
pub const BLE_UUID_SERVICE_PRIMARY: u32 = 10240;
pub const BLE_UUID_SERVICE_SECONDARY: u32 = 10241;
pub const BLE_UUID_SERVICE_INCLUDE: u32 = 10242;
pub const BLE_UUID_CHARACTERISTIC: u32 = 10243;
pub const BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP: u32 = 10496;
pub const BLE_UUID_DESCRIPTOR_CHAR_USER_DESC: u32 = 10497;
pub const BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG: u32 = 10498;
pub const BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG: u32 = 10499;
pub const BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT: u32 = 10500;
pub const BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT: u32 = 10501;
pub const BLE_UUID_GATT: u32 = 6145;
pub const BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED: u32 = 10757;
pub const BLE_UUID_GAP: u32 = 6144;
pub const BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME: u32 = 10752;
pub const BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE: u32 = 10753;
pub const BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR: u32 = 10755;
pub const BLE_UUID_GAP_CHARACTERISTIC_PPCP: u32 = 10756;
pub const BLE_UUID_GAP_CHARACTERISTIC_CAR: u32 = 10918;
pub const BLE_UUID_GAP_CHARACTERISTIC_RPA_ONLY: u32 = 10953;
pub const BLE_UUID_TYPE_UNKNOWN: u32 = 0;
pub const BLE_UUID_TYPE_BLE: u32 = 1;
pub const BLE_UUID_TYPE_VENDOR_BEGIN: u32 = 2;
pub const BLE_APPEARANCE_UNKNOWN: u32 = 0;
pub const BLE_APPEARANCE_GENERIC_PHONE: u32 = 64;
pub const BLE_APPEARANCE_GENERIC_COMPUTER: u32 = 128;
pub const BLE_APPEARANCE_GENERIC_WATCH: u32 = 192;
pub const BLE_APPEARANCE_WATCH_SPORTS_WATCH: u32 = 193;
pub const BLE_APPEARANCE_GENERIC_CLOCK: u32 = 256;
pub const BLE_APPEARANCE_GENERIC_DISPLAY: u32 = 320;
pub const BLE_APPEARANCE_GENERIC_REMOTE_CONTROL: u32 = 384;
pub const BLE_APPEARANCE_GENERIC_EYE_GLASSES: u32 = 448;
pub const BLE_APPEARANCE_GENERIC_TAG: u32 = 512;
pub const BLE_APPEARANCE_GENERIC_KEYRING: u32 = 576;
pub const BLE_APPEARANCE_GENERIC_MEDIA_PLAYER: u32 = 640;
pub const BLE_APPEARANCE_GENERIC_BARCODE_SCANNER: u32 = 704;
pub const BLE_APPEARANCE_GENERIC_THERMOMETER: u32 = 768;
pub const BLE_APPEARANCE_THERMOMETER_EAR: u32 = 769;
pub const BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR: u32 = 832;
pub const BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT: u32 = 833;
pub const BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE: u32 = 896;
pub const BLE_APPEARANCE_BLOOD_PRESSURE_ARM: u32 = 897;
pub const BLE_APPEARANCE_BLOOD_PRESSURE_WRIST: u32 = 898;
pub const BLE_APPEARANCE_GENERIC_HID: u32 = 960;
pub const BLE_APPEARANCE_HID_KEYBOARD: u32 = 961;
pub const BLE_APPEARANCE_HID_MOUSE: u32 = 962;
pub const BLE_APPEARANCE_HID_JOYSTICK: u32 = 963;
pub const BLE_APPEARANCE_HID_GAMEPAD: u32 = 964;
pub const BLE_APPEARANCE_HID_DIGITIZERSUBTYPE: u32 = 965;
pub const BLE_APPEARANCE_HID_CARD_READER: u32 = 966;
pub const BLE_APPEARANCE_HID_DIGITAL_PEN: u32 = 967;
pub const BLE_APPEARANCE_HID_BARCODE: u32 = 968;
pub const BLE_APPEARANCE_GENERIC_GLUCOSE_METER: u32 = 1024;
pub const BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR: u32 = 1088;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE: u32 = 1089;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE: u32 = 1090;
pub const BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP: u32 = 1091;
pub const BLE_APPEARANCE_GENERIC_CYCLING: u32 = 1152;
pub const BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER: u32 = 1153;
pub const BLE_APPEARANCE_CYCLING_SPEED_SENSOR: u32 = 1154;
pub const BLE_APPEARANCE_CYCLING_CADENCE_SENSOR: u32 = 1155;
pub const BLE_APPEARANCE_CYCLING_POWER_SENSOR: u32 = 1156;
pub const BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR: u32 = 1157;
pub const BLE_APPEARANCE_GENERIC_PULSE_OXIMETER: u32 = 3136;
pub const BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP: u32 = 3137;
pub const BLE_APPEARANCE_PULSE_OXIMETER_WRIST_WORN: u32 = 3138;
pub const BLE_APPEARANCE_GENERIC_WEIGHT_SCALE: u32 = 3200;
pub const BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS_ACT: u32 = 5184;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_DISP: u32 = 5185;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_DISP: u32 = 5186;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_POD: u32 = 5187;
pub const BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_POD: u32 = 5188;
pub const NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN: u32 = 4096;
pub const NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION: u32 = 4097;
pub const NRF_ERROR_SDM_INCORRECT_CLENR0: u32 = 4098;
pub const NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN: u32 = 8192;
pub const NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE: u32 = 8193;
pub const NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED: u32 = 8194;
pub const NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN: u32 = 8195;
pub const NRF_ERROR_SOC_POWER_MODE_UNKNOWN: u32 = 8196;
pub const NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN: u32 = 8197;
pub const NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN: u32 = 8198;
pub const NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES: u32 = 8199;
pub const NRF_ERROR_SOC_PPI_INVALID_CHANNEL: u32 = 8200;
pub const NRF_ERROR_SOC_PPI_INVALID_GROUP: u32 = 8201;
pub const SOC_SVC_BASE: u32 = 32;
pub const SOC_SVC_BASE_NOT_AVAILABLE: u32 = 44;
pub const NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US: u32 = 62;
pub const NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US: u32 = 200;
pub const NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US: u32 = 20;
pub const NRF_RADIO_MIN_EXTENSION_MARGIN_US: u32 = 82;
pub const SOC_ECB_KEY_LENGTH: u32 = 16;
pub const SOC_ECB_CLEARTEXT_LENGTH: u32 = 16;
pub const SOC_ECB_CIPHERTEXT_LENGTH: u32 = 16;
pub const NRF_RADIO_LENGTH_MIN_US: u32 = 100;
pub const NRF_RADIO_LENGTH_MAX_US: u32 = 100000;
pub const NRF_RADIO_DISTANCE_MAX_US: u32 = 127999999;
pub const NRF_RADIO_EARLIEST_TIMEOUT_MAX_US: u32 = 127999999;
pub const NRF_RADIO_START_JITTER_US: u32 = 2;
pub const SD_MAJOR_VERSION: u32 = 7;
pub const SD_MINOR_VERSION: u32 = 0;
pub const SD_BUGFIX_VERSION: u32 = 1;
pub const SD_VARIANT_ID: u32 = 140;
pub const SD_VERSION: u32 = 7000001;
pub const SDM_SVC_BASE: u32 = 16;
pub const SD_UNIQUE_STR_SIZE: u32 = 20;
pub const SDM_INFO_FIELD_INVALID: u32 = 0;
pub const SOFTDEVICE_INFO_STRUCT_OFFSET: u32 = 8192;
pub const SD_INFO_STRUCT_SIZE_OFFSET: u32 = 8192;
pub const SD_SIZE_OFFSET: u32 = 8200;
pub const SD_FWID_OFFSET: u32 = 8204;
pub const SD_ID_OFFSET: u32 = 8208;
pub const SD_VERSION_OFFSET: u32 = 8212;
pub const SD_UNIQUE_STR_OFFSET: u32 = 8216;
pub const SD_FLASH_SIZE: u32 = 155648;
pub const NRF_FAULT_ID_SD_RANGE_START: u32 = 0;
pub const NRF_FAULT_ID_APP_RANGE_START: u32 = 4096;
pub const NRF_FAULT_ID_SD_ASSERT: u32 = 1;
pub const NRF_FAULT_ID_APP_MEMACC: u32 = 4097;
pub const NRF_CLOCK_LF_ACCURACY_250_PPM: u32 = 0;
pub const NRF_CLOCK_LF_ACCURACY_500_PPM: u32 = 1;
pub const NRF_CLOCK_LF_ACCURACY_150_PPM: u32 = 2;
pub const NRF_CLOCK_LF_ACCURACY_100_PPM: u32 = 3;
pub const NRF_CLOCK_LF_ACCURACY_75_PPM: u32 = 4;
pub const NRF_CLOCK_LF_ACCURACY_50_PPM: u32 = 5;
pub const NRF_CLOCK_LF_ACCURACY_30_PPM: u32 = 6;
pub const NRF_CLOCK_LF_ACCURACY_20_PPM: u32 = 7;
pub const NRF_CLOCK_LF_ACCURACY_10_PPM: u32 = 8;
pub const NRF_CLOCK_LF_ACCURACY_5_PPM: u32 = 9;
pub const NRF_CLOCK_LF_ACCURACY_2_PPM: u32 = 10;
pub const NRF_CLOCK_LF_ACCURACY_1_PPM: u32 = 11;
pub const NRF_CLOCK_LF_SRC_RC: u32 = 0;
pub const NRF_CLOCK_LF_SRC_XTAL: u32 = 1;
pub const NRF_CLOCK_LF_SRC_SYNTH: u32 = 2;
pub const SD_TIMERS_USED: u32 = 1;
pub const SD_SWI_USED: u32 = 54;
pub const BLE_SVC_BASE: u32 = 96;
pub const BLE_SVC_LAST: u32 = 107;
pub const BLE_GAP_SVC_BASE: u32 = 108;
pub const BLE_GAP_SVC_LAST: u32 = 154;
pub const BLE_GATTC_SVC_BASE: u32 = 155;
pub const BLE_GATTC_SVC_LAST: u32 = 167;
pub const BLE_GATTS_SVC_BASE: u32 = 168;
pub const BLE_GATTS_SVC_LAST: u32 = 183;
pub const BLE_L2CAP_SVC_BASE: u32 = 184;
pub const BLE_L2CAP_SVC_LAST: u32 = 191;
pub const BLE_EVT_INVALID: u32 = 0;
pub const BLE_EVT_BASE: u32 = 1;
pub const BLE_EVT_LAST: u32 = 15;
pub const BLE_GAP_EVT_BASE: u32 = 16;
pub const BLE_GAP_EVT_LAST: u32 = 47;
pub const BLE_GATTC_EVT_BASE: u32 = 48;
pub const BLE_GATTC_EVT_LAST: u32 = 79;
pub const BLE_GATTS_EVT_BASE: u32 = 80;
pub const BLE_GATTS_EVT_LAST: u32 = 111;
pub const BLE_L2CAP_EVT_BASE: u32 = 112;
pub const BLE_L2CAP_EVT_LAST: u32 = 143;
pub const BLE_OPT_INVALID: u32 = 0;
pub const BLE_OPT_BASE: u32 = 1;
pub const BLE_OPT_LAST: u32 = 31;
pub const BLE_GAP_OPT_BASE: u32 = 32;
pub const BLE_GAP_OPT_LAST: u32 = 63;
pub const BLE_GATT_OPT_BASE: u32 = 64;
pub const BLE_GATT_OPT_LAST: u32 = 95;
pub const BLE_GATTC_OPT_BASE: u32 = 96;
pub const BLE_GATTC_OPT_LAST: u32 = 127;
pub const BLE_GATTS_OPT_BASE: u32 = 128;
pub const BLE_GATTS_OPT_LAST: u32 = 159;
pub const BLE_L2CAP_OPT_BASE: u32 = 160;
pub const BLE_L2CAP_OPT_LAST: u32 = 191;
pub const BLE_CFG_INVALID: u32 = 0;
pub const BLE_CFG_BASE: u32 = 1;
pub const BLE_CFG_LAST: u32 = 31;
pub const BLE_CONN_CFG_BASE: u32 = 32;
pub const BLE_CONN_CFG_LAST: u32 = 63;
pub const BLE_GAP_CFG_BASE: u32 = 64;
pub const BLE_GAP_CFG_LAST: u32 = 95;
pub const BLE_GATT_CFG_BASE: u32 = 96;
pub const BLE_GATT_CFG_LAST: u32 = 127;
pub const BLE_GATTC_CFG_BASE: u32 = 128;
pub const BLE_GATTC_CFG_LAST: u32 = 159;
pub const BLE_GATTS_CFG_BASE: u32 = 160;
pub const BLE_GATTS_CFG_LAST: u32 = 191;
pub const BLE_L2CAP_CFG_BASE: u32 = 192;
pub const BLE_L2CAP_CFG_LAST: u32 = 223;
pub const BLE_ERROR_NOT_ENABLED: u32 = 12289;
pub const BLE_ERROR_INVALID_CONN_HANDLE: u32 = 12290;
pub const BLE_ERROR_INVALID_ATTR_HANDLE: u32 = 12291;
pub const BLE_ERROR_INVALID_ADV_HANDLE: u32 = 12292;
pub const BLE_ERROR_INVALID_ROLE: u32 = 12293;
pub const BLE_ERROR_BLOCKED_BY_OTHER_LINKS: u32 = 12294;
pub const NRF_L2CAP_ERR_BASE: u32 = 12544;
pub const NRF_GAP_ERR_BASE: u32 = 12800;
pub const NRF_GATTC_ERR_BASE: u32 = 13056;
pub const NRF_GATTS_ERR_BASE: u32 = 13312;
pub const BLE_L2CAP_CH_COUNT_MAX: u32 = 64;
pub const BLE_L2CAP_MTU_MIN: u32 = 23;
pub const BLE_L2CAP_MPS_MIN: u32 = 23;
pub const BLE_L2CAP_CID_INVALID: u32 = 0;
pub const BLE_L2CAP_CREDITS_DEFAULT: u32 = 1;
pub const BLE_L2CAP_CH_SETUP_REFUSED_SRC_LOCAL: u32 = 1;
pub const BLE_L2CAP_CH_SETUP_REFUSED_SRC_REMOTE: u32 = 2;
pub const BLE_L2CAP_CH_STATUS_CODE_SUCCESS: u32 = 0;
pub const BLE_L2CAP_CH_STATUS_CODE_LE_PSM_NOT_SUPPORTED: u32 = 2;
pub const BLE_L2CAP_CH_STATUS_CODE_NO_RESOURCES: u32 = 4;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHENTICATION: u32 = 5;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHORIZATION: u32 = 6;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC_KEY_SIZE: u32 = 7;
pub const BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC: u32 = 8;
pub const BLE_L2CAP_CH_STATUS_CODE_INVALID_SCID: u32 = 9;
pub const BLE_L2CAP_CH_STATUS_CODE_SCID_ALLOCATED: u32 = 10;
pub const BLE_L2CAP_CH_STATUS_CODE_UNACCEPTABLE_PARAMS: u32 = 11;
pub const BLE_L2CAP_CH_STATUS_CODE_NOT_UNDERSTOOD: u32 = 32768;
pub const BLE_L2CAP_CH_STATUS_CODE_TIMEOUT: u32 = 49152;
pub const BLE_HCI_STATUS_CODE_SUCCESS: u32 = 0;
pub const BLE_HCI_STATUS_CODE_UNKNOWN_BTLE_COMMAND: u32 = 1;
pub const BLE_HCI_STATUS_CODE_UNKNOWN_CONNECTION_IDENTIFIER: u32 = 2;
pub const BLE_HCI_AUTHENTICATION_FAILURE: u32 = 5;
pub const BLE_HCI_STATUS_CODE_PIN_OR_KEY_MISSING: u32 = 6;
pub const BLE_HCI_MEMORY_CAPACITY_EXCEEDED: u32 = 7;
pub const BLE_HCI_CONNECTION_TIMEOUT: u32 = 8;
pub const BLE_HCI_STATUS_CODE_COMMAND_DISALLOWED: u32 = 12;
pub const BLE_HCI_STATUS_CODE_INVALID_BTLE_COMMAND_PARAMETERS: u32 = 18;
pub const BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION: u32 = 19;
pub const BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_LOW_RESOURCES: u32 = 20;
pub const BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_POWER_OFF: u32 = 21;
pub const BLE_HCI_LOCAL_HOST_TERMINATED_CONNECTION: u32 = 22;
pub const BLE_HCI_UNSUPPORTED_REMOTE_FEATURE: u32 = 26;
pub const BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS: u32 = 30;
pub const BLE_HCI_STATUS_CODE_UNSPECIFIED_ERROR: u32 = 31;
pub const BLE_HCI_STATUS_CODE_LMP_RESPONSE_TIMEOUT: u32 = 34;
pub const BLE_HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION: u32 = 35;
pub const BLE_HCI_STATUS_CODE_LMP_PDU_NOT_ALLOWED: u32 = 36;
pub const BLE_HCI_INSTANT_PASSED: u32 = 40;
pub const BLE_HCI_PAIRING_WITH_UNIT_KEY_UNSUPPORTED: u32 = 41;
pub const BLE_HCI_DIFFERENT_TRANSACTION_COLLISION: u32 = 42;
pub const BLE_HCI_PARAMETER_OUT_OF_MANDATORY_RANGE: u32 = 48;
pub const BLE_HCI_CONTROLLER_BUSY: u32 = 58;
pub const BLE_HCI_CONN_INTERVAL_UNACCEPTABLE: u32 = 59;
pub const BLE_HCI_DIRECTED_ADVERTISER_TIMEOUT: u32 = 60;
pub const BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE: u32 = 61;
pub const BLE_HCI_CONN_FAILED_TO_BE_ESTABLISHED: u32 = 62;
pub const BLE_GATT_ATT_MTU_DEFAULT: u32 = 23;
pub const BLE_GATT_HANDLE_INVALID: u32 = 0;
pub const BLE_GATT_HANDLE_START: u32 = 1;
pub const BLE_GATT_HANDLE_END: u32 = 65535;
pub const BLE_GATT_TIMEOUT_SRC_PROTOCOL: u32 = 0;
pub const BLE_GATT_OP_INVALID: u32 = 0;
pub const BLE_GATT_OP_WRITE_REQ: u32 = 1;
pub const BLE_GATT_OP_WRITE_CMD: u32 = 2;
pub const BLE_GATT_OP_SIGN_WRITE_CMD: u32 = 3;
pub const BLE_GATT_OP_PREP_WRITE_REQ: u32 = 4;
pub const BLE_GATT_OP_EXEC_WRITE_REQ: u32 = 5;
pub const BLE_GATT_EXEC_WRITE_FLAG_PREPARED_CANCEL: u32 = 0;
pub const BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE: u32 = 1;
pub const BLE_GATT_HVX_INVALID: u32 = 0;
pub const BLE_GATT_HVX_NOTIFICATION: u32 = 1;
pub const BLE_GATT_HVX_INDICATION: u32 = 2;
pub const BLE_GATT_STATUS_SUCCESS: u32 = 0;
pub const BLE_GATT_STATUS_UNKNOWN: u32 = 1;
pub const BLE_GATT_STATUS_ATTERR_INVALID: u32 = 256;
pub const BLE_GATT_STATUS_ATTERR_INVALID_HANDLE: u32 = 257;
pub const BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED: u32 = 258;
pub const BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED: u32 = 259;
pub const BLE_GATT_STATUS_ATTERR_INVALID_PDU: u32 = 260;
pub const BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION: u32 = 261;
pub const BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED: u32 = 262;
pub const BLE_GATT_STATUS_ATTERR_INVALID_OFFSET: u32 = 263;
pub const BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION: u32 = 264;
pub const BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL: u32 = 265;
pub const BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND: u32 = 266;
pub const BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG: u32 = 267;
pub const BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE: u32 = 268;
pub const BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH: u32 = 269;
pub const BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR: u32 = 270;
pub const BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION: u32 = 271;
pub const BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE: u32 = 272;
pub const BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES: u32 = 273;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN: u32 = 274;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END: u32 = 383;
pub const BLE_GATT_STATUS_ATTERR_APP_BEGIN: u32 = 384;
pub const BLE_GATT_STATUS_ATTERR_APP_END: u32 = 415;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN: u32 = 416;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END: u32 = 479;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN: u32 = 480;
pub const BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END: u32 = 508;
pub const BLE_GATT_STATUS_ATTERR_CPS_WRITE_REQ_REJECTED: u32 = 508;
pub const BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR: u32 = 509;
pub const BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG: u32 = 510;
pub const BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE: u32 = 511;
pub const BLE_GATT_CPF_FORMAT_RFU: u32 = 0;
pub const BLE_GATT_CPF_FORMAT_BOOLEAN: u32 = 1;
pub const BLE_GATT_CPF_FORMAT_2BIT: u32 = 2;
pub const BLE_GATT_CPF_FORMAT_NIBBLE: u32 = 3;
pub const BLE_GATT_CPF_FORMAT_UINT8: u32 = 4;
pub const BLE_GATT_CPF_FORMAT_UINT12: u32 = 5;
pub const BLE_GATT_CPF_FORMAT_UINT16: u32 = 6;
pub const BLE_GATT_CPF_FORMAT_UINT24: u32 = 7;
pub const BLE_GATT_CPF_FORMAT_UINT32: u32 = 8;
pub const BLE_GATT_CPF_FORMAT_UINT48: u32 = 9;
pub const BLE_GATT_CPF_FORMAT_UINT64: u32 = 10;
pub const BLE_GATT_CPF_FORMAT_UINT128: u32 = 11;
pub const BLE_GATT_CPF_FORMAT_SINT8: u32 = 12;
pub const BLE_GATT_CPF_FORMAT_SINT12: u32 = 13;
pub const BLE_GATT_CPF_FORMAT_SINT16: u32 = 14;
pub const BLE_GATT_CPF_FORMAT_SINT24: u32 = 15;
pub const BLE_GATT_CPF_FORMAT_SINT32: u32 = 16;
pub const BLE_GATT_CPF_FORMAT_SINT48: u32 = 17;
pub const BLE_GATT_CPF_FORMAT_SINT64: u32 = 18;
pub const BLE_GATT_CPF_FORMAT_SINT128: u32 = 19;
pub const BLE_GATT_CPF_FORMAT_FLOAT32: u32 = 20;
pub const BLE_GATT_CPF_FORMAT_FLOAT64: u32 = 21;
pub const BLE_GATT_CPF_FORMAT_SFLOAT: u32 = 22;
pub const BLE_GATT_CPF_FORMAT_FLOAT: u32 = 23;
pub const BLE_GATT_CPF_FORMAT_DUINT16: u32 = 24;
pub const BLE_GATT_CPF_FORMAT_UTF8S: u32 = 25;
pub const BLE_GATT_CPF_FORMAT_UTF16S: u32 = 26;
pub const BLE_GATT_CPF_FORMAT_STRUCT: u32 = 27;
pub const BLE_GATT_CPF_NAMESPACE_BTSIG: u32 = 1;
pub const BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN: u32 = 0;
pub const BLE_ERROR_GATTC_PROC_NOT_PERMITTED: u32 = 13056;
pub const BLE_GATTC_ATTR_INFO_FORMAT_16BIT: u32 = 1;
pub const BLE_GATTC_ATTR_INFO_FORMAT_128BIT: u32 = 2;
pub const BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT: u32 = 1;
pub const MBR_SVC_BASE: u32 = 24;
pub const MBR_PAGE_SIZE_IN_WORDS: u32 = 1024;
pub const MBR_SIZE: u32 = 4096;
pub const MBR_BOOTLOADER_ADDR: u32 = 4088;
pub const MBR_PARAM_PAGE_ADDR: u32 = 4092;
pub const BLE_ERROR_GAP_UUID_LIST_MISMATCH: u32 = 12800;
pub const BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST: u32 = 12801;
pub const BLE_ERROR_GAP_INVALID_BLE_ADDR: u32 = 12802;
pub const BLE_ERROR_GAP_WHITELIST_IN_USE: u32 = 12803;
pub const BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE: u32 = 12804;
pub const BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE: u32 = 12805;
pub const BLE_GAP_ROLE_INVALID: u32 = 0;
pub const BLE_GAP_ROLE_PERIPH: u32 = 1;
pub const BLE_GAP_ROLE_CENTRAL: u32 = 2;
pub const BLE_GAP_TIMEOUT_SRC_SCAN: u32 = 1;
pub const BLE_GAP_TIMEOUT_SRC_CONN: u32 = 2;
pub const BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD: u32 = 3;
pub const BLE_GAP_ADDR_TYPE_PUBLIC: u32 = 0;
pub const BLE_GAP_ADDR_TYPE_RANDOM_STATIC: u32 = 1;
pub const BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE: u32 = 2;
pub const BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE: u32 = 3;
pub const BLE_GAP_ADDR_TYPE_ANONYMOUS: u32 = 127;
pub const BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S: u32 = 900;
pub const BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S: u32 = 41400;
pub const BLE_GAP_ADDR_LEN: u32 = 6;
pub const BLE_GAP_PRIVACY_MODE_OFF: u32 = 0;
pub const BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY: u32 = 1;
pub const BLE_GAP_PRIVACY_MODE_NETWORK_PRIVACY: u32 = 2;
pub const BLE_GAP_POWER_LEVEL_INVALID: u32 = 127;
pub const BLE_GAP_ADV_SET_HANDLE_NOT_SET: u32 = 255;
pub const BLE_GAP_ADV_SET_COUNT_DEFAULT: u32 = 1;
pub const BLE_GAP_ADV_SET_COUNT_MAX: u32 = 1;
pub const BLE_GAP_ADV_SET_DATA_SIZE_MAX: u32 = 31;
pub const BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_MAX_SUPPORTED: u32 = 255;
pub const BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_CONNECTABLE_MAX_SUPPORTED: u32 = 238;
pub const BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE: u32 = 255;
pub const BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_TIMEOUT: u32 = 1;
pub const BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_LIMIT_REACHED: u32 = 2;
pub const BLE_GAP_AD_TYPE_FLAGS: u32 = 1;
pub const BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 2;
pub const BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE: u32 = 3;
pub const BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 4;
pub const BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE: u32 = 5;
pub const BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE: u32 = 6;
pub const BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE: u32 = 7;
pub const BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME: u32 = 8;
pub const BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME: u32 = 9;
pub const BLE_GAP_AD_TYPE_TX_POWER_LEVEL: u32 = 10;
pub const BLE_GAP_AD_TYPE_CLASS_OF_DEVICE: u32 = 13;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C: u32 = 14;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R: u32 = 15;
pub const BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE: u32 = 16;
pub const BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS: u32 = 17;
pub const BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE: u32 = 18;
pub const BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT: u32 = 20;
pub const BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT: u32 = 21;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA: u32 = 22;
pub const BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS: u32 = 23;
pub const BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS: u32 = 24;
pub const BLE_GAP_AD_TYPE_APPEARANCE: u32 = 25;
pub const BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL: u32 = 26;
pub const BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS: u32 = 27;
pub const BLE_GAP_AD_TYPE_LE_ROLE: u32 = 28;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256: u32 = 29;
pub const BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256: u32 = 30;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID: u32 = 32;
pub const BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID: u32 = 33;
pub const BLE_GAP_AD_TYPE_LESC_CONFIRMATION_VALUE: u32 = 34;
pub const BLE_GAP_AD_TYPE_LESC_RANDOM_VALUE: u32 = 35;
pub const BLE_GAP_AD_TYPE_URI: u32 = 36;
pub const BLE_GAP_AD_TYPE_3D_INFORMATION_DATA: u32 = 61;
pub const BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA: u32 = 255;
pub const BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE: u32 = 1;
pub const BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE: u32 = 2;
pub const BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED: u32 = 4;
pub const BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER: u32 = 8;
pub const BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST: u32 = 16;
pub const BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE: u32 = 5;
pub const BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE: u32 = 6;
pub const BLE_GAP_ADV_INTERVAL_MIN: u32 = 32;
pub const BLE_GAP_ADV_INTERVAL_MAX: u32 = 16384;
pub const BLE_GAP_SCAN_INTERVAL_MIN: u32 = 4;
pub const BLE_GAP_SCAN_INTERVAL_MAX: u32 = 65535;
pub const BLE_GAP_SCAN_WINDOW_MIN: u32 = 4;
pub const BLE_GAP_SCAN_WINDOW_MAX: u32 = 65535;
pub const BLE_GAP_SCAN_TIMEOUT_MIN: u32 = 1;
pub const BLE_GAP_SCAN_TIMEOUT_UNLIMITED: u32 = 0;
pub const BLE_GAP_SCAN_BUFFER_MIN: u32 = 31;
pub const BLE_GAP_SCAN_BUFFER_MAX: u32 = 31;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MIN: u32 = 255;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MAX: u32 = 1650;
pub const BLE_GAP_SCAN_BUFFER_EXTENDED_MAX_SUPPORTED: u32 = 255;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 1;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE: u32 = 2;
pub const BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 3;
pub const BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 4;
pub const BLE_GAP_ADV_TYPE_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 5;
pub const BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 6;
pub const BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 7;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_UNDIRECTED: u32 = 8;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_DIRECTED: u32 = 9;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED: u32 = 10;
pub const BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_DIRECTED: u32 = 11;
pub const BLE_GAP_ADV_FP_ANY: u32 = 0;
pub const BLE_GAP_ADV_FP_FILTER_SCANREQ: u32 = 1;
pub const BLE_GAP_ADV_FP_FILTER_CONNREQ: u32 = 2;
pub const BLE_GAP_ADV_FP_FILTER_BOTH: u32 = 3;
pub const BLE_GAP_ADV_DATA_STATUS_COMPLETE: u32 = 0;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA: u32 = 1;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_TRUNCATED: u32 = 2;
pub const BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MISSED: u32 = 3;
pub const BLE_GAP_SCAN_FP_ACCEPT_ALL: u32 = 0;
pub const BLE_GAP_SCAN_FP_WHITELIST: u32 = 1;
pub const BLE_GAP_SCAN_FP_ALL_NOT_RESOLVED_DIRECTED: u32 = 2;
pub const BLE_GAP_SCAN_FP_WHITELIST_NOT_RESOLVED_DIRECTED: u32 = 3;
pub const BLE_GAP_ADV_TIMEOUT_HIGH_DUTY_MAX: u32 = 128;
pub const BLE_GAP_ADV_TIMEOUT_LIMITED_MAX: u32 = 18000;
pub const BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED: u32 = 0;
pub const BLE_GAP_DISC_MODE_NOT_DISCOVERABLE: u32 = 0;
pub const BLE_GAP_DISC_MODE_LIMITED: u32 = 1;
pub const BLE_GAP_DISC_MODE_GENERAL: u32 = 2;
pub const BLE_GAP_IO_CAPS_DISPLAY_ONLY: u32 = 0;
pub const BLE_GAP_IO_CAPS_DISPLAY_YESNO: u32 = 1;
pub const BLE_GAP_IO_CAPS_KEYBOARD_ONLY: u32 = 2;
pub const BLE_GAP_IO_CAPS_NONE: u32 = 3;
pub const BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY: u32 = 4;
pub const BLE_GAP_AUTH_KEY_TYPE_NONE: u32 = 0;
pub const BLE_GAP_AUTH_KEY_TYPE_PASSKEY: u32 = 1;
pub const BLE_GAP_AUTH_KEY_TYPE_OOB: u32 = 2;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_START: u32 = 0;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN: u32 = 1;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT: u32 = 2;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR: u32 = 3;
pub const BLE_GAP_KP_NOT_TYPE_PASSKEY_END: u32 = 4;
pub const BLE_GAP_SEC_STATUS_SUCCESS: u32 = 0;
pub const BLE_GAP_SEC_STATUS_TIMEOUT: u32 = 1;
pub const BLE_GAP_SEC_STATUS_PDU_INVALID: u32 = 2;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN: u32 = 3;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE1_END: u32 = 128;
pub const BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED: u32 = 129;
pub const BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE: u32 = 130;
pub const BLE_GAP_SEC_STATUS_AUTH_REQ: u32 = 131;
pub const BLE_GAP_SEC_STATUS_CONFIRM_VALUE: u32 = 132;
pub const BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP: u32 = 133;
pub const BLE_GAP_SEC_STATUS_ENC_KEY_SIZE: u32 = 134;
pub const BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED: u32 = 135;
pub const BLE_GAP_SEC_STATUS_UNSPECIFIED: u32 = 136;
pub const BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS: u32 = 137;
pub const BLE_GAP_SEC_STATUS_INVALID_PARAMS: u32 = 138;
pub const BLE_GAP_SEC_STATUS_DHKEY_FAILURE: u32 = 139;
pub const BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE: u32 = 140;
pub const BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG: u32 = 141;
pub const BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED: u32 = 142;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN: u32 = 143;
pub const BLE_GAP_SEC_STATUS_RFU_RANGE2_END: u32 = 255;
pub const BLE_GAP_SEC_STATUS_SOURCE_LOCAL: u32 = 0;
pub const BLE_GAP_SEC_STATUS_SOURCE_REMOTE: u32 = 1;
pub const BLE_GAP_CP_MIN_CONN_INTVL_NONE: u32 = 65535;
pub const BLE_GAP_CP_MIN_CONN_INTVL_MIN: u32 = 6;
pub const BLE_GAP_CP_MIN_CONN_INTVL_MAX: u32 = 3200;
pub const BLE_GAP_CP_MAX_CONN_INTVL_NONE: u32 = 65535;
pub const BLE_GAP_CP_MAX_CONN_INTVL_MIN: u32 = 6;
pub const BLE_GAP_CP_MAX_CONN_INTVL_MAX: u32 = 3200;
pub const BLE_GAP_CP_SLAVE_LATENCY_MAX: u32 = 499;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE: u32 = 65535;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN: u32 = 10;
pub const BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX: u32 = 3200;
pub const BLE_GAP_DEVNAME_DEFAULT: &[u8; 6] = b"nRF5x\0";
pub const BLE_GAP_DEVNAME_DEFAULT_LEN: u32 = 31;
pub const BLE_GAP_DEVNAME_MAX_LEN: u32 = 248;
pub const BLE_GAP_RSSI_THRESHOLD_INVALID: u32 = 255;
pub const BLE_GAP_PHY_AUTO: u32 = 0;
pub const BLE_GAP_PHY_1MBPS: u32 = 1;
pub const BLE_GAP_PHY_2MBPS: u32 = 2;
pub const BLE_GAP_PHY_CODED: u32 = 4;
pub const BLE_GAP_PHY_NOT_SET: u32 = 255;
pub const BLE_GAP_PHYS_SUPPORTED: u32 = 7;
pub const BLE_GAP_SEC_RAND_LEN: u32 = 8;
pub const BLE_GAP_SEC_KEY_LEN: u32 = 16;
pub const BLE_GAP_LESC_P256_PK_LEN: u32 = 64;
pub const BLE_GAP_LESC_DHKEY_LEN: u32 = 32;
pub const BLE_GAP_PASSKEY_LEN: u32 = 6;
pub const BLE_GAP_WHITELIST_ADDR_MAX_COUNT: u32 = 8;
pub const BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT: u32 = 8;
pub const BLE_GAP_CONN_COUNT_DEFAULT: u32 = 1;
pub const BLE_GAP_EVENT_LENGTH_MIN: u32 = 2;
pub const BLE_GAP_EVENT_LENGTH_CODED_PHY_MIN: u32 = 6;
pub const BLE_GAP_EVENT_LENGTH_DEFAULT: u32 = 3;
pub const BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT: u32 = 1;
pub const BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT: u32 = 3;
pub const BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT: u32 = 1;
pub const BLE_GAP_ROLE_COUNT_COMBINED_MAX: u32 = 20;
pub const BLE_GAP_DATA_LENGTH_AUTO: u32 = 0;
pub const BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX: u32 = 48000;
pub const BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MIN: u32 = 1;
pub const BLE_GAP_SEC_MODE: u32 = 0;
pub const BLE_GAP_CHANNEL_COUNT: u32 = 40;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_CONTINUOUS: u32 = 0;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MIN_US: u32 = 7500;
pub const BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MAX_US: u32 = 4000000;
pub const BLE_GAP_CHAR_INCL_CONFIG_INCLUDE: u32 = 0;
pub const BLE_GAP_CHAR_INCL_CONFIG_EXCLUDE_WITH_SPACE: u32 = 1;
pub const BLE_GAP_CHAR_INCL_CONFIG_EXCLUDE_WITHOUT_SPACE: u32 = 2;
pub const BLE_GAP_PPCP_INCL_CONFIG_DEFAULT: u32 = 0;
pub const BLE_GAP_CAR_INCL_CONFIG_DEFAULT: u32 = 0;
pub const BLE_ERROR_GATTS_INVALID_ATTR_TYPE: u32 = 13312;
pub const BLE_ERROR_GATTS_SYS_ATTR_MISSING: u32 = 13313;
pub const BLE_GATTS_FIX_ATTR_LEN_MAX: u32 = 510;
pub const BLE_GATTS_VAR_ATTR_LEN_MAX: u32 = 512;
pub const BLE_GATTS_SRVC_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_SRVC_TYPE_PRIMARY: u32 = 1;
pub const BLE_GATTS_SRVC_TYPE_SECONDARY: u32 = 2;
pub const BLE_GATTS_ATTR_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL: u32 = 1;
pub const BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL: u32 = 2;
pub const BLE_GATTS_ATTR_TYPE_INC_DECL: u32 = 3;
pub const BLE_GATTS_ATTR_TYPE_CHAR_DECL: u32 = 4;
pub const BLE_GATTS_ATTR_TYPE_CHAR_VAL: u32 = 5;
pub const BLE_GATTS_ATTR_TYPE_DESC: u32 = 6;
pub const BLE_GATTS_ATTR_TYPE_OTHER: u32 = 7;
pub const BLE_GATTS_OP_INVALID: u32 = 0;
pub const BLE_GATTS_OP_WRITE_REQ: u32 = 1;
pub const BLE_GATTS_OP_WRITE_CMD: u32 = 2;
pub const BLE_GATTS_OP_SIGN_WRITE_CMD: u32 = 3;
pub const BLE_GATTS_OP_PREP_WRITE_REQ: u32 = 4;
pub const BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL: u32 = 5;
pub const BLE_GATTS_OP_EXEC_WRITE_REQ_NOW: u32 = 6;
pub const BLE_GATTS_VLOC_INVALID: u32 = 0;
pub const BLE_GATTS_VLOC_STACK: u32 = 1;
pub const BLE_GATTS_VLOC_USER: u32 = 2;
pub const BLE_GATTS_AUTHORIZE_TYPE_INVALID: u32 = 0;
pub const BLE_GATTS_AUTHORIZE_TYPE_READ: u32 = 1;
pub const BLE_GATTS_AUTHORIZE_TYPE_WRITE: u32 = 2;
pub const BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS: u32 = 1;
pub const BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS: u32 = 2;
pub const BLE_GATTS_SERVICE_CHANGED_DEFAULT: u32 = 1;
pub const BLE_GATTS_ATTR_TAB_SIZE_MIN: u32 = 248;
pub const BLE_GATTS_ATTR_TAB_SIZE_DEFAULT: u32 = 1408;
pub const BLE_GATTS_HVN_TX_QUEUE_SIZE_DEFAULT: u32 = 1;
pub const BLE_EVT_PTR_ALIGNMENT: u32 = 4;
pub const BLE_USER_MEM_TYPE_INVALID: u32 = 0;
pub const BLE_USER_MEM_TYPE_GATTS_QUEUED_WRITES: u32 = 1;
pub const BLE_UUID_VS_COUNT_DEFAULT: u32 = 10;
pub const BLE_UUID_VS_COUNT_MAX: u32 = 254;
pub const BLE_CONN_CFG_TAG_DEFAULT: u32 = 0;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = self::c_longlong;
pub type uintmax_t = self::c_ulonglong;
#[doc = " @brief 128 bit UUID values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid128_t {
    #[doc = "< Little-Endian UUID bytes."]
    pub uuid128: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_uuid128_t"][::core::mem::size_of::<ble_uuid128_t>() - 16usize];
    ["Alignment of ble_uuid128_t"][::core::mem::align_of::<ble_uuid128_t>() - 1usize];
    ["Offset of field: ble_uuid128_t::uuid128"][::core::mem::offset_of!(ble_uuid128_t, uuid128) - 0usize];
};
#[doc = " @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid_t {
    #[doc = "< 16-bit UUID value or octets 12-13 of 128-bit UUID."]
    pub uuid: u16,
    #[doc = "< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined."]
    pub type_: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_uuid_t"][::core::mem::size_of::<ble_uuid_t>() - 4usize];
    ["Alignment of ble_uuid_t"][::core::mem::align_of::<ble_uuid_t>() - 2usize];
    ["Offset of field: ble_uuid_t::uuid"][::core::mem::offset_of!(ble_uuid_t, uuid) - 0usize];
    ["Offset of field: ble_uuid_t::type_"][::core::mem::offset_of!(ble_uuid_t, type_) - 2usize];
};
#[doc = "@brief Data structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_data_t {
    #[doc = "< Pointer to the data buffer provided to/from the application."]
    pub p_data: *mut u8,
    #[doc = "< Length of the data buffer, in bytes."]
    pub len: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_data_t"][::core::mem::size_of::<ble_data_t>() - 8usize];
    ["Alignment of ble_data_t"][::core::mem::align_of::<ble_data_t>() - 4usize];
    ["Offset of field: ble_data_t::p_data"][::core::mem::offset_of!(ble_data_t, p_data) - 0usize];
    ["Offset of field: ble_data_t::len"][::core::mem::offset_of!(ble_data_t, len) - 4usize];
};
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_GET: NRF_SOC_SVCS = 32;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_SET: NRF_SOC_SVCS = 33;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ENABLE_CLR: NRF_SOC_SVCS = 34;
pub const NRF_SOC_SVCS_SD_PPI_CHANNEL_ASSIGN: NRF_SOC_SVCS = 35;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_TASK_ENABLE: NRF_SOC_SVCS = 36;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_TASK_DISABLE: NRF_SOC_SVCS = 37;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_ASSIGN: NRF_SOC_SVCS = 38;
pub const NRF_SOC_SVCS_SD_PPI_GROUP_GET: NRF_SOC_SVCS = 39;
pub const NRF_SOC_SVCS_SD_FLASH_PAGE_ERASE: NRF_SOC_SVCS = 40;
pub const NRF_SOC_SVCS_SD_FLASH_WRITE: NRF_SOC_SVCS = 41;
pub const NRF_SOC_SVCS_SD_PROTECTED_REGISTER_WRITE: NRF_SOC_SVCS = 43;
pub const NRF_SOC_SVCS_SD_MUTEX_NEW: NRF_SOC_SVCS = 44;
pub const NRF_SOC_SVCS_SD_MUTEX_ACQUIRE: NRF_SOC_SVCS = 45;
pub const NRF_SOC_SVCS_SD_MUTEX_RELEASE: NRF_SOC_SVCS = 46;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_POOL_CAPACITY_GET: NRF_SOC_SVCS = 47;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_BYTES_AVAILABLE_GET: NRF_SOC_SVCS = 48;
pub const NRF_SOC_SVCS_SD_RAND_APPLICATION_VECTOR_GET: NRF_SOC_SVCS = 49;
pub const NRF_SOC_SVCS_SD_POWER_MODE_SET: NRF_SOC_SVCS = 50;
pub const NRF_SOC_SVCS_SD_POWER_SYSTEM_OFF: NRF_SOC_SVCS = 51;
pub const NRF_SOC_SVCS_SD_POWER_RESET_REASON_GET: NRF_SOC_SVCS = 52;
pub const NRF_SOC_SVCS_SD_POWER_RESET_REASON_CLR: NRF_SOC_SVCS = 53;
pub const NRF_SOC_SVCS_SD_POWER_POF_ENABLE: NRF_SOC_SVCS = 54;
pub const NRF_SOC_SVCS_SD_POWER_POF_THRESHOLD_SET: NRF_SOC_SVCS = 55;
pub const NRF_SOC_SVCS_SD_POWER_POF_THRESHOLDVDDH_SET: NRF_SOC_SVCS = 56;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_SET: NRF_SOC_SVCS = 57;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_CLR: NRF_SOC_SVCS = 58;
pub const NRF_SOC_SVCS_SD_POWER_RAM_POWER_GET: NRF_SOC_SVCS = 59;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_SET: NRF_SOC_SVCS = 60;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_CLR: NRF_SOC_SVCS = 61;
pub const NRF_SOC_SVCS_SD_POWER_GPREGRET_GET: NRF_SOC_SVCS = 62;
pub const NRF_SOC_SVCS_SD_POWER_DCDC_MODE_SET: NRF_SOC_SVCS = 63;
pub const NRF_SOC_SVCS_SD_POWER_DCDC0_MODE_SET: NRF_SOC_SVCS = 64;
pub const NRF_SOC_SVCS_SD_APP_EVT_WAIT: NRF_SOC_SVCS = 65;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_REQUEST: NRF_SOC_SVCS = 66;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_RELEASE: NRF_SOC_SVCS = 67;
pub const NRF_SOC_SVCS_SD_CLOCK_HFCLK_IS_RUNNING: NRF_SOC_SVCS = 68;
pub const NRF_SOC_SVCS_SD_RADIO_NOTIFICATION_CFG_SET: NRF_SOC_SVCS = 69;
pub const NRF_SOC_SVCS_SD_ECB_BLOCK_ENCRYPT: NRF_SOC_SVCS = 70;
pub const NRF_SOC_SVCS_SD_ECB_BLOCKS_ENCRYPT: NRF_SOC_SVCS = 71;
pub const NRF_SOC_SVCS_SD_RADIO_SESSION_OPEN: NRF_SOC_SVCS = 72;
pub const NRF_SOC_SVCS_SD_RADIO_SESSION_CLOSE: NRF_SOC_SVCS = 73;
pub const NRF_SOC_SVCS_SD_RADIO_REQUEST: NRF_SOC_SVCS = 74;
pub const NRF_SOC_SVCS_SD_EVT_GET: NRF_SOC_SVCS = 75;
pub const NRF_SOC_SVCS_SD_TEMP_GET: NRF_SOC_SVCS = 76;
pub const NRF_SOC_SVCS_SD_POWER_USBPWRRDY_ENABLE: NRF_SOC_SVCS = 77;
pub const NRF_SOC_SVCS_SD_POWER_USBDETECTED_ENABLE: NRF_SOC_SVCS = 78;
pub const NRF_SOC_SVCS_SD_POWER_USBREMOVED_ENABLE: NRF_SOC_SVCS = 79;
pub const NRF_SOC_SVCS_SD_POWER_USBREGSTATUS_GET: NRF_SOC_SVCS = 80;
pub const NRF_SOC_SVCS_SVC_SOC_LAST: NRF_SOC_SVCS = 81;
#[doc = "@brief The SVC numbers used by the SVC functions in the SoC library."]
pub type NRF_SOC_SVCS = self::c_uint;
pub const NRF_MUTEX_VALUES_NRF_MUTEX_FREE: NRF_MUTEX_VALUES = 0;
pub const NRF_MUTEX_VALUES_NRF_MUTEX_TAKEN: NRF_MUTEX_VALUES = 1;
#[doc = "@brief Possible values of a ::nrf_mutex_t."]
pub type NRF_MUTEX_VALUES = self::c_uint;
#[doc = "< Constant latency mode. See power management in the reference manual."]
pub const NRF_POWER_MODES_NRF_POWER_MODE_CONSTLAT: NRF_POWER_MODES = 0;
#[doc = "< Low power mode. See power management in the reference manual."]
pub const NRF_POWER_MODES_NRF_POWER_MODE_LOWPWR: NRF_POWER_MODES = 1;
#[doc = "@brief Power modes."]
pub type NRF_POWER_MODES = self::c_uint;
#[doc = "< 1.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V17: NRF_POWER_THRESHOLDS = 4;
#[doc = "< 1.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V18: NRF_POWER_THRESHOLDS = 5;
#[doc = "< 1.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V19: NRF_POWER_THRESHOLDS = 6;
#[doc = "< 2.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V20: NRF_POWER_THRESHOLDS = 7;
#[doc = "< 2.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V21: NRF_POWER_THRESHOLDS = 8;
#[doc = "< 2.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V22: NRF_POWER_THRESHOLDS = 9;
#[doc = "< 2.3 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V23: NRF_POWER_THRESHOLDS = 10;
#[doc = "< 2.4 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V24: NRF_POWER_THRESHOLDS = 11;
#[doc = "< 2.5 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V25: NRF_POWER_THRESHOLDS = 12;
#[doc = "< 2.6 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V26: NRF_POWER_THRESHOLDS = 13;
#[doc = "< 2.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V27: NRF_POWER_THRESHOLDS = 14;
#[doc = "< 2.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDS_NRF_POWER_THRESHOLD_V28: NRF_POWER_THRESHOLDS = 15;
#[doc = "@brief Power failure thresholds"]
pub type NRF_POWER_THRESHOLDS = self::c_uint;
#[doc = "< 2.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V27: NRF_POWER_THRESHOLDVDDHS = 0;
#[doc = "< 2.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V28: NRF_POWER_THRESHOLDVDDHS = 1;
#[doc = "< 2.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V29: NRF_POWER_THRESHOLDVDDHS = 2;
#[doc = "< 3.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V30: NRF_POWER_THRESHOLDVDDHS = 3;
#[doc = "< 3.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V31: NRF_POWER_THRESHOLDVDDHS = 4;
#[doc = "< 3.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V32: NRF_POWER_THRESHOLDVDDHS = 5;
#[doc = "< 3.3 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V33: NRF_POWER_THRESHOLDVDDHS = 6;
#[doc = "< 3.4 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V34: NRF_POWER_THRESHOLDVDDHS = 7;
#[doc = "< 3.5 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V35: NRF_POWER_THRESHOLDVDDHS = 8;
#[doc = "< 3.6 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V36: NRF_POWER_THRESHOLDVDDHS = 9;
#[doc = "< 3.7 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V37: NRF_POWER_THRESHOLDVDDHS = 10;
#[doc = "< 3.8 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V38: NRF_POWER_THRESHOLDVDDHS = 11;
#[doc = "< 3.9 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V39: NRF_POWER_THRESHOLDVDDHS = 12;
#[doc = "< 4.0 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V40: NRF_POWER_THRESHOLDVDDHS = 13;
#[doc = "< 4.1 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V41: NRF_POWER_THRESHOLDVDDHS = 14;
#[doc = "< 4.2 Volts power failure threshold."]
pub const NRF_POWER_THRESHOLDVDDHS_NRF_POWER_THRESHOLDVDDH_V42: NRF_POWER_THRESHOLDVDDHS = 15;
#[doc = "@brief Power failure thresholds for high voltage"]
pub type NRF_POWER_THRESHOLDVDDHS = self::c_uint;
#[doc = "< The DCDC is disabled."]
pub const NRF_POWER_DCDC_MODES_NRF_POWER_DCDC_DISABLE: NRF_POWER_DCDC_MODES = 0;
#[doc = "< The DCDC is enabled."]
pub const NRF_POWER_DCDC_MODES_NRF_POWER_DCDC_ENABLE: NRF_POWER_DCDC_MODES = 1;
#[doc = "@brief DC/DC converter modes."]
pub type NRF_POWER_DCDC_MODES = self::c_uint;
#[doc = "< The event does not have a notification."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_NONE: NRF_RADIO_NOTIFICATION_DISTANCES = 0;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_800US: NRF_RADIO_NOTIFICATION_DISTANCES = 1;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_1740US: NRF_RADIO_NOTIFICATION_DISTANCES = 2;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_2680US: NRF_RADIO_NOTIFICATION_DISTANCES = 3;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_3620US: NRF_RADIO_NOTIFICATION_DISTANCES = 4;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_4560US: NRF_RADIO_NOTIFICATION_DISTANCES = 5;
#[doc = "< The distance from the active notification to start of radio activity."]
pub const NRF_RADIO_NOTIFICATION_DISTANCES_NRF_RADIO_NOTIFICATION_DISTANCE_5500US: NRF_RADIO_NOTIFICATION_DISTANCES = 6;
#[doc = "@brief Radio notification distances."]
pub type NRF_RADIO_NOTIFICATION_DISTANCES = self::c_uint;
#[doc = "< The event does not have a radio notification signal."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_NONE: NRF_RADIO_NOTIFICATION_TYPES = 0;
#[doc = "< Using interrupt for notification when the radio will be enabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE: NRF_RADIO_NOTIFICATION_TYPES = 1;
#[doc = "< Using interrupt for notification when the radio has been disabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE: NRF_RADIO_NOTIFICATION_TYPES = 2;
#[doc = "< Using interrupt for notification both when the radio will be enabled and disabled."]
pub const NRF_RADIO_NOTIFICATION_TYPES_NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH: NRF_RADIO_NOTIFICATION_TYPES = 3;
#[doc = "@brief Radio notification types."]
pub type NRF_RADIO_NOTIFICATION_TYPES = self::c_uint;
#[doc = "< This signal indicates the start of the radio timeslot."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_START: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 0;
#[doc = "< This signal indicates the NRF_TIMER0 interrupt."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 1;
#[doc = "< This signal indicates the NRF_RADIO interrupt."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO: NRF_RADIO_CALLBACK_SIGNAL_TYPE = 2;
#[doc = "< This signal indicates extend action failed."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED: NRF_RADIO_CALLBACK_SIGNAL_TYPE =
    3;
#[doc = "< This signal indicates extend action succeeded."]
pub const NRF_RADIO_CALLBACK_SIGNAL_TYPE_NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED:
    NRF_RADIO_CALLBACK_SIGNAL_TYPE = 4;
#[doc = "@brief The Radio signal callback types."]
pub type NRF_RADIO_CALLBACK_SIGNAL_TYPE = self::c_uint;
#[doc = "< Return without action."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE: NRF_RADIO_SIGNAL_CALLBACK_ACTION = 0;
#[doc = "< Request an extension of the current\ntimeslot. Maximum execution time for this action:\n@ref NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US.\nThis action must be started at least\n@ref NRF_RADIO_MIN_EXTENSION_MARGIN_US before\nthe end of the timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND: NRF_RADIO_SIGNAL_CALLBACK_ACTION =
    1;
#[doc = "< End the current radio timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_END: NRF_RADIO_SIGNAL_CALLBACK_ACTION = 2;
#[doc = "< Request a new radio timeslot and end the current timeslot."]
pub const NRF_RADIO_SIGNAL_CALLBACK_ACTION_NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END:
    NRF_RADIO_SIGNAL_CALLBACK_ACTION = 3;
#[doc = "@brief The actions requested by the signal callback.\n\n  This code gives the SOC instructions about what action to take when the signal callback has\n  returned."]
pub type NRF_RADIO_SIGNAL_CALLBACK_ACTION = self::c_uint;
#[doc = "< The SoftDevice will guarantee that the high frequency clock source is the\nexternal crystal for the whole duration of the timeslot. This should be the\npreferred option for events that use the radio or require high timing accuracy.\n@note The SoftDevice will automatically turn on and off the external crystal,\nat the beginning and end of the timeslot, respectively. The crystal may also\nintentionally be left running after the timeslot, in cases where it is needed\nby the SoftDevice shortly after the end of the timeslot."]
pub const NRF_RADIO_HFCLK_CFG_NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED: NRF_RADIO_HFCLK_CFG = 0;
#[doc = "< This configuration allows for earlier and tighter scheduling of timeslots.\nThe RC oscillator may be the clock source in part or for the whole duration of the timeslot.\nThe RC oscillator's accuracy must therefore be taken into consideration.\n@note If the application will use the radio peripheral in timeslots with this configuration,\nit must make sure that the crystal is running and stable before starting the radio."]
pub const NRF_RADIO_HFCLK_CFG_NRF_RADIO_HFCLK_CFG_NO_GUARANTEE: NRF_RADIO_HFCLK_CFG = 1;
#[doc = "@brief Radio timeslot high frequency clock source configuration."]
pub type NRF_RADIO_HFCLK_CFG = self::c_uint;
#[doc = "< High (equal priority as the normal connection priority of the SoftDevice stack(s))."]
pub const NRF_RADIO_PRIORITY_NRF_RADIO_PRIORITY_HIGH: NRF_RADIO_PRIORITY = 0;
#[doc = "< Normal (equal priority as the priority of secondary activities of the SoftDevice stack(s))."]
pub const NRF_RADIO_PRIORITY_NRF_RADIO_PRIORITY_NORMAL: NRF_RADIO_PRIORITY = 1;
#[doc = "@brief Radio timeslot priorities."]
pub type NRF_RADIO_PRIORITY = self::c_uint;
#[doc = "< Request radio timeslot as early as possible. This should always be used for the first request in a session."]
pub const NRF_RADIO_REQUEST_TYPE_NRF_RADIO_REQ_TYPE_EARLIEST: NRF_RADIO_REQUEST_TYPE = 0;
#[doc = "< Normal radio timeslot request."]
pub const NRF_RADIO_REQUEST_TYPE_NRF_RADIO_REQ_TYPE_NORMAL: NRF_RADIO_REQUEST_TYPE = 1;
#[doc = "@brief Radio timeslot request type."]
pub type NRF_RADIO_REQUEST_TYPE = self::c_uint;
#[doc = "< Event indicating that the HFCLK has started."]
pub const NRF_SOC_EVTS_NRF_EVT_HFCLKSTARTED: NRF_SOC_EVTS = 0;
#[doc = "< Event indicating that a power failure warning has occurred."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_FAILURE_WARNING: NRF_SOC_EVTS = 1;
#[doc = "< Event indicating that the ongoing flash operation has completed successfully."]
pub const NRF_SOC_EVTS_NRF_EVT_FLASH_OPERATION_SUCCESS: NRF_SOC_EVTS = 2;
#[doc = "< Event indicating that the ongoing flash operation has timed out with an error."]
pub const NRF_SOC_EVTS_NRF_EVT_FLASH_OPERATION_ERROR: NRF_SOC_EVTS = 3;
#[doc = "< Event indicating that a radio timeslot was blocked."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_BLOCKED: NRF_SOC_EVTS = 4;
#[doc = "< Event indicating that a radio timeslot was canceled by SoftDevice."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_CANCELED: NRF_SOC_EVTS = 5;
#[doc = "< Event indicating that a radio timeslot signal callback handler return was invalid."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN: NRF_SOC_EVTS = 6;
#[doc = "< Event indicating that a radio timeslot session is idle."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SESSION_IDLE: NRF_SOC_EVTS = 7;
#[doc = "< Event indicating that a radio timeslot session is closed."]
pub const NRF_SOC_EVTS_NRF_EVT_RADIO_SESSION_CLOSED: NRF_SOC_EVTS = 8;
#[doc = "< Event indicating that a USB 3.3 V supply is ready."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_POWER_READY: NRF_SOC_EVTS = 9;
#[doc = "< Event indicating that voltage supply is detected on VBUS."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_DETECTED: NRF_SOC_EVTS = 10;
#[doc = "< Event indicating that voltage supply is removed from VBUS."]
pub const NRF_SOC_EVTS_NRF_EVT_POWER_USB_REMOVED: NRF_SOC_EVTS = 11;
pub const NRF_SOC_EVTS_NRF_EVT_NUMBER_OF_EVTS: NRF_SOC_EVTS = 12;
#[doc = "@brief SoC Events."]
pub type NRF_SOC_EVTS = self::c_uint;
#[doc = "@brief Represents a mutex for use with the nrf_mutex functions.\n @note Accessing the value directly is not safe, use the mutex functions!"]
pub type nrf_mutex_t = u8;
#[doc = "@brief Parameters for a request for a timeslot as early as possible."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_request_earliest_t {
    #[doc = "< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY."]
    pub priority: u8,
    #[doc = "< The radio timeslot length (in the range 100 to 100,000] microseconds)."]
    pub length_us: u32,
    #[doc = "< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds)."]
    pub timeout_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_request_earliest_t"][::core::mem::size_of::<nrf_radio_request_earliest_t>() - 12usize];
    ["Alignment of nrf_radio_request_earliest_t"][::core::mem::align_of::<nrf_radio_request_earliest_t>() - 4usize];
    ["Offset of field: nrf_radio_request_earliest_t::hfclk"]
        [::core::mem::offset_of!(nrf_radio_request_earliest_t, hfclk) - 0usize];
    ["Offset of field: nrf_radio_request_earliest_t::priority"]
        [::core::mem::offset_of!(nrf_radio_request_earliest_t, priority) - 1usize];
    ["Offset of field: nrf_radio_request_earliest_t::length_us"]
        [::core::mem::offset_of!(nrf_radio_request_earliest_t, length_us) - 4usize];
    ["Offset of field: nrf_radio_request_earliest_t::timeout_us"]
        [::core::mem::offset_of!(nrf_radio_request_earliest_t, timeout_us) - 8usize];
};
#[doc = "@brief Parameters for a normal radio timeslot request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_request_normal_t {
    #[doc = "< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY."]
    pub priority: u8,
    #[doc = "< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds)."]
    pub distance_us: u32,
    #[doc = "< The radio timeslot length (in the range [100..100,000] microseconds)."]
    pub length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_request_normal_t"][::core::mem::size_of::<nrf_radio_request_normal_t>() - 12usize];
    ["Alignment of nrf_radio_request_normal_t"][::core::mem::align_of::<nrf_radio_request_normal_t>() - 4usize];
    ["Offset of field: nrf_radio_request_normal_t::hfclk"]
        [::core::mem::offset_of!(nrf_radio_request_normal_t, hfclk) - 0usize];
    ["Offset of field: nrf_radio_request_normal_t::priority"]
        [::core::mem::offset_of!(nrf_radio_request_normal_t, priority) - 1usize];
    ["Offset of field: nrf_radio_request_normal_t::distance_us"]
        [::core::mem::offset_of!(nrf_radio_request_normal_t, distance_us) - 4usize];
    ["Offset of field: nrf_radio_request_normal_t::length_us"]
        [::core::mem::offset_of!(nrf_radio_request_normal_t, length_us) - 8usize];
};
#[doc = "@brief Radio timeslot request parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nrf_radio_request_t {
    #[doc = "< Type of request, see @ref NRF_RADIO_REQUEST_TYPE."]
    pub request_type: u8,
    #[doc = "< Parameter union."]
    pub params: nrf_radio_request_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nrf_radio_request_t__bindgen_ty_1 {
    #[doc = "< Parameters for requesting a radio timeslot as early as possible."]
    pub earliest: nrf_radio_request_earliest_t,
    #[doc = "< Parameters for requesting a normal radio timeslot."]
    pub normal: nrf_radio_request_normal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_request_t__bindgen_ty_1"]
        [::core::mem::size_of::<nrf_radio_request_t__bindgen_ty_1>() - 12usize];
    ["Alignment of nrf_radio_request_t__bindgen_ty_1"]
        [::core::mem::align_of::<nrf_radio_request_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: nrf_radio_request_t__bindgen_ty_1::earliest"]
        [::core::mem::offset_of!(nrf_radio_request_t__bindgen_ty_1, earliest) - 0usize];
    ["Offset of field: nrf_radio_request_t__bindgen_ty_1::normal"]
        [::core::mem::offset_of!(nrf_radio_request_t__bindgen_ty_1, normal) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_request_t"][::core::mem::size_of::<nrf_radio_request_t>() - 16usize];
    ["Alignment of nrf_radio_request_t"][::core::mem::align_of::<nrf_radio_request_t>() - 4usize];
    ["Offset of field: nrf_radio_request_t::request_type"]
        [::core::mem::offset_of!(nrf_radio_request_t, request_type) - 0usize];
    ["Offset of field: nrf_radio_request_t::params"][::core::mem::offset_of!(nrf_radio_request_t, params) - 4usize];
};
#[doc = "@brief Return parameters of the radio timeslot signal callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t {
    #[doc = "< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION."]
    pub callback_action: u8,
    #[doc = "< Parameter union."]
    pub params: nrf_radio_signal_callback_return_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nrf_radio_signal_callback_return_param_t__bindgen_ty_1 {
    #[doc = "< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END."]
    pub request: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND."]
    pub extend: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The request parameters for the next radio timeslot."]
    pub p_next: *mut nrf_radio_request_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1::p_next"][::core::mem::offset_of!(
        nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_1,
        p_next
    ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US)."]
    pub length_us: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Alignment of nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2::length_us"][::core::mem::offset_of!(
        nrf_radio_signal_callback_return_param_t__bindgen_ty_1__bindgen_ty_2,
        length_us
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_signal_callback_return_param_t__bindgen_ty_1"]
        [::core::mem::size_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>() - 4usize];
    ["Alignment of nrf_radio_signal_callback_return_param_t__bindgen_ty_1"]
        [::core::mem::align_of::<nrf_radio_signal_callback_return_param_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t__bindgen_ty_1::request"]
        [::core::mem::offset_of!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1, request) - 0usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t__bindgen_ty_1::extend"]
        [::core::mem::offset_of!(nrf_radio_signal_callback_return_param_t__bindgen_ty_1, extend) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_radio_signal_callback_return_param_t"]
        [::core::mem::size_of::<nrf_radio_signal_callback_return_param_t>() - 8usize];
    ["Alignment of nrf_radio_signal_callback_return_param_t"]
        [::core::mem::align_of::<nrf_radio_signal_callback_return_param_t>() - 4usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t::callback_action"]
        [::core::mem::offset_of!(nrf_radio_signal_callback_return_param_t, callback_action) - 0usize];
    ["Offset of field: nrf_radio_signal_callback_return_param_t::params"]
        [::core::mem::offset_of!(nrf_radio_signal_callback_return_param_t, params) - 4usize];
};
#[doc = "@brief The radio timeslot signal callback type.\n\n @note In case of invalid return parameters, the radio timeslot will automatically end\n       immediately after returning from the signal callback and the\n       @ref NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN event will be sent.\n @note The returned struct pointer must remain valid after the signal callback\n       function returns. For instance, this means that it must not point to a stack variable.\n\n @param[in] signal_type Type of signal, see @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE.\n\n @return Pointer to structure containing action requested by the application."]
pub type nrf_radio_signal_callback_t =
    ::core::option::Option<unsafe extern "C" fn(signal_type: u8) -> *mut nrf_radio_signal_callback_return_param_t>;
#[doc = "@brief AES ECB parameter typedefs"]
pub type soc_ecb_key_t = [u8; 16usize];
pub type soc_ecb_cleartext_t = [u8; 16usize];
pub type soc_ecb_ciphertext_t = [u8; 16usize];
#[doc = "@brief AES ECB data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_ecb_hal_data_t {
    #[doc = "< Encryption key."]
    pub key: soc_ecb_key_t,
    #[doc = "< Cleartext data."]
    pub cleartext: soc_ecb_cleartext_t,
    #[doc = "< Ciphertext data."]
    pub ciphertext: soc_ecb_ciphertext_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_ecb_hal_data_t"][::core::mem::size_of::<nrf_ecb_hal_data_t>() - 48usize];
    ["Alignment of nrf_ecb_hal_data_t"][::core::mem::align_of::<nrf_ecb_hal_data_t>() - 1usize];
    ["Offset of field: nrf_ecb_hal_data_t::key"][::core::mem::offset_of!(nrf_ecb_hal_data_t, key) - 0usize];
    ["Offset of field: nrf_ecb_hal_data_t::cleartext"]
        [::core::mem::offset_of!(nrf_ecb_hal_data_t, cleartext) - 16usize];
    ["Offset of field: nrf_ecb_hal_data_t::ciphertext"]
        [::core::mem::offset_of!(nrf_ecb_hal_data_t, ciphertext) - 32usize];
};
#[doc = "@brief AES ECB block. Used to provide multiple blocks in a single call\nto @ref sd_ecb_blocks_encrypt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_ecb_hal_data_block_t {
    #[doc = "< Pointer to the Encryption key."]
    pub p_key: *const soc_ecb_key_t,
    #[doc = "< Pointer to the Cleartext data."]
    pub p_cleartext: *const soc_ecb_cleartext_t,
    #[doc = "< Pointer to the Ciphertext data."]
    pub p_ciphertext: *mut soc_ecb_ciphertext_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_ecb_hal_data_block_t"][::core::mem::size_of::<nrf_ecb_hal_data_block_t>() - 12usize];
    ["Alignment of nrf_ecb_hal_data_block_t"][::core::mem::align_of::<nrf_ecb_hal_data_block_t>() - 4usize];
    ["Offset of field: nrf_ecb_hal_data_block_t::p_key"]
        [::core::mem::offset_of!(nrf_ecb_hal_data_block_t, p_key) - 0usize];
    ["Offset of field: nrf_ecb_hal_data_block_t::p_cleartext"]
        [::core::mem::offset_of!(nrf_ecb_hal_data_block_t, p_cleartext) - 4usize];
    ["Offset of field: nrf_ecb_hal_data_block_t::p_ciphertext"]
        [::core::mem::offset_of!(nrf_ecb_hal_data_block_t, p_ciphertext) - 8usize];
};

#[doc = "@brief Initialize a mutex.\n\n @param[in] p_mutex Pointer to the mutex to initialize.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_mutex_new(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 44",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Attempt to acquire a mutex.\n\n @param[in] p_mutex Pointer to the mutex to acquire.\n\n @retval ::NRF_SUCCESS The mutex was successfully acquired.\n @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired."]
#[inline(always)]
pub unsafe fn sd_mutex_acquire(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 45",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Release a mutex.\n\n @param[in] p_mutex Pointer to the mutex to release.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_mutex_release(p_mutex: *mut nrf_mutex_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 46",
        inout("r0") to_asm(p_mutex) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Query the capacity of the application random pool.\n\n @param[out] p_pool_capacity The capacity of the pool.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_rand_application_pool_capacity_get(p_pool_capacity: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 47",
        inout("r0") to_asm(p_pool_capacity) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get number of random bytes available to the application.\n\n @param[out] p_bytes_available The number of bytes currently available in the pool.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_rand_application_bytes_available_get(p_bytes_available: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 48",
        inout("r0") to_asm(p_bytes_available) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get random bytes from the application pool.\n\n @param[out]  p_buff  Pointer to unit8_t buffer for storing the bytes.\n @param[in]   length  Number of bytes to take from pool and place in p_buff.\n\n @retval ::NRF_SUCCESS The requested bytes were written to p_buff.\n @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available."]
#[inline(always)]
pub unsafe fn sd_rand_application_vector_get(p_buff: *mut u8, length: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 49",
        inout("r0") to_asm(p_buff) => ret,
        inout("r1") to_asm(length) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets the reset reason register.\n\n @param[out]  p_reset_reason  Contents of the NRF_POWER->RESETREAS register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_reset_reason_get(p_reset_reason: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 52",
        inout("r0") to_asm(p_reset_reason) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clears the bits of the reset reason register.\n\n @param[in] reset_reason_clr_msk Contains the bits to clear from the reset reason register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_reset_reason_clr(reset_reason_clr_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 53",
        inout("r0") to_asm(reset_reason_clr_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power mode when in CPU sleep.\n\n @param[in] power_mode The power mode to use when in CPU sleep, see @ref NRF_POWER_MODES. @sa sd_app_evt_wait\n\n @retval ::NRF_SUCCESS The power mode was set.\n @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown."]
#[inline(always)]
pub unsafe fn sd_power_mode_set(power_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 50",
        inout("r0") to_asm(power_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Puts the chip in System OFF mode.\n\n @retval ::NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN"]
#[inline(always)]
pub unsafe fn sd_power_system_off() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 51",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power-fail comparator.\n\n Enabling this will give a SoftDevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs.\n The event can be retrieved with sd_evt_get();\n\n @param[in] pof_enable    True if the power-fail comparator should be enabled, false if it should be disabled.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_pof_enable(pof_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 54",
        inout("r0") to_asm(pof_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the USB power ready event.\n\n Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_POWER_READY) when a USB 3.3 V supply is ready.\n The event can be retrieved with sd_evt_get();\n\n @param[in] usbpwrrdy_enable    True if the power ready event should be enabled, false if it should be disabled.\n\n @note Calling this function on a chip without USBD peripheral will result in undefined behaviour.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbpwrrdy_enable(usbpwrrdy_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 77",
        inout("r0") to_asm(usbpwrrdy_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power USB-detected event.\n\n Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_DETECTED) when a voltage supply is detected on VBUS.\n The event can be retrieved with sd_evt_get();\n\n @param[in] usbdetected_enable    True if the power ready event should be enabled, false if it should be disabled.\n\n @note Calling this function on a chip without USBD peripheral will result in undefined behaviour.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbdetected_enable(usbdetected_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 78",
        inout("r0") to_asm(usbdetected_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enables or disables the power USB-removed event.\n\n Enabling this will give a SoftDevice event (NRF_EVT_POWER_USB_REMOVED) when a voltage supply is removed from VBUS.\n The event can be retrieved with sd_evt_get();\n\n @param[in] usbremoved_enable    True if the power ready event should be enabled, false if it should be disabled.\n\n @note Calling this function on a chip without USBD peripheral will result in undefined behaviour.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbremoved_enable(usbremoved_enable: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 79",
        inout("r0") to_asm(usbremoved_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get USB supply status register content.\n\n @param[out] usbregstatus    The content of USBREGSTATUS register.\n\n @note Calling this function on a chip without USBD peripheral will result in undefined behaviour.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_usbregstatus_get(usbregstatus: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 80",
        inout("r0") to_asm(usbregstatus) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power failure comparator threshold value.\n\n @note: Power failure comparator threshold setting. This setting applies both for normal voltage\n        mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to\n        VDDH only).\n\n @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDS.\n\n @retval ::NRF_SUCCESS The power failure threshold was set.\n @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown."]
#[inline(always)]
pub unsafe fn sd_power_pof_threshold_set(threshold: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 55",
        inout("r0") to_asm(threshold) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the power failure comparator threshold value for high voltage.\n\n @note: Power failure comparator threshold setting for high voltage mode (supply connected to\n        VDDH only). This setting does not apply for normal voltage mode (supply connected to both\n        VDD and VDDH).\n\n @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDVDDHS.\n\n @retval ::NRF_SUCCESS The power failure threshold was set.\n @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown."]
#[inline(always)]
pub unsafe fn sd_power_pof_thresholdvddh_set(threshold: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 56",
        inout("r0") to_asm(threshold) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Writes the NRF_POWER->RAM[index].POWERSET register.\n\n @param[in] index Contains the index in the NRF_POWER->RAM[index].POWERSET register to write to.\n @param[in] ram_powerset Contains the word to write to the NRF_POWER->RAM[index].POWERSET register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_set(index: u8, ram_powerset: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 57",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(ram_powerset) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Writes the NRF_POWER->RAM[index].POWERCLR register.\n\n @param[in] index Contains the index in the NRF_POWER->RAM[index].POWERCLR register to write to.\n @param[in] ram_powerclr Contains the word to write to the NRF_POWER->RAM[index].POWERCLR register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_clr(index: u8, ram_powerclr: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 58",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(ram_powerclr) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get contents of NRF_POWER->RAM[index].POWER register, indicates power status of RAM[index] blocks.\n\n @param[in] index Contains the index in the NRF_POWER->RAM[index].POWER register to read from.\n @param[out] p_ram_power Content of NRF_POWER->RAM[index].POWER register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_ram_power_get(index: u8, p_ram_power: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 59",
        inout("r0") to_asm(index) => ret,
        inout("r1") to_asm(p_ram_power) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set bits in the general purpose retention registers (NRF_POWER->GPREGRET*).\n\n @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.\n @param[in] gpregret_msk Bits to be set in the GPREGRET register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_set(gpregret_id: u32, gpregret_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 60",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(gpregret_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clear bits in the general purpose retention registers (NRF_POWER->GPREGRET*).\n\n @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.\n @param[in] gpregret_msk Bits to be clear in the GPREGRET register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_clr(gpregret_id: u32, gpregret_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 61",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(gpregret_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get contents of the general purpose retention registers (NRF_POWER->GPREGRET*).\n\n @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.\n @param[out] p_gpregret Contents of the GPREGRET register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_power_gpregret_get(gpregret_id: u32, p_gpregret: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 62",
        inout("r0") to_asm(gpregret_id) => ret,
        inout("r1") to_asm(p_gpregret) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enable or disable the DC/DC regulator for the regulator stage 1 (REG1).\n\n @param[in] dcdc_mode The mode of the DCDC, see @ref NRF_POWER_DCDC_MODES.\n\n @retval ::NRF_SUCCESS\n @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid."]
#[inline(always)]
pub unsafe fn sd_power_dcdc_mode_set(dcdc_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 63",
        inout("r0") to_asm(dcdc_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Enable or disable the DC/DC regulator for the regulator stage 0 (REG0).\n\n For more details on the REG0 stage, please see product specification.\n\n @param[in] dcdc_mode The mode of the DCDC0, see @ref NRF_POWER_DCDC_MODES.\n\n @retval ::NRF_SUCCESS\n @retval ::NRF_ERROR_INVALID_PARAM The dcdc_mode is invalid."]
#[inline(always)]
pub unsafe fn sd_power_dcdc0_mode_set(dcdc_mode: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 64",
        inout("r0") to_asm(dcdc_mode) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Request the high frequency crystal oscillator.\n\n Will start the high frequency crystal oscillator, the startup time of the crystal varies\n and the ::sd_clock_hfclk_is_running function can be polled to check if it has started.\n\n @see sd_clock_hfclk_is_running\n @see sd_clock_hfclk_release\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_request() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 66",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Releases the high frequency crystal oscillator.\n\n Will stop the high frequency crystal oscillator, this happens immediately.\n\n @see sd_clock_hfclk_is_running\n @see sd_clock_hfclk_request\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_release() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 67",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Checks if the high frequency crystal oscillator is running.\n\n @see sd_clock_hfclk_request\n @see sd_clock_hfclk_release\n\n @param[out] p_is_running 1 if the external crystal oscillator is running, 0 if not.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_clock_hfclk_is_running(p_is_running: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 68",
        inout("r0") to_asm(p_is_running) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Waits for an application event.\n\n An application event is either an application interrupt or a pended interrupt when the interrupt\n is disabled.\n\n When the application waits for an application event by calling this function, an interrupt that\n is enabled will be taken immediately on pending since this function will wait in thread mode,\n then the execution will return in the application's main thread.\n\n In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M\n MCU's System Control Register (SCR), CMSIS_SCB. In that case, when a disabled interrupt gets\n pended, this function will return to the application's main thread.\n\n @note The application must ensure that the pended flag is cleared using ::sd_nvic_ClearPendingIRQ\n       in order to sleep using this function. This is only necessary for disabled interrupts, as\n       the interrupt handler will clear the pending flag automatically for enabled interrupts.\n\n @note If an application interrupt has happened since the last time sd_app_evt_wait was\n       called this function will return immediately and not go to sleep. This is to avoid race\n       conditions that can occur when a flag is updated in the interrupt handler and processed\n       in the main loop.\n\n @post An application interrupt has happened or a interrupt pending flag is set.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_app_evt_wait() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 65",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get PPI channel enable register contents.\n\n @param[out] p_channel_enable The contents of the PPI CHEN register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_get(p_channel_enable: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 32",
        inout("r0") to_asm(p_channel_enable) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set PPI channel enable register.\n\n @param[in] channel_enable_set_msk Mask containing the bits to set in the PPI CHEN register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_set(channel_enable_set_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 33",
        inout("r0") to_asm(channel_enable_set_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Clear PPI channel enable register.\n\n @param[in] channel_enable_clr_msk Mask containing the bits to clear in the PPI CHEN register.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_enable_clr(channel_enable_clr_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 34",
        inout("r0") to_asm(channel_enable_clr_msk) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Assign endpoints to a PPI channel.\n\n @param[in] channel_num Number of the PPI channel to assign.\n @param[in] evt_endpoint Event endpoint of the PPI channel.\n @param[in] task_endpoint Task endpoint of the PPI channel.\n\n @retval ::NRF_ERROR_SOC_PPI_INVALID_CHANNEL The channel number is invalid.\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_channel_assign(
    channel_num: u8,
    evt_endpoint: *const self::c_void,
    task_endpoint: *const self::c_void,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 35",
        inout("r0") to_asm(channel_num) => ret,
        inout("r1") to_asm(evt_endpoint) => _,
        inout("r2") to_asm(task_endpoint) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Task to enable a channel group.\n\n @param[in] group_num Number of the channel group.\n\n @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_task_enable(group_num: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 36",
        inout("r0") to_asm(group_num) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Task to disable a channel group.\n\n @param[in] group_num Number of the PPI group.\n\n @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_task_disable(group_num: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 37",
        inout("r0") to_asm(group_num) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Assign PPI channels to a channel group.\n\n @param[in] group_num Number of the channel group.\n @param[in] channel_msk Mask of the channels to assign to the group.\n\n @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_assign(group_num: u8, channel_msk: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 38",
        inout("r0") to_asm(group_num) => ret,
        inout("r1") to_asm(channel_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets the PPI channels of a channel group.\n\n @param[in]   group_num Number of the channel group.\n @param[out]  p_channel_msk Mask of the channels assigned to the group.\n\n @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ppi_group_get(group_num: u8, p_channel_msk: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 39",
        inout("r0") to_asm(group_num) => ret,
        inout("r1") to_asm(p_channel_msk) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Configures the Radio Notification signal.\n\n @note\n      - The notification signal latency depends on the interrupt priority settings of SWI used\n        for notification signal.\n      - To ensure that the radio notification signal behaves in a consistent way, the radio\n        notifications must be configured when there is no protocol stack or other SoftDevice\n        activity in progress. It is recommended that the radio notification signal is\n        configured directly after the SoftDevice has been enabled.\n      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice\n        will interrupt the application to do Radio Event preparation.\n      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have\n        to shorten the connection events to have time for the Radio Notification signals.\n\n @param[in]  type      Type of notification signal, see @ref NRF_RADIO_NOTIFICATION_TYPES.\n                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio\n                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is\n                       recommended (but not required) to be used with\n                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE.\n\n @param[in]  distance  Distance between the notification signal and start of radio activity, see @ref NRF_RADIO_NOTIFICATION_DISTANCES.\n                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or\n                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used.\n\n @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid.\n @retval ::NRF_ERROR_INVALID_STATE A protocol stack or other SoftDevice is running. Stop all\n                                   running activities and retry.\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_radio_notification_cfg_set(type_: u8, distance: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 69",
        inout("r0") to_asm(type_) => ret,
        inout("r1") to_asm(distance) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Encrypts a block according to the specified parameters.\n\n 128-bit AES encryption.\n\n @note:\n    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while\n      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application\n      main or low interrupt level.\n\n @param[in, out] p_ecb_data Pointer to the ECB parameters' struct (two input\n                            parameters and one output parameter).\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ecb_block_encrypt(p_ecb_data: *mut nrf_ecb_hal_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 70",
        inout("r0") to_asm(p_ecb_data) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Encrypts multiple data blocks provided as an array of data block structures.\n\n @details: Performs 128-bit AES encryption on multiple data blocks\n\n @note:\n    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while\n      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application\n      main or low interrupt level.\n\n @param[in]     block_count     Count of blocks in the p_data_blocks array.\n @param[in,out] p_data_blocks   Pointer to the first entry in a contiguous array of\n                                @ref nrf_ecb_hal_data_block_t structures.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_ecb_blocks_encrypt(block_count: u8, p_data_blocks: *mut nrf_ecb_hal_data_block_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 71",
        inout("r0") to_asm(block_count) => ret,
        inout("r1") to_asm(p_data_blocks) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Gets any pending events generated by the SoC API.\n\n The application should keep calling this function to get events, until ::NRF_ERROR_NOT_FOUND is returned.\n\n @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending.\n\n @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter.\n @retval ::NRF_ERROR_NOT_FOUND No pending events."]
#[inline(always)]
pub unsafe fn sd_evt_get(p_evt_id: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 75",
        inout("r0") to_asm(p_evt_id) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the temperature measured on the chip\n\n This function will block until the temperature measurement is done.\n It takes around 50 us from call to return.\n\n @param[out] p_temp Result of temperature measurement. Die temperature in 0.25 degrees Celsius.\n\n @retval ::NRF_SUCCESS A temperature measurement was done, and the temperature was written to temp"]
#[inline(always)]
pub unsafe fn sd_temp_get(p_temp: *mut i32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 76",
        inout("r0") to_asm(p_temp) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Flash Write\n\n Commands to write a buffer to flash\n\n If the SoftDevice is enabled:\n  This call initiates the flash access command, and its completion will be communicated to the\n  application with exactly one of the following events:\n      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.\n      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.\n\n If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the\n write has been completed\n\n @note\n      - This call takes control over the radio and the CPU during flash erase and write to make sure that\n        they will not interfere with the flash access. This means that all interrupts will be blocked\n        for a predictable time (depending on the NVMC specification in the device's Product Specification\n        and the command parameters).\n      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS\n        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled.\n      - This call will make the SoftDevice trigger a hardfault when the page is written, if it is\n        protected.\n\n\n @param[in]  p_dst Pointer to start of flash location to be written.\n @param[in]  p_src Pointer to buffer with data to be written.\n @param[in]  size  Number of 32-bit words to write. Maximum size is the number of words in one\n                   flash page. See the device's Product Specification for details.\n\n @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned.\n @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.\n @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.\n @retval ::NRF_ERROR_FORBIDDEN      Tried to write to an address outside the application flash area.\n @retval ::NRF_SUCCESS              The command was accepted."]
#[inline(always)]
pub unsafe fn sd_flash_write(p_dst: *mut u32, p_src: *const u32, size: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 41",
        inout("r0") to_asm(p_dst) => ret,
        inout("r1") to_asm(p_src) => _,
        inout("r2") to_asm(size) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Flash Erase page\n\n Commands to erase a flash page\n If the SoftDevice is enabled:\n  This call initiates the flash access command, and its completion will be communicated to the\n  application with exactly one of the following events:\n      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.\n      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.\n\n If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the\n erase has been completed\n\n @note\n      - This call takes control over the radio and the CPU during flash erase and write to make sure that\n        they will not interfere with the flash access. This means that all interrupts will be blocked\n        for a predictable time (depending on the NVMC specification in the device's Product Specification\n        and the command parameters).\n      - This call will make the SoftDevice trigger a hardfault when the page is erased, if it is\n        protected.\n\n\n @param[in]  page_number           Page number of the page to erase\n\n @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error.\n @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.\n @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.\n @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a page outside the application flash area.\n @retval ::NRF_SUCCESS             The command was accepted."]
#[inline(always)]
pub unsafe fn sd_flash_page_erase(page_number: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 40",
        inout("r0") to_asm(page_number) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Opens a session for radio timeslot requests.\n\n @note Only one session can be open at a time.\n @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) will be called when the radio timeslot\n       starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed\n       by the application.\n @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0) is called whenever the NRF_TIMER0\n       interrupt occurs.\n @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO) is called whenever the NRF_RADIO\n       interrupt occurs.\n @note p_radio_signal_callback() will be called at ARM interrupt priority level 0. This\n       implies that none of the sd_* API calls can be used from p_radio_signal_callback().\n\n @param[in] p_radio_signal_callback The signal callback.\n\n @retval ::NRF_ERROR_INVALID_ADDR p_radio_signal_callback is an invalid function pointer.\n @retval ::NRF_ERROR_BUSY If session cannot be opened.\n @retval ::NRF_ERROR_INTERNAL If a new session could not be opened due to an internal error.\n @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_session_open(p_radio_signal_callback: nrf_radio_signal_callback_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 72",
        inout("r0") to_asm(p_radio_signal_callback) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Closes a session for radio timeslot requests.\n\n @note Any current radio timeslot will be finished before the session is closed.\n @note If a radio timeslot is scheduled when the session is closed, it will be canceled.\n @note The application cannot consider the session closed until the @ref NRF_EVT_RADIO_SESSION_CLOSED\n       event is received.\n\n @retval ::NRF_ERROR_FORBIDDEN If session not opened.\n @retval ::NRF_ERROR_BUSY If session is currently being closed.\n @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_session_close() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 73",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Requests a radio timeslot.\n\n @note The request type is determined by p_request->request_type, and can be one of @ref NRF_RADIO_REQ_TYPE_EARLIEST\n       and @ref NRF_RADIO_REQ_TYPE_NORMAL. The first request in a session must always be of type @ref NRF_RADIO_REQ_TYPE_EARLIEST.\n @note For a normal request (@ref NRF_RADIO_REQ_TYPE_NORMAL), the start time of a radio timeslot is specified by\n       p_request->distance_us and is given relative to the start of the previous timeslot.\n @note A too small p_request->distance_us will lead to a @ref NRF_EVT_RADIO_BLOCKED event.\n @note Timeslots scheduled too close will lead to a @ref NRF_EVT_RADIO_BLOCKED event.\n @note See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths.\n @note If an opportunity for the first radio timeslot is not found before 100 ms after the call to this\n       function, it is not scheduled, and instead a @ref NRF_EVT_RADIO_BLOCKED event is sent.\n       The application may then try to schedule the first radio timeslot again.\n @note Successful requests will result in nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START).\n       Unsuccessful requests will result in a @ref NRF_EVT_RADIO_BLOCKED event, see @ref NRF_SOC_EVTS.\n @note The jitter in the start time of the radio timeslots is +/- @ref NRF_RADIO_START_JITTER_US us.\n @note The nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) call has a latency relative to the\n       specified radio timeslot start, but this does not affect the actual start time of the timeslot.\n @note NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency\n       (16 MHz) clock source. If p_request->hfclk_force_xtal is true, the high frequency clock is\n       guaranteed to be clocked from the external crystal.\n @note The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral\n       during the radio timeslot.\n\n @param[in] p_request Pointer to the request parameters.\n\n @retval ::NRF_ERROR_FORBIDDEN Either:\n                                - The session is not open.\n                                - The session is not IDLE.\n                                - This is the first request and its type is not @ref NRF_RADIO_REQ_TYPE_EARLIEST.\n                                - The request type was set to @ref NRF_RADIO_REQ_TYPE_NORMAL after a\n                                  @ref NRF_RADIO_REQ_TYPE_EARLIEST request was blocked.\n @retval ::NRF_ERROR_INVALID_ADDR If the p_request pointer is invalid.\n @retval ::NRF_ERROR_INVALID_PARAM If the parameters of p_request are not valid.\n @retval ::NRF_SUCCESS Otherwise."]
#[inline(always)]
pub unsafe fn sd_radio_request(p_request: *const nrf_radio_request_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 74",
        inout("r0") to_asm(p_request) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Write register protected by the SoftDevice\n\n This function writes to a register that is write-protected by the SoftDevice. Please refer to your\n SoftDevice Specification for more details about which registers that are protected by SoftDevice.\n This function can write to the following protected peripheral:\n  - ACL\n\n @note Protected registers may be read directly.\n @note Register that are write-once will return @ref NRF_SUCCESS on second set, even the value in\n       the register has not changed. See the Product Specification for more details about register\n       properties.\n\n @param[in]  p_register Pointer to register to be written.\n @param[in]  value Value to be written to the register.\n\n @retval ::NRF_ERROR_INVALID_ADDR This function can not write to the reguested register.\n @retval ::NRF_SUCCESS Value successfully written to register.\n"]
#[inline(always)]
pub unsafe fn sd_protected_register_write(p_register: *mut u32, value: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 43",
        inout("r0") to_asm(p_register) => ret,
        inout("r1") to_asm(value) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< ::sd_softdevice_enable"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_ENABLE: NRF_SD_SVCS = 16;
#[doc = "< ::sd_softdevice_disable"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_DISABLE: NRF_SD_SVCS = 17;
#[doc = "< ::sd_softdevice_is_enabled"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_IS_ENABLED: NRF_SD_SVCS = 18;
#[doc = "< ::sd_softdevice_vector_table_base_set"]
pub const NRF_SD_SVCS_SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET: NRF_SD_SVCS = 19;
#[doc = "< Placeholder for last SDM SVC"]
pub const NRF_SD_SVCS_SVC_SDM_LAST: NRF_SD_SVCS = 20;
#[doc = "@brief nRF SoftDevice Manager API SVC numbers."]
pub type NRF_SD_SVCS = self::c_uint;
#[doc = "@brief Type representing LFCLK oscillator source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_clock_lf_cfg_t {
    #[doc = "< LF oscillator clock source, see @ref NRF_CLOCK_LF_SRC."]
    pub source: u8,
    #[doc = "< Only for ::NRF_CLOCK_LF_SRC_RC: Calibration timer interval in 1/4 second\nunits (nRF52: 1-32).\n@note To avoid excessive clock drift, 0.5 degrees Celsius is the\nmaximum temperature change allowed in one calibration timer\ninterval. The interval should be selected to ensure this.\n\n@note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC."]
    pub rc_ctiv: u8,
    #[doc = "<  Only for ::NRF_CLOCK_LF_SRC_RC: How often (in number of calibration\nintervals) the RC oscillator shall be calibrated if the temperature\nhasn't changed.\n0: Always calibrate even if the temperature hasn't changed.\n1: Only calibrate if the temperature has changed (legacy - nRF51 only).\n2-33: Check the temperature and only calibrate if it has changed,\nhowever calibration will take place every rc_temp_ctiv\nintervals in any case.\n\n@note Must be 0 if source is not ::NRF_CLOCK_LF_SRC_RC.\n\n@note For nRF52, the application must ensure calibration at least once\nevery 8 seconds to ensure +/-500 ppm clock stability. The\nrecommended configuration for ::NRF_CLOCK_LF_SRC_RC on nRF52 is\nrc_ctiv=16 and rc_temp_ctiv=2. This will ensure calibration at\nleast once every 8 seconds and for temperature changes of 0.5\ndegrees Celsius every 4 seconds. See the Product Specification\nfor the nRF52 device being used for more information."]
    pub rc_temp_ctiv: u8,
    #[doc = "< External clock accuracy used in the LL to compute timing\nwindows, see @ref NRF_CLOCK_LF_ACCURACY."]
    pub accuracy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nrf_clock_lf_cfg_t"][::core::mem::size_of::<nrf_clock_lf_cfg_t>() - 4usize];
    ["Alignment of nrf_clock_lf_cfg_t"][::core::mem::align_of::<nrf_clock_lf_cfg_t>() - 1usize];
    ["Offset of field: nrf_clock_lf_cfg_t::source"][::core::mem::offset_of!(nrf_clock_lf_cfg_t, source) - 0usize];
    ["Offset of field: nrf_clock_lf_cfg_t::rc_ctiv"][::core::mem::offset_of!(nrf_clock_lf_cfg_t, rc_ctiv) - 1usize];
    ["Offset of field: nrf_clock_lf_cfg_t::rc_temp_ctiv"]
        [::core::mem::offset_of!(nrf_clock_lf_cfg_t, rc_temp_ctiv) - 2usize];
    ["Offset of field: nrf_clock_lf_cfg_t::accuracy"][::core::mem::offset_of!(nrf_clock_lf_cfg_t, accuracy) - 3usize];
};
#[doc = "@brief Fault Handler type.\n\n When certain unrecoverable errors occur within the application or SoftDevice the fault handler will be called back.\n The protocol stack will be in an undefined state when this happens and the only way to recover will be to\n perform a reset, using e.g. CMSIS NVIC_SystemReset().\n If the application returns from the fault handler the SoftDevice will call NVIC_SystemReset().\n\n @note It is recommended to either perform a reset in the fault handler or to let the SoftDevice reset the device.\n       Otherwise SoC peripherals may behave in an undefined way. For example, the RADIO peripherial may\n       continously transmit packets.\n\n @note This callback is executed in HardFault context, thus SVC functions cannot be called from the fault callback.\n\n @param[in] id Fault identifier. See @ref NRF_FAULT_IDS.\n @param[in] pc The program counter of the instruction that triggered the fault.\n @param[in] info Optional additional information regarding the fault. Refer to each Fault identifier for details.\n\n @note When id is set to @ref NRF_FAULT_ID_APP_MEMACC, pc will contain the address of the instruction being executed at the time when\n the fault is detected by the CPU. The CPU program counter may have advanced up to 2 instructions (no branching) after the one that triggered the fault."]
pub type nrf_fault_handler_t = ::core::option::Option<unsafe extern "C" fn(id: u32, pc: u32, info: u32)>;

#[doc = "@brief Enables the SoftDevice and by extension the protocol stack.\n\n @note Some care must be taken if a low frequency clock source is already running when calling this function:\n       If the LF clock has a different source then the one currently running, it will be stopped. Then, the new\n       clock source will be started.\n\n @note This function has no effect when returning with an error.\n\n @post If return code is ::NRF_SUCCESS\n       - SoC library and protocol stack APIs are made available.\n       - A portion of RAM will be unavailable (see relevant SDS documentation).\n       - Some peripherals will be unavailable or available only through the SoC API (see relevant SDS documentation).\n       - Interrupts will not arrive from protected peripherals or interrupts.\n       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the SoftDevice.\n       - Interrupt latency may be affected by the SoftDevice  (see relevant SDS documentation).\n       - Chosen low frequency clock source will be running.\n\n @param p_clock_lf_cfg Low frequency clock source and accuracy.\nIf NULL the clock will be configured as an RC source with rc_ctiv = 16 and .rc_temp_ctiv = 2\nIn the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock.\n @param fault_handler Callback to be invoked in case of fault, cannot be NULL.\n\n @retval ::NRF_SUCCESS\n @retval ::NRF_ERROR_INVALID_ADDR  Invalid or NULL pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.\n @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.\n @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid clock source configuration supplied in p_clock_lf_cfg."]
#[inline(always)]
pub unsafe fn sd_softdevice_enable(
    p_clock_lf_cfg: *const nrf_clock_lf_cfg_t,
    fault_handler: nrf_fault_handler_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 16",
        inout("r0") to_asm(p_clock_lf_cfg) => ret,
        inout("r1") to_asm(fault_handler) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Disables the SoftDevice and by extension the protocol stack.\n\n Idempotent function to disable the SoftDevice.\n\n @post SoC library and protocol stack APIs are made unavailable.\n @post All interrupts that was protected by the SoftDevice will be disabled and initialized to priority 0 (highest).\n @post All peripherals used by the SoftDevice will be reset to default values.\n @post All of RAM become available.\n @post All interrupts are forwarded to the application.\n @post LFCLK source chosen in ::sd_softdevice_enable will be left running.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_disable() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 17",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Check if the SoftDevice is enabled.\n\n @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_is_enabled(p_softdevice_enabled: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 18",
        inout("r0") to_asm(p_softdevice_enabled) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Sets the base address of the interrupt vector table for interrupts forwarded from the SoftDevice\n\n This function is only intended to be called when a bootloader is enabled.\n\n @param[in] address The base address of the interrupt vector table for forwarded interrupts.\n\n @retval ::NRF_SUCCESS"]
#[inline(always)]
pub unsafe fn sd_softdevice_vector_table_base_set(address: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 19",
        inout("r0") to_asm(address) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Set up an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_SETUP: BLE_L2CAP_SVCS = 184;
#[doc = "< Release an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_RELEASE: BLE_L2CAP_SVCS = 185;
#[doc = "< Receive an SDU on an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_RX: BLE_L2CAP_SVCS = 186;
#[doc = "< Transmit an SDU on an L2CAP channel."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_TX: BLE_L2CAP_SVCS = 187;
#[doc = "< Advanced SDU reception flow control."]
pub const BLE_L2CAP_SVCS_SD_BLE_L2CAP_CH_FLOW_CONTROL: BLE_L2CAP_SVCS = 188;
#[doc = "@brief L2CAP API SVC numbers."]
pub type BLE_L2CAP_SVCS = self::c_uint;
#[doc = "< L2CAP Channel Setup Request event.\n\\n See @ref ble_l2cap_evt_ch_setup_request_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP_REQUEST: BLE_L2CAP_EVTS = 112;
#[doc = "< L2CAP Channel Setup Refused event.\n\\n See @ref ble_l2cap_evt_ch_setup_refused_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP_REFUSED: BLE_L2CAP_EVTS = 113;
#[doc = "< L2CAP Channel Setup Completed event.\n\\n See @ref ble_l2cap_evt_ch_setup_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SETUP: BLE_L2CAP_EVTS = 114;
#[doc = "< L2CAP Channel Released event.\n\\n No additional event structure applies."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_RELEASED: BLE_L2CAP_EVTS = 115;
#[doc = "< L2CAP Channel SDU data buffer released event.\n\\n See @ref ble_l2cap_evt_ch_sdu_buf_released_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED: BLE_L2CAP_EVTS = 116;
#[doc = "< L2CAP Channel Credit received.\n\\n See @ref ble_l2cap_evt_ch_credit_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_CREDIT: BLE_L2CAP_EVTS = 117;
#[doc = "< L2CAP Channel SDU received.\n\\n See @ref ble_l2cap_evt_ch_rx_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_RX: BLE_L2CAP_EVTS = 118;
#[doc = "< L2CAP Channel SDU transmitted.\n\\n See @ref ble_l2cap_evt_ch_tx_t."]
pub const BLE_L2CAP_EVTS_BLE_L2CAP_EVT_CH_TX: BLE_L2CAP_EVTS = 119;
#[doc = "@brief L2CAP Event IDs."]
pub type BLE_L2CAP_EVTS = self::c_uint;
#[doc = " @brief BLE L2CAP connection configuration parameters, set with @ref sd_ble_cfg_set.\n\n @note  These parameters are set per connection, so all L2CAP channels created on this connection\n        will have the same parameters.\n\n @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:\n                                    - rx_mps is smaller than @ref BLE_L2CAP_MPS_MIN.\n                                    - tx_mps is smaller than @ref BLE_L2CAP_MPS_MIN.\n                                    - ch_count is greater than @ref BLE_L2CAP_CH_COUNT_MAX.\n @retval ::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_conn_cfg_t {
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall\nbe able to receive on L2CAP channels on connections with this\nconfiguration. The minimum value is @ref BLE_L2CAP_MPS_MIN."]
    pub rx_mps: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall\nbe able to transmit on L2CAP channels on connections with this\nconfiguration. The minimum value is @ref BLE_L2CAP_MPS_MIN."]
    pub tx_mps: u16,
    #[doc = "< Number of SDU data buffers that can be queued for reception per\nL2CAP channel. The minimum value is one."]
    pub rx_queue_size: u8,
    #[doc = "< Number of SDU data buffers that can be queued for transmission\nper L2CAP channel. The minimum value is one."]
    pub tx_queue_size: u8,
    #[doc = "< Number of L2CAP channels the application can create per connection\nwith this configuration. The default value is zero, the maximum\nvalue is @ref BLE_L2CAP_CH_COUNT_MAX.\n@note if this parameter is set to zero, all other parameters in\n@ref ble_l2cap_conn_cfg_t are ignored."]
    pub ch_count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_conn_cfg_t"][::core::mem::size_of::<ble_l2cap_conn_cfg_t>() - 8usize];
    ["Alignment of ble_l2cap_conn_cfg_t"][::core::mem::align_of::<ble_l2cap_conn_cfg_t>() - 2usize];
    ["Offset of field: ble_l2cap_conn_cfg_t::rx_mps"][::core::mem::offset_of!(ble_l2cap_conn_cfg_t, rx_mps) - 0usize];
    ["Offset of field: ble_l2cap_conn_cfg_t::tx_mps"][::core::mem::offset_of!(ble_l2cap_conn_cfg_t, tx_mps) - 2usize];
    ["Offset of field: ble_l2cap_conn_cfg_t::rx_queue_size"]
        [::core::mem::offset_of!(ble_l2cap_conn_cfg_t, rx_queue_size) - 4usize];
    ["Offset of field: ble_l2cap_conn_cfg_t::tx_queue_size"]
        [::core::mem::offset_of!(ble_l2cap_conn_cfg_t, tx_queue_size) - 5usize];
    ["Offset of field: ble_l2cap_conn_cfg_t::ch_count"]
        [::core::mem::offset_of!(ble_l2cap_conn_cfg_t, ch_count) - 6usize];
};
#[doc = "@brief L2CAP channel RX parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_rx_params_t {
    #[doc = "< The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to\nreceive on this L2CAP channel.\n- Must be equal to or greater than @ref BLE_L2CAP_MTU_MIN."]
    pub rx_mtu: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be\nable to receive on this L2CAP channel.\n- Must be equal to or greater than @ref BLE_L2CAP_MPS_MIN.\n- Must be equal to or less than @ref ble_l2cap_conn_cfg_t::rx_mps."]
    pub rx_mps: u16,
    #[doc = "< SDU data buffer for reception.\n- If @ref ble_data_t::p_data is non-NULL, initial credits are\nissued to the peer.\n- If @ref ble_data_t::p_data is NULL, no initial credits are\nissued to the peer."]
    pub sdu_buf: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_ch_rx_params_t"][::core::mem::size_of::<ble_l2cap_ch_rx_params_t>() - 12usize];
    ["Alignment of ble_l2cap_ch_rx_params_t"][::core::mem::align_of::<ble_l2cap_ch_rx_params_t>() - 4usize];
    ["Offset of field: ble_l2cap_ch_rx_params_t::rx_mtu"]
        [::core::mem::offset_of!(ble_l2cap_ch_rx_params_t, rx_mtu) - 0usize];
    ["Offset of field: ble_l2cap_ch_rx_params_t::rx_mps"]
        [::core::mem::offset_of!(ble_l2cap_ch_rx_params_t, rx_mps) - 2usize];
    ["Offset of field: ble_l2cap_ch_rx_params_t::sdu_buf"]
        [::core::mem::offset_of!(ble_l2cap_ch_rx_params_t, sdu_buf) - 4usize];
};
#[doc = "@brief L2CAP channel setup parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_setup_params_t {
    #[doc = "< L2CAP channel RX parameters."]
    pub rx_params: ble_l2cap_ch_rx_params_t,
    #[doc = "< LE Protocol/Service Multiplexer. Used when requesting\nsetup of an L2CAP channel, ignored otherwise."]
    pub le_psm: u16,
    #[doc = "< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES.\nUsed when replying to a setup request of an L2CAP\nchannel, ignored otherwise."]
    pub status: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_ch_setup_params_t"][::core::mem::size_of::<ble_l2cap_ch_setup_params_t>() - 16usize];
    ["Alignment of ble_l2cap_ch_setup_params_t"][::core::mem::align_of::<ble_l2cap_ch_setup_params_t>() - 4usize];
    ["Offset of field: ble_l2cap_ch_setup_params_t::rx_params"]
        [::core::mem::offset_of!(ble_l2cap_ch_setup_params_t, rx_params) - 0usize];
    ["Offset of field: ble_l2cap_ch_setup_params_t::le_psm"]
        [::core::mem::offset_of!(ble_l2cap_ch_setup_params_t, le_psm) - 12usize];
    ["Offset of field: ble_l2cap_ch_setup_params_t::status"]
        [::core::mem::offset_of!(ble_l2cap_ch_setup_params_t, status) - 14usize];
};
#[doc = "@brief L2CAP channel TX parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_ch_tx_params_t {
    #[doc = "< The maximum L2CAP SDU size, in bytes, that L2CAP is able to\ntransmit on this L2CAP channel."]
    pub tx_mtu: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that the peer is\nable to receive on this L2CAP channel."]
    pub peer_mps: u16,
    #[doc = "< The maximum L2CAP PDU payload size, in bytes, that L2CAP is able\nto transmit on this L2CAP channel. This is effective tx_mps,\nselected by the SoftDevice as\nMIN( @ref ble_l2cap_ch_tx_params_t::peer_mps, @ref ble_l2cap_conn_cfg_t::tx_mps )"]
    pub tx_mps: u16,
    #[doc = "< Initial credits given by the peer."]
    pub credits: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_ch_tx_params_t"][::core::mem::size_of::<ble_l2cap_ch_tx_params_t>() - 8usize];
    ["Alignment of ble_l2cap_ch_tx_params_t"][::core::mem::align_of::<ble_l2cap_ch_tx_params_t>() - 2usize];
    ["Offset of field: ble_l2cap_ch_tx_params_t::tx_mtu"]
        [::core::mem::offset_of!(ble_l2cap_ch_tx_params_t, tx_mtu) - 0usize];
    ["Offset of field: ble_l2cap_ch_tx_params_t::peer_mps"]
        [::core::mem::offset_of!(ble_l2cap_ch_tx_params_t, peer_mps) - 2usize];
    ["Offset of field: ble_l2cap_ch_tx_params_t::tx_mps"]
        [::core::mem::offset_of!(ble_l2cap_ch_tx_params_t, tx_mps) - 4usize];
    ["Offset of field: ble_l2cap_ch_tx_params_t::credits"]
        [::core::mem::offset_of!(ble_l2cap_ch_tx_params_t, credits) - 6usize];
};
#[doc = "@brief L2CAP Channel Setup Request event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_request_t {
    #[doc = "< L2CAP channel TX parameters."]
    pub tx_params: ble_l2cap_ch_tx_params_t,
    #[doc = "< LE Protocol/Service Multiplexer."]
    pub le_psm: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_setup_request_t"][::core::mem::size_of::<ble_l2cap_evt_ch_setup_request_t>() - 10usize];
    ["Alignment of ble_l2cap_evt_ch_setup_request_t"]
        [::core::mem::align_of::<ble_l2cap_evt_ch_setup_request_t>() - 2usize];
    ["Offset of field: ble_l2cap_evt_ch_setup_request_t::tx_params"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_setup_request_t, tx_params) - 0usize];
    ["Offset of field: ble_l2cap_evt_ch_setup_request_t::le_psm"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_setup_request_t, le_psm) - 8usize];
};
#[doc = "@brief L2CAP Channel Setup Refused event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_refused_t {
    #[doc = "< Source, see @ref BLE_L2CAP_CH_SETUP_REFUSED_SRCS"]
    pub source: u8,
    #[doc = "< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES"]
    pub status: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_setup_refused_t"][::core::mem::size_of::<ble_l2cap_evt_ch_setup_refused_t>() - 4usize];
    ["Alignment of ble_l2cap_evt_ch_setup_refused_t"]
        [::core::mem::align_of::<ble_l2cap_evt_ch_setup_refused_t>() - 2usize];
    ["Offset of field: ble_l2cap_evt_ch_setup_refused_t::source"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_setup_refused_t, source) - 0usize];
    ["Offset of field: ble_l2cap_evt_ch_setup_refused_t::status"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_setup_refused_t, status) - 2usize];
};
#[doc = "@brief L2CAP Channel Setup Completed event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_setup_t {
    #[doc = "< L2CAP channel TX parameters."]
    pub tx_params: ble_l2cap_ch_tx_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_setup_t"][::core::mem::size_of::<ble_l2cap_evt_ch_setup_t>() - 8usize];
    ["Alignment of ble_l2cap_evt_ch_setup_t"][::core::mem::align_of::<ble_l2cap_evt_ch_setup_t>() - 2usize];
    ["Offset of field: ble_l2cap_evt_ch_setup_t::tx_params"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_setup_t, tx_params) - 0usize];
};
#[doc = "@brief L2CAP Channel SDU Data Buffer Released event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_sdu_buf_released_t {
    #[doc = "< Returned reception or transmission SDU data buffer. The SoftDevice\nreturns SDU data buffers supplied by the application, which have\nnot yet been returned previously via a @ref BLE_L2CAP_EVT_CH_RX or\n@ref BLE_L2CAP_EVT_CH_TX event."]
    pub sdu_buf: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_sdu_buf_released_t"]
        [::core::mem::size_of::<ble_l2cap_evt_ch_sdu_buf_released_t>() - 8usize];
    ["Alignment of ble_l2cap_evt_ch_sdu_buf_released_t"]
        [::core::mem::align_of::<ble_l2cap_evt_ch_sdu_buf_released_t>() - 4usize];
    ["Offset of field: ble_l2cap_evt_ch_sdu_buf_released_t::sdu_buf"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_sdu_buf_released_t, sdu_buf) - 0usize];
};
#[doc = "@brief L2CAP Channel Credit received event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_credit_t {
    #[doc = "< Additional credits given by the peer."]
    pub credits: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_credit_t"][::core::mem::size_of::<ble_l2cap_evt_ch_credit_t>() - 2usize];
    ["Alignment of ble_l2cap_evt_ch_credit_t"][::core::mem::align_of::<ble_l2cap_evt_ch_credit_t>() - 2usize];
    ["Offset of field: ble_l2cap_evt_ch_credit_t::credits"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_credit_t, credits) - 0usize];
};
#[doc = "@brief L2CAP Channel received SDU event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_rx_t {
    #[doc = "< Total SDU length, in bytes."]
    pub sdu_len: u16,
    #[doc = "< SDU data buffer.\n@note If there is not enough space in the buffer\n(sdu_buf.len < sdu_len) then the rest of the SDU will be\nsilently discarded by the SoftDevice."]
    pub sdu_buf: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_rx_t"][::core::mem::size_of::<ble_l2cap_evt_ch_rx_t>() - 12usize];
    ["Alignment of ble_l2cap_evt_ch_rx_t"][::core::mem::align_of::<ble_l2cap_evt_ch_rx_t>() - 4usize];
    ["Offset of field: ble_l2cap_evt_ch_rx_t::sdu_len"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_rx_t, sdu_len) - 0usize];
    ["Offset of field: ble_l2cap_evt_ch_rx_t::sdu_buf"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_rx_t, sdu_buf) - 4usize];
};
#[doc = "@brief L2CAP Channel transmitted SDU event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_evt_ch_tx_t {
    #[doc = "< SDU data buffer."]
    pub sdu_buf: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_ch_tx_t"][::core::mem::size_of::<ble_l2cap_evt_ch_tx_t>() - 8usize];
    ["Alignment of ble_l2cap_evt_ch_tx_t"][::core::mem::align_of::<ble_l2cap_evt_ch_tx_t>() - 4usize];
    ["Offset of field: ble_l2cap_evt_ch_tx_t::sdu_buf"]
        [::core::mem::offset_of!(ble_l2cap_evt_ch_tx_t, sdu_buf) - 0usize];
};
#[doc = "@brief L2CAP event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_l2cap_evt_t {
    #[doc = "< Connection Handle on which the event occured."]
    pub conn_handle: u16,
    #[doc = "< Local Channel ID of the L2CAP channel, or\n@ref BLE_L2CAP_CID_INVALID if not present."]
    pub local_cid: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_l2cap_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_l2cap_evt_t__bindgen_ty_1 {
    #[doc = "< L2CAP Channel Setup Request Event Parameters."]
    pub ch_setup_request: ble_l2cap_evt_ch_setup_request_t,
    #[doc = "< L2CAP Channel Setup Refused Event Parameters."]
    pub ch_setup_refused: ble_l2cap_evt_ch_setup_refused_t,
    #[doc = "< L2CAP Channel Setup Completed Event Parameters."]
    pub ch_setup: ble_l2cap_evt_ch_setup_t,
    #[doc = "< L2CAP Channel SDU Data Buffer Released Event Parameters."]
    pub ch_sdu_buf_released: ble_l2cap_evt_ch_sdu_buf_released_t,
    #[doc = "< L2CAP Channel Credit Received Event Parameters."]
    pub credit: ble_l2cap_evt_ch_credit_t,
    #[doc = "< L2CAP Channel SDU Received Event Parameters."]
    pub rx: ble_l2cap_evt_ch_rx_t,
    #[doc = "< L2CAP Channel SDU Transmitted Event Parameters."]
    pub tx: ble_l2cap_evt_ch_tx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_l2cap_evt_t__bindgen_ty_1>() - 12usize];
    ["Alignment of ble_l2cap_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_l2cap_evt_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::ch_setup_request"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, ch_setup_request) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::ch_setup_refused"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, ch_setup_refused) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::ch_setup"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, ch_setup) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::ch_sdu_buf_released"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, ch_sdu_buf_released) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::credit"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, credit) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::rx"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, rx) - 0usize];
    ["Offset of field: ble_l2cap_evt_t__bindgen_ty_1::tx"]
        [::core::mem::offset_of!(ble_l2cap_evt_t__bindgen_ty_1, tx) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_l2cap_evt_t"][::core::mem::size_of::<ble_l2cap_evt_t>() - 16usize];
    ["Alignment of ble_l2cap_evt_t"][::core::mem::align_of::<ble_l2cap_evt_t>() - 4usize];
    ["Offset of field: ble_l2cap_evt_t::conn_handle"][::core::mem::offset_of!(ble_l2cap_evt_t, conn_handle) - 0usize];
    ["Offset of field: ble_l2cap_evt_t::local_cid"][::core::mem::offset_of!(ble_l2cap_evt_t, local_cid) - 2usize];
    ["Offset of field: ble_l2cap_evt_t::params"][::core::mem::offset_of!(ble_l2cap_evt_t, params) - 4usize];
};

#[doc = "@brief Set up an L2CAP channel.\n\n @details This function is used to:\n          - Request setup of an L2CAP channel: sends an LE Credit Based Connection Request packet to a peer.\n          - Reply to a setup request of an L2CAP channel (if called in response to a\n            @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST event): sends an LE Credit Based Connection\n            Response packet to a peer.\n\n @note    A call to this function will require the application to keep the SDU data buffer alive\n          until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX or\n          @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.\n\n @events\n @event{@ref BLE_L2CAP_EVT_CH_SETUP, Setup successful.}\n @event{@ref BLE_L2CAP_EVT_CH_SETUP_REFUSED, Setup failed.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_L2CAP_CH_SETUP_MSC}\n @endmscs\n\n @param[in] conn_handle      Connection Handle.\n @param[in,out] p_local_cid  Pointer to a uint16_t containing Local Channel ID of the L2CAP channel:\n                             - As input: @ref BLE_L2CAP_CID_INVALID when requesting setup of an L2CAP\n                               channel or local_cid provided in the @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST\n                               event when replying to a setup request of an L2CAP channel.\n                             - As output: local_cid for this channel.\n @param[in] p_params         L2CAP channel parameters.\n\n @retval ::NRF_SUCCESS                    Successfully queued request or response for transmission.\n @retval ::NRF_ERROR_BUSY                 The stack is busy, process pending events and retry.\n @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_PARAM        Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_LENGTH       Supplied higher rx_mps than has been configured on this link.\n @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (L2CAP channel already set up).\n @retval ::NRF_ERROR_NOT_FOUND            CID not found.\n @retval ::NRF_ERROR_RESOURCES            The limit has been reached for available L2CAP channels,\n                                          see @ref ble_l2cap_conn_cfg_t::ch_count."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_setup(
    conn_handle: u16,
    p_local_cid: *mut u16,
    p_params: *const ble_l2cap_ch_setup_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 184",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_local_cid) => _,
        inout("r2") to_asm(p_params) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Release an L2CAP channel.\n\n @details This sends a Disconnection Request packet to a peer.\n\n @events\n @event{@ref BLE_L2CAP_EVT_CH_RELEASED, Release complete.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_L2CAP_CH_RELEASE_MSC}\n @endmscs\n\n @param[in] conn_handle   Connection Handle.\n @param[in] local_cid     Local Channel ID of the L2CAP channel.\n\n @retval ::NRF_SUCCESS                    Successfully queued request for transmission.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is\n                                          in progress for the L2CAP channel).\n @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_release(conn_handle: u16, local_cid: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 185",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Receive an SDU on an L2CAP channel.\n\n @details This may issue additional credits to the peer using an LE Flow Control Credit packet.\n\n @note    A call to this function will require the application to keep the memory pointed by\n          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX\n          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.\n\n @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::rx_queue_size SDU data buffers\n          for reception per L2CAP channel.\n\n @events\n @event{@ref BLE_L2CAP_EVT_CH_RX, The SDU is received.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_L2CAP_CH_RX_MSC}\n @endmscs\n\n @param[in] conn_handle Connection Handle.\n @param[in] local_cid   Local Channel ID of the L2CAP channel.\n @param[in] p_sdu_buf   Pointer to the SDU data buffer.\n\n @retval ::NRF_SUCCESS                    Buffer accepted.\n @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is\n                                          in progress for an L2CAP channel).\n @retval ::NRF_ERROR_NOT_FOUND            CID not found.\n @retval ::NRF_ERROR_RESOURCES            Too many SDU data buffers supplied. Wait for a\n                                          @ref BLE_L2CAP_EVT_CH_RX event and retry."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_rx(conn_handle: u16, local_cid: u16, p_sdu_buf: *const ble_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 186",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(p_sdu_buf) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Transmit an SDU on an L2CAP channel.\n\n @note    A call to this function will require the application to keep the memory pointed by\n          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_TX\n          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.\n\n @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::tx_queue_size SDUs for\n          transmission per L2CAP channel.\n\n @note    The application can keep track of the available credits for transmission by following\n          the procedure below:\n          - Store initial credits given by the peer in a variable.\n            (Initial credits are provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)\n          - Decrement the variable, which stores the currently available credits, by\n            ceiling((@ref ble_data_t::len + 2) / tx_mps) when a call to this function returns\n            @ref NRF_SUCCESS. (tx_mps is provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)\n          - Increment the variable, which stores the currently available credits, by additional\n            credits given by the peer in a @ref BLE_L2CAP_EVT_CH_CREDIT event.\n\n @events\n @event{@ref BLE_L2CAP_EVT_CH_TX, The SDU is transmitted.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_L2CAP_CH_TX_MSC}\n @endmscs\n\n @param[in] conn_handle Connection Handle.\n @param[in] local_cid   Local Channel ID of the L2CAP channel.\n @param[in] p_sdu_buf   Pointer to the SDU data buffer.\n\n @retval ::NRF_SUCCESS                    Successfully queued L2CAP SDU for transmission.\n @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is\n                                          in progress for the L2CAP channel).\n @retval ::NRF_ERROR_NOT_FOUND            CID not found.\n @retval ::NRF_ERROR_DATA_SIZE            Invalid SDU length supplied, must not be more than\n                                          @ref ble_l2cap_ch_tx_params_t::tx_mtu provided in\n                                          @ref BLE_L2CAP_EVT_CH_SETUP event.\n @retval ::NRF_ERROR_RESOURCES            Too many SDUs queued for transmission. Wait for a\n                                          @ref BLE_L2CAP_EVT_CH_TX event and retry."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_tx(conn_handle: u16, local_cid: u16, p_sdu_buf: *const ble_data_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 187",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(p_sdu_buf) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Advanced SDU reception flow control.\n\n @details Adjust the way the SoftDevice issues credits to the peer.\n          This may issue additional credits to the peer using an LE Flow Control Credit packet.\n\n @mscs\n @mmsc{@ref BLE_L2CAP_CH_FLOW_CONTROL_MSC}\n @endmscs\n\n @param[in] conn_handle Connection Handle.\n @param[in] local_cid   Local Channel ID of the L2CAP channel or @ref BLE_L2CAP_CID_INVALID to set\n                        the value that will be used for newly created channels.\n @param[in] credits     Number of credits that the SoftDevice will make sure the peer has every\n                        time it starts using a new reception buffer.\n                        - @ref BLE_L2CAP_CREDITS_DEFAULT is the default value the SoftDevice will\n                          use if this function is not called.\n                        - If set to zero, the SoftDevice will stop issuing credits for new reception\n                          buffers the application provides or has provided. SDU reception that is\n                          currently ongoing will be allowed to complete.\n @param[out] p_credits  NULL or pointer to a uint16_t. If a valid pointer is provided, it will be\n                        written by the SoftDevice with the number of credits that is or will be\n                        available to the peer. If the value written by the SoftDevice is 0 when\n                        credits parameter was set to 0, the peer will not be able to send more\n                        data until more credits are provided by calling this function again with\n                        credits > 0. This parameter is ignored when local_cid is set to\n                        @ref BLE_L2CAP_CID_INVALID.\n\n @note Application should take care when setting number of credits higher than default value. In\n       this case the application must make sure that the SoftDevice always has reception buffers\n       available (see @ref sd_ble_l2cap_ch_rx) for that channel. If the SoftDevice does not have\n       such buffers available, packets may be NACKed on the Link Layer and all Bluetooth traffic\n       on the connection handle may be stalled until the SoftDevice again has an available\n       reception buffer. This applies even if the application has used this call to set the\n       credits back to default, or zero.\n\n @retval ::NRF_SUCCESS                    Flow control parameters accepted.\n @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is\n                                          in progress for an L2CAP channel).\n @retval ::NRF_ERROR_NOT_FOUND            CID not found."]
#[inline(always)]
pub unsafe fn sd_ble_l2cap_ch_flow_control(conn_handle: u16, local_cid: u16, credits: u16, p_credits: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 188",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(local_cid) => _,
        inout("r2") to_asm(credits) => _,
        inout("r3") to_asm(p_credits) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief BLE GATT connection configuration parameters, set with @ref sd_ble_cfg_set.\n\n @retval ::NRF_ERROR_INVALID_PARAM att_mtu is smaller than @ref BLE_GATT_ATT_MTU_DEFAULT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_conn_cfg_t {
    #[doc = "< Maximum size of ATT packet the SoftDevice can send or receive.\nThe default and minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT.\n@mscs\n@mmsc{@ref BLE_GATTC_MTU_EXCHANGE}\n@mmsc{@ref BLE_GATTS_MTU_EXCHANGE}\n@endmscs"]
    pub att_mtu: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatt_conn_cfg_t"][::core::mem::size_of::<ble_gatt_conn_cfg_t>() - 2usize];
    ["Alignment of ble_gatt_conn_cfg_t"][::core::mem::align_of::<ble_gatt_conn_cfg_t>() - 2usize];
    ["Offset of field: ble_gatt_conn_cfg_t::att_mtu"][::core::mem::offset_of!(ble_gatt_conn_cfg_t, att_mtu) - 0usize];
};
#[doc = "@brief GATT Characteristic Properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_char_props_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatt_char_props_t"][::core::mem::size_of::<ble_gatt_char_props_t>() - 1usize];
    ["Alignment of ble_gatt_char_props_t"][::core::mem::align_of::<ble_gatt_char_props_t>() - 1usize];
};
impl ble_gatt_char_props_t {
    #[inline]
    pub fn broadcast(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn broadcast_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_broadcast_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn read(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn read_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_read_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn write_wo_resp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_wo_resp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn write_wo_resp_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_write_wo_resp_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn write(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn write_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_write_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn notify(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_notify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn notify_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_notify_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn indicate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn indicate_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_indicate_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auth_signed_wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_signed_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_signed_wr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_signed_wr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        broadcast: u8,
        read: u8,
        write_wo_resp: u8,
        write: u8,
        notify: u8,
        indicate: u8,
        auth_signed_wr: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let broadcast: u8 = unsafe { ::core::mem::transmute(broadcast) };
            broadcast as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let read: u8 = unsafe { ::core::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let write_wo_resp: u8 = unsafe { ::core::mem::transmute(write_wo_resp) };
            write_wo_resp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write: u8 = unsafe { ::core::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let notify: u8 = unsafe { ::core::mem::transmute(notify) };
            notify as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let indicate: u8 = unsafe { ::core::mem::transmute(indicate) };
            indicate as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let auth_signed_wr: u8 = unsafe { ::core::mem::transmute(auth_signed_wr) };
            auth_signed_wr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Characteristic Extended Properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_char_ext_props_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatt_char_ext_props_t"][::core::mem::size_of::<ble_gatt_char_ext_props_t>() - 1usize];
    ["Alignment of ble_gatt_char_ext_props_t"][::core::mem::align_of::<ble_gatt_char_ext_props_t>() - 1usize];
};
impl ble_gatt_char_ext_props_t {
    #[inline]
    pub fn reliable_wr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reliable_wr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reliable_wr_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reliable_wr_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wr_aux(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr_aux(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wr_aux_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wr_aux_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(reliable_wr: u8, wr_aux: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reliable_wr: u8 = unsafe { ::core::mem::transmute(reliable_wr) };
            reliable_wr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr_aux: u8 = unsafe { ::core::mem::transmute(wr_aux) };
            wr_aux as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Primary Service Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER: BLE_GATTC_SVCS = 155;
#[doc = "< Relationship Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_RELATIONSHIPS_DISCOVER: BLE_GATTC_SVCS = 156;
#[doc = "< Characteristic Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHARACTERISTICS_DISCOVER: BLE_GATTC_SVCS = 157;
#[doc = "< Characteristic Descriptor Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_DESCRIPTORS_DISCOVER: BLE_GATTC_SVCS = 158;
#[doc = "< Attribute Information Discovery."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_ATTR_INFO_DISCOVER: BLE_GATTC_SVCS = 159;
#[doc = "< Read Characteristic Value by UUID."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ: BLE_GATTC_SVCS = 160;
#[doc = "< Generic read."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_READ: BLE_GATTC_SVCS = 161;
#[doc = "< Read multiple Characteristic Values."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_CHAR_VALUES_READ: BLE_GATTC_SVCS = 162;
#[doc = "< Generic write."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_WRITE: BLE_GATTC_SVCS = 163;
#[doc = "< Handle Value Confirmation."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_HV_CONFIRM: BLE_GATTC_SVCS = 164;
#[doc = "< Exchange MTU Request."]
pub const BLE_GATTC_SVCS_SD_BLE_GATTC_EXCHANGE_MTU_REQUEST: BLE_GATTC_SVCS = 165;
#[doc = "@brief GATTC API SVC numbers."]
pub type BLE_GATTC_SVCS = self::c_uint;
#[doc = "< Primary Service Discovery Response event.          \\n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP: BLE_GATTC_EVTS = 48;
#[doc = "< Relationship Discovery Response event.             \\n See @ref ble_gattc_evt_rel_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_REL_DISC_RSP: BLE_GATTC_EVTS = 49;
#[doc = "< Characteristic Discovery Response event.           \\n See @ref ble_gattc_evt_char_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_DISC_RSP: BLE_GATTC_EVTS = 50;
#[doc = "< Descriptor Discovery Response event.               \\n See @ref ble_gattc_evt_desc_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_DESC_DISC_RSP: BLE_GATTC_EVTS = 51;
#[doc = "< Attribute Information Response event.              \\n See @ref ble_gattc_evt_attr_info_disc_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_ATTR_INFO_DISC_RSP: BLE_GATTC_EVTS = 52;
#[doc = "< Read By UUID Response event.                       \\n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP: BLE_GATTC_EVTS = 53;
#[doc = "< Read Response event.                               \\n See @ref ble_gattc_evt_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_READ_RSP: BLE_GATTC_EVTS = 54;
#[doc = "< Read multiple Response event.                      \\n See @ref ble_gattc_evt_char_vals_read_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_CHAR_VALS_READ_RSP: BLE_GATTC_EVTS = 55;
#[doc = "< Write Response event.                              \\n See @ref ble_gattc_evt_write_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_WRITE_RSP: BLE_GATTC_EVTS = 56;
#[doc = "< Handle Value Notification or Indication event.     \\n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \\n See @ref ble_gattc_evt_hvx_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_HVX: BLE_GATTC_EVTS = 57;
#[doc = "< Exchange MTU Response event.                       \\n See @ref ble_gattc_evt_exchange_mtu_rsp_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_EXCHANGE_MTU_RSP: BLE_GATTC_EVTS = 58;
#[doc = "< Timeout event.                                     \\n See @ref ble_gattc_evt_timeout_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_TIMEOUT: BLE_GATTC_EVTS = 59;
#[doc = "< Write without Response transmission complete.      \\n See @ref ble_gattc_evt_write_cmd_tx_complete_t."]
pub const BLE_GATTC_EVTS_BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE: BLE_GATTC_EVTS = 60;
#[doc = " @brief GATT Client Event IDs."]
pub type BLE_GATTC_EVTS = self::c_uint;
#[doc = " @brief BLE GATTC connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_conn_cfg_t {
    #[doc = "< The guaranteed minimum number of Write without Response that can be queued for transmission.\nThe default value is @ref BLE_GATTC_WRITE_CMD_TX_QUEUE_SIZE_DEFAULT"]
    pub write_cmd_tx_queue_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_conn_cfg_t"][::core::mem::size_of::<ble_gattc_conn_cfg_t>() - 1usize];
    ["Alignment of ble_gattc_conn_cfg_t"][::core::mem::align_of::<ble_gattc_conn_cfg_t>() - 1usize];
    ["Offset of field: ble_gattc_conn_cfg_t::write_cmd_tx_queue_size"]
        [::core::mem::offset_of!(ble_gattc_conn_cfg_t, write_cmd_tx_queue_size) - 0usize];
};
#[doc = "@brief Operation Handle Range."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_handle_range_t {
    #[doc = "< Start Handle."]
    pub start_handle: u16,
    #[doc = "< End Handle."]
    pub end_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_handle_range_t"][::core::mem::size_of::<ble_gattc_handle_range_t>() - 4usize];
    ["Alignment of ble_gattc_handle_range_t"][::core::mem::align_of::<ble_gattc_handle_range_t>() - 2usize];
    ["Offset of field: ble_gattc_handle_range_t::start_handle"]
        [::core::mem::offset_of!(ble_gattc_handle_range_t, start_handle) - 0usize];
    ["Offset of field: ble_gattc_handle_range_t::end_handle"]
        [::core::mem::offset_of!(ble_gattc_handle_range_t, end_handle) - 2usize];
};
#[doc = "@brief GATT service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_service_t {
    #[doc = "< Service UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Service Handle Range."]
    pub handle_range: ble_gattc_handle_range_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_service_t"][::core::mem::size_of::<ble_gattc_service_t>() - 8usize];
    ["Alignment of ble_gattc_service_t"][::core::mem::align_of::<ble_gattc_service_t>() - 2usize];
    ["Offset of field: ble_gattc_service_t::uuid"][::core::mem::offset_of!(ble_gattc_service_t, uuid) - 0usize];
    ["Offset of field: ble_gattc_service_t::handle_range"]
        [::core::mem::offset_of!(ble_gattc_service_t, handle_range) - 4usize];
};
#[doc = "@brief  GATT include."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_include_t {
    #[doc = "< Include Handle."]
    pub handle: u16,
    #[doc = "< Handle of the included service."]
    pub included_srvc: ble_gattc_service_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_include_t"][::core::mem::size_of::<ble_gattc_include_t>() - 10usize];
    ["Alignment of ble_gattc_include_t"][::core::mem::align_of::<ble_gattc_include_t>() - 2usize];
    ["Offset of field: ble_gattc_include_t::handle"][::core::mem::offset_of!(ble_gattc_include_t, handle) - 0usize];
    ["Offset of field: ble_gattc_include_t::included_srvc"]
        [::core::mem::offset_of!(ble_gattc_include_t, included_srvc) - 2usize];
};
#[doc = "@brief GATT characteristic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_char_t {
    #[doc = "< Characteristic UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Characteristic Properties."]
    pub char_props: ble_gatt_char_props_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Handle of the Characteristic Declaration."]
    pub handle_decl: u16,
    #[doc = "< Handle of the Characteristic Value."]
    pub handle_value: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_char_t"][::core::mem::size_of::<ble_gattc_char_t>() - 10usize];
    ["Alignment of ble_gattc_char_t"][::core::mem::align_of::<ble_gattc_char_t>() - 2usize];
    ["Offset of field: ble_gattc_char_t::uuid"][::core::mem::offset_of!(ble_gattc_char_t, uuid) - 0usize];
    ["Offset of field: ble_gattc_char_t::char_props"][::core::mem::offset_of!(ble_gattc_char_t, char_props) - 4usize];
    ["Offset of field: ble_gattc_char_t::handle_decl"][::core::mem::offset_of!(ble_gattc_char_t, handle_decl) - 6usize];
    ["Offset of field: ble_gattc_char_t::handle_value"]
        [::core::mem::offset_of!(ble_gattc_char_t, handle_value) - 8usize];
};
impl ble_gattc_char_t {
    #[inline]
    pub fn char_ext_props(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_char_ext_props(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn char_ext_props_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_char_ext_props_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(char_ext_props: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let char_ext_props: u8 = unsafe { ::core::mem::transmute(char_ext_props) };
            char_ext_props as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_desc_t {
    #[doc = "< Descriptor Handle."]
    pub handle: u16,
    #[doc = "< Descriptor UUID."]
    pub uuid: ble_uuid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_desc_t"][::core::mem::size_of::<ble_gattc_desc_t>() - 6usize];
    ["Alignment of ble_gattc_desc_t"][::core::mem::align_of::<ble_gattc_desc_t>() - 2usize];
    ["Offset of field: ble_gattc_desc_t::handle"][::core::mem::offset_of!(ble_gattc_desc_t, handle) - 0usize];
    ["Offset of field: ble_gattc_desc_t::uuid"][::core::mem::offset_of!(ble_gattc_desc_t, uuid) - 2usize];
};
#[doc = "@brief Write Parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_write_params_t {
    #[doc = "< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS."]
    pub write_op: u8,
    #[doc = "< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS."]
    pub flags: u8,
    #[doc = "< Handle to the attribute to be written."]
    pub handle: u16,
    #[doc = "< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0."]
    pub offset: u16,
    #[doc = "< Length of data in bytes."]
    pub len: u16,
    #[doc = "< Pointer to the value data."]
    pub p_value: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_write_params_t"][::core::mem::size_of::<ble_gattc_write_params_t>() - 12usize];
    ["Alignment of ble_gattc_write_params_t"][::core::mem::align_of::<ble_gattc_write_params_t>() - 4usize];
    ["Offset of field: ble_gattc_write_params_t::write_op"]
        [::core::mem::offset_of!(ble_gattc_write_params_t, write_op) - 0usize];
    ["Offset of field: ble_gattc_write_params_t::flags"]
        [::core::mem::offset_of!(ble_gattc_write_params_t, flags) - 1usize];
    ["Offset of field: ble_gattc_write_params_t::handle"]
        [::core::mem::offset_of!(ble_gattc_write_params_t, handle) - 2usize];
    ["Offset of field: ble_gattc_write_params_t::offset"]
        [::core::mem::offset_of!(ble_gattc_write_params_t, offset) - 4usize];
    ["Offset of field: ble_gattc_write_params_t::len"][::core::mem::offset_of!(ble_gattc_write_params_t, len) - 6usize];
    ["Offset of field: ble_gattc_write_params_t::p_value"]
        [::core::mem::offset_of!(ble_gattc_write_params_t, p_value) - 8usize];
};
#[doc = "@brief Attribute Information for 16-bit Attribute UUID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_attr_info16_t {
    #[doc = "< Attribute handle."]
    pub handle: u16,
    #[doc = "< 16-bit Attribute UUID."]
    pub uuid: ble_uuid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_attr_info16_t"][::core::mem::size_of::<ble_gattc_attr_info16_t>() - 6usize];
    ["Alignment of ble_gattc_attr_info16_t"][::core::mem::align_of::<ble_gattc_attr_info16_t>() - 2usize];
    ["Offset of field: ble_gattc_attr_info16_t::handle"]
        [::core::mem::offset_of!(ble_gattc_attr_info16_t, handle) - 0usize];
    ["Offset of field: ble_gattc_attr_info16_t::uuid"][::core::mem::offset_of!(ble_gattc_attr_info16_t, uuid) - 2usize];
};
#[doc = "@brief Attribute Information for 128-bit Attribute UUID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_attr_info128_t {
    #[doc = "< Attribute handle."]
    pub handle: u16,
    #[doc = "< 128-bit Attribute UUID."]
    pub uuid: ble_uuid128_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_attr_info128_t"][::core::mem::size_of::<ble_gattc_attr_info128_t>() - 18usize];
    ["Alignment of ble_gattc_attr_info128_t"][::core::mem::align_of::<ble_gattc_attr_info128_t>() - 2usize];
    ["Offset of field: ble_gattc_attr_info128_t::handle"]
        [::core::mem::offset_of!(ble_gattc_attr_info128_t, handle) - 0usize];
    ["Offset of field: ble_gattc_attr_info128_t::uuid"]
        [::core::mem::offset_of!(ble_gattc_attr_info128_t, uuid) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_prim_srvc_disc_rsp_t {
    #[doc = "< Service count."]
    pub count: u16,
    #[doc = "< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub services: __IncompleteArrayField<ble_gattc_service_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_prim_srvc_disc_rsp_t"]
        [::core::mem::size_of::<ble_gattc_evt_prim_srvc_disc_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_prim_srvc_disc_rsp_t"]
        [::core::mem::align_of::<ble_gattc_evt_prim_srvc_disc_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_prim_srvc_disc_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_prim_srvc_disc_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_prim_srvc_disc_rsp_t::services"]
        [::core::mem::offset_of!(ble_gattc_evt_prim_srvc_disc_rsp_t, services) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_REL_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_rel_disc_rsp_t {
    #[doc = "< Include count."]
    pub count: u16,
    #[doc = "< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub includes: __IncompleteArrayField<ble_gattc_include_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_rel_disc_rsp_t"][::core::mem::size_of::<ble_gattc_evt_rel_disc_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_rel_disc_rsp_t"][::core::mem::align_of::<ble_gattc_evt_rel_disc_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_rel_disc_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_rel_disc_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_rel_disc_rsp_t::includes"]
        [::core::mem::offset_of!(ble_gattc_evt_rel_disc_rsp_t, includes) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_disc_rsp_t {
    #[doc = "< Characteristic count."]
    pub count: u16,
    #[doc = "< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub chars: __IncompleteArrayField<ble_gattc_char_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_char_disc_rsp_t"][::core::mem::size_of::<ble_gattc_evt_char_disc_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_char_disc_rsp_t"][::core::mem::align_of::<ble_gattc_evt_char_disc_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_char_disc_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_char_disc_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_char_disc_rsp_t::chars"]
        [::core::mem::offset_of!(ble_gattc_evt_char_disc_rsp_t, chars) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_DESC_DISC_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_desc_disc_rsp_t {
    #[doc = "< Descriptor count."]
    pub count: u16,
    #[doc = "< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub descs: __IncompleteArrayField<ble_gattc_desc_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_desc_disc_rsp_t"][::core::mem::size_of::<ble_gattc_evt_desc_disc_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_desc_disc_rsp_t"][::core::mem::align_of::<ble_gattc_evt_desc_disc_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_desc_disc_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_desc_disc_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_desc_disc_rsp_t::descs"]
        [::core::mem::offset_of!(ble_gattc_evt_desc_disc_rsp_t, descs) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP."]
#[repr(C)]
pub struct ble_gattc_evt_attr_info_disc_rsp_t {
    #[doc = "< Attribute count."]
    pub count: u16,
    #[doc = "< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT."]
    pub format: u8,
    #[doc = "< Attribute information union."]
    pub info: ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1 {
    #[doc = "< Attribute information for 16-bit Attribute UUID.\n@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub attr_info16: __BindgenUnionField<[ble_gattc_attr_info16_t; 0usize]>,
    #[doc = "< Attribute information for 128-bit Attribute UUID.\n@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub attr_info128: __BindgenUnionField<[ble_gattc_attr_info128_t; 0usize]>,
    pub bindgen_union_field: [u16; 0usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1"]
        [::core::mem::size_of::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>() - 0usize];
    ["Alignment of ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1"]
        [::core::mem::align_of::<ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1::attr_info16"]
        [::core::mem::offset_of!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1, attr_info16) - 0usize];
    ["Offset of field: ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1::attr_info128"]
        [::core::mem::offset_of!(ble_gattc_evt_attr_info_disc_rsp_t__bindgen_ty_1, attr_info128) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_attr_info_disc_rsp_t"]
        [::core::mem::size_of::<ble_gattc_evt_attr_info_disc_rsp_t>() - 4usize];
    ["Alignment of ble_gattc_evt_attr_info_disc_rsp_t"]
        [::core::mem::align_of::<ble_gattc_evt_attr_info_disc_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_attr_info_disc_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_attr_info_disc_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_attr_info_disc_rsp_t::format"]
        [::core::mem::offset_of!(ble_gattc_evt_attr_info_disc_rsp_t, format) - 2usize];
    ["Offset of field: ble_gattc_evt_attr_info_disc_rsp_t::info"]
        [::core::mem::offset_of!(ble_gattc_evt_attr_info_disc_rsp_t, info) - 4usize];
};
#[doc = "@brief GATT read by UUID handle value pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_handle_value_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len."]
    pub p_value: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_handle_value_t"][::core::mem::size_of::<ble_gattc_handle_value_t>() - 8usize];
    ["Alignment of ble_gattc_handle_value_t"][::core::mem::align_of::<ble_gattc_handle_value_t>() - 4usize];
    ["Offset of field: ble_gattc_handle_value_t::handle"]
        [::core::mem::offset_of!(ble_gattc_handle_value_t, handle) - 0usize];
    ["Offset of field: ble_gattc_handle_value_t::p_value"]
        [::core::mem::offset_of!(ble_gattc_handle_value_t, p_value) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_val_by_uuid_read_rsp_t {
    #[doc = "< Handle-Value Pair Count."]
    pub count: u16,
    #[doc = "< Length of the value in Handle-Value(s) list."]
    pub value_len: u16,
    #[doc = "< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter.\n@note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub handle_value: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_char_val_by_uuid_read_rsp_t"]
        [::core::mem::size_of::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>() - 4usize];
    ["Alignment of ble_gattc_evt_char_val_by_uuid_read_rsp_t"]
        [::core::mem::align_of::<ble_gattc_evt_char_val_by_uuid_read_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_char_val_by_uuid_read_rsp_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_char_val_by_uuid_read_rsp_t, count) - 0usize];
    ["Offset of field: ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len"]
        [::core::mem::offset_of!(ble_gattc_evt_char_val_by_uuid_read_rsp_t, value_len) - 2usize];
    ["Offset of field: ble_gattc_evt_char_val_by_uuid_read_rsp_t::handle_value"]
        [::core::mem::offset_of!(ble_gattc_evt_char_val_by_uuid_read_rsp_t, handle_value) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_read_rsp_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Offset of the attribute data."]
    pub offset: u16,
    #[doc = "< Attribute data length."]
    pub len: u16,
    #[doc = "< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_read_rsp_t"][::core::mem::size_of::<ble_gattc_evt_read_rsp_t>() - 6usize];
    ["Alignment of ble_gattc_evt_read_rsp_t"][::core::mem::align_of::<ble_gattc_evt_read_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_read_rsp_t::handle"]
        [::core::mem::offset_of!(ble_gattc_evt_read_rsp_t, handle) - 0usize];
    ["Offset of field: ble_gattc_evt_read_rsp_t::offset"]
        [::core::mem::offset_of!(ble_gattc_evt_read_rsp_t, offset) - 2usize];
    ["Offset of field: ble_gattc_evt_read_rsp_t::len"][::core::mem::offset_of!(ble_gattc_evt_read_rsp_t, len) - 4usize];
    ["Offset of field: ble_gattc_evt_read_rsp_t::data"]
        [::core::mem::offset_of!(ble_gattc_evt_read_rsp_t, data) - 6usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_char_vals_read_rsp_t {
    #[doc = "< Concatenated Attribute values length."]
    pub len: u16,
    #[doc = "< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub values: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_char_vals_read_rsp_t"]
        [::core::mem::size_of::<ble_gattc_evt_char_vals_read_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_char_vals_read_rsp_t"]
        [::core::mem::align_of::<ble_gattc_evt_char_vals_read_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_char_vals_read_rsp_t::len"]
        [::core::mem::offset_of!(ble_gattc_evt_char_vals_read_rsp_t, len) - 0usize];
    ["Offset of field: ble_gattc_evt_char_vals_read_rsp_t::values"]
        [::core::mem::offset_of!(ble_gattc_evt_char_vals_read_rsp_t, values) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_WRITE_RSP."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_write_rsp_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Type of write operation, see @ref BLE_GATT_WRITE_OPS."]
    pub write_op: u8,
    #[doc = "< Data offset."]
    pub offset: u16,
    #[doc = "< Data length."]
    pub len: u16,
    #[doc = "< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_write_rsp_t"][::core::mem::size_of::<ble_gattc_evt_write_rsp_t>() - 8usize];
    ["Alignment of ble_gattc_evt_write_rsp_t"][::core::mem::align_of::<ble_gattc_evt_write_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_write_rsp_t::handle"]
        [::core::mem::offset_of!(ble_gattc_evt_write_rsp_t, handle) - 0usize];
    ["Offset of field: ble_gattc_evt_write_rsp_t::write_op"]
        [::core::mem::offset_of!(ble_gattc_evt_write_rsp_t, write_op) - 2usize];
    ["Offset of field: ble_gattc_evt_write_rsp_t::offset"]
        [::core::mem::offset_of!(ble_gattc_evt_write_rsp_t, offset) - 4usize];
    ["Offset of field: ble_gattc_evt_write_rsp_t::len"]
        [::core::mem::offset_of!(ble_gattc_evt_write_rsp_t, len) - 6usize];
    ["Offset of field: ble_gattc_evt_write_rsp_t::data"]
        [::core::mem::offset_of!(ble_gattc_evt_write_rsp_t, data) - 8usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_HVX."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gattc_evt_hvx_t {
    #[doc = "< Handle to which the HVx operation applies."]
    pub handle: u16,
    #[doc = "< Indication or Notification, see @ref BLE_GATT_HVX_TYPES."]
    pub type_: u8,
    #[doc = "< Attribute data length."]
    pub len: u16,
    #[doc = "< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_hvx_t"][::core::mem::size_of::<ble_gattc_evt_hvx_t>() - 6usize];
    ["Alignment of ble_gattc_evt_hvx_t"][::core::mem::align_of::<ble_gattc_evt_hvx_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_hvx_t::handle"][::core::mem::offset_of!(ble_gattc_evt_hvx_t, handle) - 0usize];
    ["Offset of field: ble_gattc_evt_hvx_t::type_"][::core::mem::offset_of!(ble_gattc_evt_hvx_t, type_) - 2usize];
    ["Offset of field: ble_gattc_evt_hvx_t::len"][::core::mem::offset_of!(ble_gattc_evt_hvx_t, len) - 4usize];
    ["Offset of field: ble_gattc_evt_hvx_t::data"][::core::mem::offset_of!(ble_gattc_evt_hvx_t, data) - 6usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_exchange_mtu_rsp_t {
    #[doc = "< Server RX MTU size."]
    pub server_rx_mtu: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_exchange_mtu_rsp_t"][::core::mem::size_of::<ble_gattc_evt_exchange_mtu_rsp_t>() - 2usize];
    ["Alignment of ble_gattc_evt_exchange_mtu_rsp_t"]
        [::core::mem::align_of::<ble_gattc_evt_exchange_mtu_rsp_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_exchange_mtu_rsp_t::server_rx_mtu"]
        [::core::mem::offset_of!(ble_gattc_evt_exchange_mtu_rsp_t, server_rx_mtu) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_timeout_t {
    #[doc = "< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES."]
    pub src: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_timeout_t"][::core::mem::size_of::<ble_gattc_evt_timeout_t>() - 1usize];
    ["Alignment of ble_gattc_evt_timeout_t"][::core::mem::align_of::<ble_gattc_evt_timeout_t>() - 1usize];
    ["Offset of field: ble_gattc_evt_timeout_t::src"][::core::mem::offset_of!(ble_gattc_evt_timeout_t, src) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gattc_evt_write_cmd_tx_complete_t {
    #[doc = "< Number of write without response transmissions completed."]
    pub count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_write_cmd_tx_complete_t"]
        [::core::mem::size_of::<ble_gattc_evt_write_cmd_tx_complete_t>() - 1usize];
    ["Alignment of ble_gattc_evt_write_cmd_tx_complete_t"]
        [::core::mem::align_of::<ble_gattc_evt_write_cmd_tx_complete_t>() - 1usize];
    ["Offset of field: ble_gattc_evt_write_cmd_tx_complete_t::count"]
        [::core::mem::offset_of!(ble_gattc_evt_write_cmd_tx_complete_t, count) - 0usize];
};
#[doc = "@brief GATTC event structure."]
#[repr(C)]
pub struct ble_gattc_evt_t {
    #[doc = "< Connection Handle on which event occurred."]
    pub conn_handle: u16,
    #[doc = "< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES."]
    pub gatt_status: u16,
    #[doc = "< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID."]
    pub error_handle: u16,
    #[doc = "< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS."]
    pub params: ble_gattc_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gattc_evt_t__bindgen_ty_1 {
    #[doc = "< Primary Service Discovery Response Event Parameters."]
    pub prim_srvc_disc_rsp: __BindgenUnionField<ble_gattc_evt_prim_srvc_disc_rsp_t>,
    #[doc = "< Relationship Discovery Response Event Parameters."]
    pub rel_disc_rsp: __BindgenUnionField<ble_gattc_evt_rel_disc_rsp_t>,
    #[doc = "< Characteristic Discovery Response Event Parameters."]
    pub char_disc_rsp: __BindgenUnionField<ble_gattc_evt_char_disc_rsp_t>,
    #[doc = "< Descriptor Discovery Response Event Parameters."]
    pub desc_disc_rsp: __BindgenUnionField<ble_gattc_evt_desc_disc_rsp_t>,
    #[doc = "< Characteristic Value Read by UUID Response Event Parameters."]
    pub char_val_by_uuid_read_rsp: __BindgenUnionField<ble_gattc_evt_char_val_by_uuid_read_rsp_t>,
    #[doc = "< Read Response Event Parameters."]
    pub read_rsp: __BindgenUnionField<ble_gattc_evt_read_rsp_t>,
    #[doc = "< Characteristic Values Read Response Event Parameters."]
    pub char_vals_read_rsp: __BindgenUnionField<ble_gattc_evt_char_vals_read_rsp_t>,
    #[doc = "< Write Response Event Parameters."]
    pub write_rsp: __BindgenUnionField<ble_gattc_evt_write_rsp_t>,
    #[doc = "< Handle Value Notification/Indication Event Parameters."]
    pub hvx: __BindgenUnionField<ble_gattc_evt_hvx_t>,
    #[doc = "< Exchange MTU Response Event Parameters."]
    pub exchange_mtu_rsp: __BindgenUnionField<ble_gattc_evt_exchange_mtu_rsp_t>,
    #[doc = "< Timeout Event Parameters."]
    pub timeout: __BindgenUnionField<ble_gattc_evt_timeout_t>,
    #[doc = "< Attribute Information Discovery Event Parameters."]
    pub attr_info_disc_rsp: __BindgenUnionField<ble_gattc_evt_attr_info_disc_rsp_t>,
    #[doc = "< Write without Response transmission complete Event Parameters."]
    pub write_cmd_tx_complete: __BindgenUnionField<ble_gattc_evt_write_cmd_tx_complete_t>,
    pub bindgen_union_field: [u16; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_gattc_evt_t__bindgen_ty_1>() - 8usize];
    ["Alignment of ble_gattc_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_gattc_evt_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::prim_srvc_disc_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, prim_srvc_disc_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::rel_disc_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, rel_disc_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::char_disc_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, char_disc_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::desc_disc_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, desc_disc_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::char_val_by_uuid_read_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, char_val_by_uuid_read_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::read_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, read_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::char_vals_read_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, char_vals_read_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::write_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, write_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::hvx"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, hvx) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::exchange_mtu_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, exchange_mtu_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::timeout"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, timeout) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::attr_info_disc_rsp"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, attr_info_disc_rsp) - 0usize];
    ["Offset of field: ble_gattc_evt_t__bindgen_ty_1::write_cmd_tx_complete"]
        [::core::mem::offset_of!(ble_gattc_evt_t__bindgen_ty_1, write_cmd_tx_complete) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gattc_evt_t"][::core::mem::size_of::<ble_gattc_evt_t>() - 14usize];
    ["Alignment of ble_gattc_evt_t"][::core::mem::align_of::<ble_gattc_evt_t>() - 2usize];
    ["Offset of field: ble_gattc_evt_t::conn_handle"][::core::mem::offset_of!(ble_gattc_evt_t, conn_handle) - 0usize];
    ["Offset of field: ble_gattc_evt_t::gatt_status"][::core::mem::offset_of!(ble_gattc_evt_t, gatt_status) - 2usize];
    ["Offset of field: ble_gattc_evt_t::error_handle"][::core::mem::offset_of!(ble_gattc_evt_t, error_handle) - 4usize];
    ["Offset of field: ble_gattc_evt_t::params"][::core::mem::offset_of!(ble_gattc_evt_t, params) - 6usize];
};

#[doc = "@brief Initiate or continue a GATT Primary Service Discovery procedure.\n\n @details This function initiates or resumes a Primary Service discovery procedure, starting from the supplied handle.\n          If the last service has not been reached, this function must be called again with an updated start handle value to continue the search.\n\n @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with\n       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.\n\n @events\n @event{@ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_PRIM_SRVC_DISC_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] start_handle Handle to start searching from.\n @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_primary_services_discover(
    conn_handle: u16,
    start_handle: u16,
    p_srvc_uuid: *const ble_uuid_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 155",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(start_handle) => _,
        inout("r2") to_asm(p_srvc_uuid) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Relationship Discovery procedure.\n\n @details This function initiates or resumes the Find Included Services sub-procedure. If the last included service has not been reached,\n          this must be called again with an updated handle range to continue the search.\n\n @events\n @event{@ref BLE_GATTC_EVT_REL_DISC_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_REL_DISC_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_relationships_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 156",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Characteristic Discovery procedure.\n\n @details This function initiates or resumes a Characteristic discovery procedure. If the last Characteristic has not been reached,\n          this must be called again with an updated handle range to continue the discovery.\n\n @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with\n       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.\n\n @events\n @event{@ref BLE_GATTC_EVT_CHAR_DISC_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_CHAR_DISC_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_characteristics_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 157",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.\n\n @details This function initiates or resumes a Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,\n          this must be called again with an updated handle range to continue the discovery.\n\n @events\n @event{@ref BLE_GATTC_EVT_DESC_DISC_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_DESC_DISC_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_descriptors_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 158",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Read using Characteristic UUID procedure.\n\n @details This function initiates or resumes a Read using Characteristic UUID procedure. If the last Characteristic has not been reached,\n          this must be called again with an updated handle range to continue the discovery.\n\n @events\n @event{@ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_READ_UUID_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_uuid Pointer to a Characteristic value UUID to read.\n @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_char_value_by_uuid_read(
    conn_handle: u16,
    p_uuid: *const ble_uuid_t,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 160",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_handle_range) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.\n\n @details This function initiates or resumes a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor\n          to be read is longer than ATT_MTU - 1, this function must be called multiple times with appropriate offset to read the\n          complete value.\n\n @events\n @event{@ref BLE_GATTC_EVT_READ_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_VALUE_READ_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] handle The handle of the attribute to be read.\n @param[in] offset Offset into the attribute value to be read.\n\n @retval ::NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_read(conn_handle: u16, handle: u16, offset: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 161",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(offset) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate a GATT Read Multiple Characteristic Values procedure.\n\n @details This function initiates a GATT Read Multiple Characteristic Values procedure.\n\n @events\n @event{@ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_READ_MULT_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.\n @param[in] handle_count The number of handles in p_handles.\n\n @retval ::NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_char_values_read(conn_handle: u16, p_handles: *const u16, handle_count: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 162",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handles) => _,
        inout("r2") to_asm(handle_count) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.\n\n @details This function can perform all write procedures described in GATT.\n\n @note    Only one write with response procedure can be ongoing per connection at a time.\n          If the application tries to write with response while another write with response procedure is ongoing,\n          the function call will return @ref NRF_ERROR_BUSY.\n          A @ref BLE_GATTC_EVT_WRITE_RSP event will be issued as soon as the write response arrives from the peer.\n\n @note    The number of Write without Response that can be queued is configured by @ref ble_gattc_conn_cfg_t::write_cmd_tx_queue_size\n          When the queue is full, the function call will return @ref NRF_ERROR_RESOURCES.\n          A @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event will be issued as soon as the transmission of the write without response is complete.\n\n @note    The application can keep track of the available queue element count for writes without responses by following the procedure below:\n          - Store initial queue element count in a variable.\n          - Decrement the variable, which stores the currently available queue element count, by one when a call to this function returns @ref NRF_SUCCESS.\n          - Increment the variable, which stores the current available queue element count, by the count variable in @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event.\n\n @events\n @event{@ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE, Write without response transmission complete.}\n @event{@ref BLE_GATTC_EVT_WRITE_RSP, Write response received from the peer.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_VALUE_WRITE_WITHOUT_RESP_MSC}\n @mmsc{@ref BLE_GATTC_VALUE_WRITE_MSC}\n @mmsc{@ref BLE_GATTC_VALUE_LONG_WRITE_MSC}\n @mmsc{@ref BLE_GATTC_VALUE_RELIABLE_WRITE_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] p_write_params A pointer to a write parameters structure.\n\n @retval ::NRF_SUCCESS Successfully started the Write procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.\n @retval ::NRF_ERROR_BUSY For write with response, procedure already in progress. Wait for a @ref BLE_GATTC_EVT_WRITE_RSP event and retry.\n @retval ::NRF_ERROR_RESOURCES Too many writes without responses queued.\n                               Wait for a @ref BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event and retry.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_write(conn_handle: u16, p_write_params: *const ble_gattc_write_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 163",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_write_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Send a Handle Value Confirmation to the GATT Server.\n\n @mscs\n @mmsc{@ref BLE_GATTC_HVI_MSC}\n @endmscs\n\n @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.\n @param[in] handle The handle of the attribute in the indication.\n\n @retval ::NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no Indication pending to be confirmed.\n @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_hv_confirm(conn_handle: u16, handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 164",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Discovers information about a range of attributes on a GATT server.\n\n @events\n @event{@ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP, Generated when information about a range of attributes has been received.}\n @endevents\n\n @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.\n @param[in] p_handle_range The range of handles to request information about.\n\n @retval ::NRF_SUCCESS Successfully started an attribute information discovery procedure.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid connection state\n @retval ::NRF_ERROR_INVALID_ADDR  Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_attr_info_discover(
    conn_handle: u16,
    p_handle_range: *const ble_gattc_handle_range_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 159",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_handle_range) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start an ATT_MTU exchange by sending an Exchange MTU Request to the server.\n\n @details The SoftDevice sets ATT_MTU to the minimum of:\n          - The Client RX MTU value, and\n          - The Server RX MTU value from @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP.\n\n          However, the SoftDevice never sets ATT_MTU lower than @ref BLE_GATT_ATT_MTU_DEFAULT.\n\n @events\n @event{@ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}\n @endmscs\n\n @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.\n @param[in] client_rx_mtu  Client RX MTU size.\n                           - The minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT.\n                           - The maximum value is @ref ble_gatt_conn_cfg_t::att_mtu in the connection configuration\nused for this connection.\n                           - The value must be equal to Server RX MTU size given in @ref sd_ble_gatts_exchange_mtu_reply\n                             if an ATT_MTU exchange has already been performed in the other direction.\n\n @retval ::NRF_SUCCESS Successfully sent request to the server.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.\n @retval ::NRF_ERROR_BUSY Client procedure already in progress.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gattc_exchange_mtu_request(conn_handle: u16, client_rx_mtu: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 165",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(client_rx_mtu) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< ::sd_mbr_command"]
pub const NRF_MBR_SVCS_SD_MBR_COMMAND: NRF_MBR_SVCS = 24;
#[doc = "@brief nRF Master Boot Record API SVC numbers."]
pub type NRF_MBR_SVCS = self::c_uint;
#[doc = "< Copy a new BootLoader. @see ::sd_mbr_command_copy_bl_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COPY_BL: NRF_MBR_COMMANDS = 0;
#[doc = "< Copy a new SoftDevice. @see ::sd_mbr_command_copy_sd_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COPY_SD: NRF_MBR_COMMANDS = 1;
#[doc = "< Initialize forwarding interrupts to SD, and run reset function in SD. Does not require any parameters in ::sd_mbr_command_t params."]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_INIT_SD: NRF_MBR_COMMANDS = 2;
#[doc = "< This command works like memcmp. @see ::sd_mbr_command_compare_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_COMPARE: NRF_MBR_COMMANDS = 3;
#[doc = "< Change the address the MBR starts after a reset. @see ::sd_mbr_command_vector_table_base_set_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET: NRF_MBR_COMMANDS = 4;
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_RESERVED: NRF_MBR_COMMANDS = 5;
#[doc = "< Start forwarding all interrupts to this address. @see ::sd_mbr_command_irq_forward_address_set_t"]
pub const NRF_MBR_COMMANDS_SD_MBR_COMMAND_IRQ_FORWARD_ADDRESS_SET: NRF_MBR_COMMANDS = 6;
#[doc = "@brief Possible values for ::sd_mbr_command_t.command"]
pub type NRF_MBR_COMMANDS = self::c_uint;
#[doc = "@brief This command copies part of a new SoftDevice\n\n The destination area is erased before copying.\n If dst is in the middle of a flash page, that whole flash page will be erased.\n If (dst+len) is in the middle of a flash page, that whole flash page will be erased.\n\n The user of this function is responsible for setting the BPROT registers.\n\n @retval ::NRF_SUCCESS indicates that the contents of the memory blocks where copied correctly.\n @retval ::NRF_ERROR_INTERNAL indicates that the contents of the memory blocks where not verified correctly after copying."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_copy_sd_t {
    #[doc = "< Pointer to the source of data to be copied."]
    pub src: *mut u32,
    #[doc = "< Pointer to the destination where the content is to be copied."]
    pub dst: *mut u32,
    #[doc = "< Number of 32 bit words to copy. Must be a multiple of @ref MBR_PAGE_SIZE_IN_WORDS words."]
    pub len: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_copy_sd_t"][::core::mem::size_of::<sd_mbr_command_copy_sd_t>() - 12usize];
    ["Alignment of sd_mbr_command_copy_sd_t"][::core::mem::align_of::<sd_mbr_command_copy_sd_t>() - 4usize];
    ["Offset of field: sd_mbr_command_copy_sd_t::src"][::core::mem::offset_of!(sd_mbr_command_copy_sd_t, src) - 0usize];
    ["Offset of field: sd_mbr_command_copy_sd_t::dst"][::core::mem::offset_of!(sd_mbr_command_copy_sd_t, dst) - 4usize];
    ["Offset of field: sd_mbr_command_copy_sd_t::len"][::core::mem::offset_of!(sd_mbr_command_copy_sd_t, len) - 8usize];
};
#[doc = "@brief This command works like memcmp, but takes the length in words.\n\n @retval ::NRF_SUCCESS indicates that the contents of both memory blocks are equal.\n @retval ::NRF_ERROR_NULL indicates that the contents of the memory blocks are not equal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_compare_t {
    #[doc = "< Pointer to block of memory."]
    pub ptr1: *mut u32,
    #[doc = "< Pointer to block of memory."]
    pub ptr2: *mut u32,
    #[doc = "< Number of 32 bit words to compare."]
    pub len: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_compare_t"][::core::mem::size_of::<sd_mbr_command_compare_t>() - 12usize];
    ["Alignment of sd_mbr_command_compare_t"][::core::mem::align_of::<sd_mbr_command_compare_t>() - 4usize];
    ["Offset of field: sd_mbr_command_compare_t::ptr1"]
        [::core::mem::offset_of!(sd_mbr_command_compare_t, ptr1) - 0usize];
    ["Offset of field: sd_mbr_command_compare_t::ptr2"]
        [::core::mem::offset_of!(sd_mbr_command_compare_t, ptr2) - 4usize];
    ["Offset of field: sd_mbr_command_compare_t::len"][::core::mem::offset_of!(sd_mbr_command_compare_t, len) - 8usize];
};
#[doc = "@brief This command copies a new BootLoader.\n\n The MBR assumes that either @ref MBR_BOOTLOADER_ADDR or @ref MBR_UICR_BOOTLOADER_ADDR is set to\n the address where the bootloader will be copied. If both addresses are set, the MBR will prioritize\n @ref MBR_BOOTLOADER_ADDR.\n\n The bootloader destination is erased by this function.\n If (destination+bl_len) is in the middle of a flash page, that whole flash page will be erased.\n\n This command requires that @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR is set,\n see @ref sd_mbr_command.\n\n This command will use the flash protect peripheral (BPROT or ACL) to protect the flash that is\n not intended to be written.\n\n On success, this function will not return. It will start the new bootloader from reset-vector as normal.\n\n @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen.\n @retval ::NRF_ERROR_FORBIDDEN if the bootloader address is not set.\n @retval ::NRF_ERROR_INVALID_LENGTH if parameters attempts to read or write outside flash area.\n @retval ::NRF_ERROR_NO_MEM No MBR parameter page is provided. See @ref sd_mbr_command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_copy_bl_t {
    #[doc = "< Pointer to the source of the bootloader to be be copied."]
    pub bl_src: *mut u32,
    #[doc = "< Number of 32 bit words to copy for BootLoader."]
    pub bl_len: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_copy_bl_t"][::core::mem::size_of::<sd_mbr_command_copy_bl_t>() - 8usize];
    ["Alignment of sd_mbr_command_copy_bl_t"][::core::mem::align_of::<sd_mbr_command_copy_bl_t>() - 4usize];
    ["Offset of field: sd_mbr_command_copy_bl_t::bl_src"]
        [::core::mem::offset_of!(sd_mbr_command_copy_bl_t, bl_src) - 0usize];
    ["Offset of field: sd_mbr_command_copy_bl_t::bl_len"]
        [::core::mem::offset_of!(sd_mbr_command_copy_bl_t, bl_len) - 4usize];
};
#[doc = "@brief Change the address the MBR starts after a reset\n\n Once this function has been called, this address is where the MBR will start to forward\n interrupts to after a reset.\n\n To restore default forwarding, this function should be called with @ref address set to 0. If a\n bootloader is present, interrupts will be forwarded to the bootloader. If not, interrupts will\n be forwarded to the SoftDevice.\n\n The location of a bootloader can be specified in @ref MBR_BOOTLOADER_ADDR or\n @ref MBR_UICR_BOOTLOADER_ADDR. If both addresses are set, the MBR will prioritize\n @ref MBR_BOOTLOADER_ADDR.\n\n This command requires that @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR is set,\n see @ref sd_mbr_command.\n\n On success, this function will not return. It will reset the device.\n\n @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen.\n @retval ::NRF_ERROR_INVALID_ADDR if parameter address is outside of the flash size.\n @retval ::NRF_ERROR_NO_MEM No MBR parameter page is provided. See @ref sd_mbr_command."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_vector_table_base_set_t {
    #[doc = "< The base address of the interrupt vector table for forwarded interrupts."]
    pub address: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_vector_table_base_set_t"]
        [::core::mem::size_of::<sd_mbr_command_vector_table_base_set_t>() - 4usize];
    ["Alignment of sd_mbr_command_vector_table_base_set_t"]
        [::core::mem::align_of::<sd_mbr_command_vector_table_base_set_t>() - 4usize];
    ["Offset of field: sd_mbr_command_vector_table_base_set_t::address"]
        [::core::mem::offset_of!(sd_mbr_command_vector_table_base_set_t, address) - 0usize];
};
#[doc = "@brief Sets the base address of the interrupt vector table for interrupts forwarded from the MBR\n\n Unlike sd_mbr_command_vector_table_base_set_t, this function does not reset, and it does not\n change where the MBR starts after reset.\n\n @retval ::NRF_SUCCESS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sd_mbr_command_irq_forward_address_set_t {
    #[doc = "< The base address of the interrupt vector table for forwarded interrupts."]
    pub address: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_irq_forward_address_set_t"]
        [::core::mem::size_of::<sd_mbr_command_irq_forward_address_set_t>() - 4usize];
    ["Alignment of sd_mbr_command_irq_forward_address_set_t"]
        [::core::mem::align_of::<sd_mbr_command_irq_forward_address_set_t>() - 4usize];
    ["Offset of field: sd_mbr_command_irq_forward_address_set_t::address"]
        [::core::mem::offset_of!(sd_mbr_command_irq_forward_address_set_t, address) - 0usize];
};
#[doc = "@brief Input structure containing data used when calling ::sd_mbr_command\n\n Depending on what command value that is set, the corresponding params value type must also be\n set. See @ref NRF_MBR_COMMANDS for command types and corresponding params value type. If command\n @ref SD_MBR_COMMAND_INIT_SD is set, it is not necessary to set any values under params."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_mbr_command_t {
    #[doc = "< Type of command to be issued. See @ref NRF_MBR_COMMANDS."]
    pub command: u32,
    #[doc = "< Command parameters."]
    pub params: sd_mbr_command_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sd_mbr_command_t__bindgen_ty_1 {
    #[doc = "< Parameters for copy SoftDevice."]
    pub copy_sd: sd_mbr_command_copy_sd_t,
    #[doc = "< Parameters for verify."]
    pub compare: sd_mbr_command_compare_t,
    #[doc = "< Parameters for copy BootLoader. Requires parameter page."]
    pub copy_bl: sd_mbr_command_copy_bl_t,
    #[doc = "< Parameters for vector table base set. Requires parameter page."]
    pub base_set: sd_mbr_command_vector_table_base_set_t,
    #[doc = "< Parameters for irq forward address set"]
    pub irq_forward_address_set: sd_mbr_command_irq_forward_address_set_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_t__bindgen_ty_1"][::core::mem::size_of::<sd_mbr_command_t__bindgen_ty_1>() - 12usize];
    ["Alignment of sd_mbr_command_t__bindgen_ty_1"][::core::mem::align_of::<sd_mbr_command_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: sd_mbr_command_t__bindgen_ty_1::copy_sd"]
        [::core::mem::offset_of!(sd_mbr_command_t__bindgen_ty_1, copy_sd) - 0usize];
    ["Offset of field: sd_mbr_command_t__bindgen_ty_1::compare"]
        [::core::mem::offset_of!(sd_mbr_command_t__bindgen_ty_1, compare) - 0usize];
    ["Offset of field: sd_mbr_command_t__bindgen_ty_1::copy_bl"]
        [::core::mem::offset_of!(sd_mbr_command_t__bindgen_ty_1, copy_bl) - 0usize];
    ["Offset of field: sd_mbr_command_t__bindgen_ty_1::base_set"]
        [::core::mem::offset_of!(sd_mbr_command_t__bindgen_ty_1, base_set) - 0usize];
    ["Offset of field: sd_mbr_command_t__bindgen_ty_1::irq_forward_address_set"]
        [::core::mem::offset_of!(sd_mbr_command_t__bindgen_ty_1, irq_forward_address_set) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sd_mbr_command_t"][::core::mem::size_of::<sd_mbr_command_t>() - 16usize];
    ["Alignment of sd_mbr_command_t"][::core::mem::align_of::<sd_mbr_command_t>() - 4usize];
    ["Offset of field: sd_mbr_command_t::command"][::core::mem::offset_of!(sd_mbr_command_t, command) - 0usize];
    ["Offset of field: sd_mbr_command_t::params"][::core::mem::offset_of!(sd_mbr_command_t, params) - 4usize];
};

#[doc = "@brief Issue Master Boot Record commands\n\n Commands used when updating a SoftDevice and bootloader.\n\n The @ref SD_MBR_COMMAND_COPY_BL and @ref SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET requires\n parameters to be retained by the MBR when resetting the IC. This is done in a separate flash\n page. The location of the flash page should be provided by the application in either\n @ref MBR_PARAM_PAGE_ADDR or @ref MBR_UICR_PARAM_PAGE_ADDR. If both addresses are set, the MBR\n will prioritize @ref MBR_PARAM_PAGE_ADDR. This page will be cleared by the MBR and is used to\n store the command before reset. When an address is specified, the page it refers to must not be\n used by the application. If no address is provided by the application, i.e. both\n @ref MBR_PARAM_PAGE_ADDR and @ref MBR_UICR_PARAM_PAGE_ADDR is 0xFFFFFFFF, MBR commands which use\n flash will be unavailable and return @ref NRF_ERROR_NO_MEM.\n\n @param[in]  param Pointer to a struct describing the command.\n\n @note For a complete set of return values, see ::sd_mbr_command_copy_sd_t,\n       ::sd_mbr_command_copy_bl_t, ::sd_mbr_command_compare_t,\n       ::sd_mbr_command_vector_table_base_set_t, ::sd_mbr_command_irq_forward_address_set_t\n\n @retval ::NRF_ERROR_NO_MEM No MBR parameter page provided\n @retval ::NRF_ERROR_INVALID_PARAM if an invalid command is given."]
#[inline(always)]
pub unsafe fn sd_mbr_command(param: *mut sd_mbr_command_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 24",
        inout("r0") to_asm(param) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Set own Bluetooth Address."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADDR_SET: BLE_GAP_SVCS = 108;
#[doc = "< Get own Bluetooth Address."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADDR_GET: BLE_GAP_SVCS = 109;
#[doc = "< Set active whitelist."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_WHITELIST_SET: BLE_GAP_SVCS = 110;
#[doc = "< Set device identity list."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_IDENTITIES_SET: BLE_GAP_SVCS = 111;
#[doc = "< Set Privacy settings"]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PRIVACY_SET: BLE_GAP_SVCS = 112;
#[doc = "< Get Privacy settings"]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PRIVACY_GET: BLE_GAP_SVCS = 113;
#[doc = "< Configure an advertising set."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_SET_CONFIGURE: BLE_GAP_SVCS = 114;
#[doc = "< Start Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_START: BLE_GAP_SVCS = 115;
#[doc = "< Stop Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_STOP: BLE_GAP_SVCS = 116;
#[doc = "< Connection Parameter Update."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_PARAM_UPDATE: BLE_GAP_SVCS = 117;
#[doc = "< Disconnect."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DISCONNECT: BLE_GAP_SVCS = 118;
#[doc = "< Set TX Power."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_TX_POWER_SET: BLE_GAP_SVCS = 119;
#[doc = "< Set Appearance."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_APPEARANCE_SET: BLE_GAP_SVCS = 120;
#[doc = "< Get Appearance."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_APPEARANCE_GET: BLE_GAP_SVCS = 121;
#[doc = "< Set PPCP."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PPCP_SET: BLE_GAP_SVCS = 122;
#[doc = "< Get PPCP."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PPCP_GET: BLE_GAP_SVCS = 123;
#[doc = "< Set Device Name."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_NAME_SET: BLE_GAP_SVCS = 124;
#[doc = "< Get Device Name."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DEVICE_NAME_GET: BLE_GAP_SVCS = 125;
#[doc = "< Initiate Pairing/Bonding."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_AUTHENTICATE: BLE_GAP_SVCS = 126;
#[doc = "< Reply with Security Parameters."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SEC_PARAMS_REPLY: BLE_GAP_SVCS = 127;
#[doc = "< Reply with an authentication key."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_AUTH_KEY_REPLY: BLE_GAP_SVCS = 128;
#[doc = "< Reply with an LE Secure Connections DHKey."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_DHKEY_REPLY: BLE_GAP_SVCS = 129;
#[doc = "< Notify of a keypress during an authentication procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_KEYPRESS_NOTIFY: BLE_GAP_SVCS = 130;
#[doc = "< Get the local LE Secure Connections OOB data."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_OOB_DATA_GET: BLE_GAP_SVCS = 131;
#[doc = "< Set the remote LE Secure Connections OOB data."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_LESC_OOB_DATA_SET: BLE_GAP_SVCS = 132;
#[doc = "< Initiate encryption procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ENCRYPT: BLE_GAP_SVCS = 133;
#[doc = "< Reply with Security Information."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SEC_INFO_REPLY: BLE_GAP_SVCS = 134;
#[doc = "< Obtain connection security level."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_SEC_GET: BLE_GAP_SVCS = 135;
#[doc = "< Start reporting of changes in RSSI."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_START: BLE_GAP_SVCS = 136;
#[doc = "< Stop reporting of changes in RSSI."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_STOP: BLE_GAP_SVCS = 137;
#[doc = "< Start Scanning."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SCAN_START: BLE_GAP_SVCS = 138;
#[doc = "< Stop Scanning."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_SCAN_STOP: BLE_GAP_SVCS = 139;
#[doc = "< Connect."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONNECT: BLE_GAP_SVCS = 140;
#[doc = "< Cancel ongoing connection procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONNECT_CANCEL: BLE_GAP_SVCS = 141;
#[doc = "< Get the last RSSI sample."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_RSSI_GET: BLE_GAP_SVCS = 142;
#[doc = "< Initiate or respond to a PHY Update Procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_PHY_UPDATE: BLE_GAP_SVCS = 143;
#[doc = "< Initiate or respond to a Data Length Update Procedure."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_DATA_LENGTH_UPDATE: BLE_GAP_SVCS = 144;
#[doc = "< Start Quality of Service (QoS) channel survey module."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_QOS_CHANNEL_SURVEY_START: BLE_GAP_SVCS = 145;
#[doc = "< Stop Quality of Service (QoS) channel survey module."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_QOS_CHANNEL_SURVEY_STOP: BLE_GAP_SVCS = 146;
#[doc = "< Get the Address used on air while Advertising."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_ADV_ADDR_GET: BLE_GAP_SVCS = 147;
#[doc = "< Get the next connection event counter."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_NEXT_CONN_EVT_COUNTER_GET: BLE_GAP_SVCS = 148;
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_EVT_TRIGGER_START: BLE_GAP_SVCS = 149;
#[doc = " Start triggering a given task on connection event start."]
pub const BLE_GAP_SVCS_SD_BLE_GAP_CONN_EVT_TRIGGER_STOP: BLE_GAP_SVCS = 150;
#[doc = "@brief GAP API SVC numbers."]
pub type BLE_GAP_SVCS = self::c_uint;
#[doc = "< Connected to peer.                              \\n See @ref ble_gap_evt_connected_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONNECTED: BLE_GAP_EVTS = 16;
#[doc = "< Disconnected from peer.                         \\n See @ref ble_gap_evt_disconnected_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DISCONNECTED: BLE_GAP_EVTS = 17;
#[doc = "< Connection Parameters updated.                  \\n See @ref ble_gap_evt_conn_param_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_PARAM_UPDATE: BLE_GAP_EVTS = 18;
#[doc = "< Request to provide security parameters.         \\n Reply with @ref sd_ble_gap_sec_params_reply.  \\n See @ref ble_gap_evt_sec_params_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_PARAMS_REQUEST: BLE_GAP_EVTS = 19;
#[doc = "< Request to provide security information.        \\n Reply with @ref sd_ble_gap_sec_info_reply.    \\n See @ref ble_gap_evt_sec_info_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_INFO_REQUEST: BLE_GAP_EVTS = 20;
#[doc = "< Request to display a passkey to the user.       \\n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \\n See @ref ble_gap_evt_passkey_display_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PASSKEY_DISPLAY: BLE_GAP_EVTS = 21;
#[doc = "< Notification of a keypress on the remote device.\\n See @ref ble_gap_evt_key_pressed_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_KEY_PRESSED: BLE_GAP_EVTS = 22;
#[doc = "< Request to provide an authentication key.       \\n Reply with @ref sd_ble_gap_auth_key_reply.    \\n See @ref ble_gap_evt_auth_key_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_AUTH_KEY_REQUEST: BLE_GAP_EVTS = 23;
#[doc = "< Request to calculate an LE Secure Connections DHKey. \\n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \\n See @ref ble_gap_evt_lesc_dhkey_request_t"]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_LESC_DHKEY_REQUEST: BLE_GAP_EVTS = 24;
#[doc = "< Authentication procedure completed with status. \\n See @ref ble_gap_evt_auth_status_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_AUTH_STATUS: BLE_GAP_EVTS = 25;
#[doc = "< Connection security updated.                    \\n See @ref ble_gap_evt_conn_sec_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_SEC_UPDATE: BLE_GAP_EVTS = 26;
#[doc = "< Timeout expired.                                \\n See @ref ble_gap_evt_timeout_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_TIMEOUT: BLE_GAP_EVTS = 27;
#[doc = "< RSSI report.                                    \\n See @ref ble_gap_evt_rssi_changed_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_RSSI_CHANGED: BLE_GAP_EVTS = 28;
#[doc = "< Advertising report.                             \\n See @ref ble_gap_evt_adv_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_ADV_REPORT: BLE_GAP_EVTS = 29;
#[doc = "< Security Request.                               \\n See @ref ble_gap_evt_sec_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SEC_REQUEST: BLE_GAP_EVTS = 30;
#[doc = "< Connection Parameter Update Request.            \\n Reply with @ref sd_ble_gap_conn_param_update. \\n See @ref ble_gap_evt_conn_param_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST: BLE_GAP_EVTS = 31;
#[doc = "< Scan request report.                            \\n See @ref ble_gap_evt_scan_req_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_SCAN_REQ_REPORT: BLE_GAP_EVTS = 32;
#[doc = "< PHY Update Request.                             \\n Reply with @ref sd_ble_gap_phy_update. \\n See @ref ble_gap_evt_phy_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PHY_UPDATE_REQUEST: BLE_GAP_EVTS = 33;
#[doc = "< PHY Update Procedure is complete.               \\n See @ref ble_gap_evt_phy_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_PHY_UPDATE: BLE_GAP_EVTS = 34;
#[doc = "< Data Length Update Request.                     \\n Reply with @ref sd_ble_gap_data_length_update. \\n See @ref ble_gap_evt_data_length_update_request_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST: BLE_GAP_EVTS = 35;
#[doc = "< LL Data Channel PDU payload length updated.     \\n See @ref ble_gap_evt_data_length_update_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_DATA_LENGTH_UPDATE: BLE_GAP_EVTS = 36;
#[doc = "< Channel survey report.                          \\n See @ref ble_gap_evt_qos_channel_survey_report_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT: BLE_GAP_EVTS = 37;
#[doc = "< Advertising set terminated.                     \\n See @ref ble_gap_evt_adv_set_terminated_t."]
pub const BLE_GAP_EVTS_BLE_GAP_EVT_ADV_SET_TERMINATED: BLE_GAP_EVTS = 38;
#[doc = "@brief GAP Event IDs.\n IDs that uniquely identify an event coming from the stack to the application."]
pub type BLE_GAP_EVTS = self::c_uint;
#[doc = "< Channel Map. @ref ble_gap_opt_ch_map_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_CH_MAP: BLE_GAP_OPTS = 32;
#[doc = "< Local connection latency. @ref ble_gap_opt_local_conn_latency_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_LOCAL_CONN_LATENCY: BLE_GAP_OPTS = 33;
#[doc = "< Set passkey. @ref ble_gap_opt_passkey_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_PASSKEY: BLE_GAP_OPTS = 34;
#[doc = "< Compatibility mode. @ref ble_gap_opt_compat_mode_1_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_COMPAT_MODE_1: BLE_GAP_OPTS = 35;
#[doc = "< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT: BLE_GAP_OPTS = 36;
#[doc = "< Disable slave latency. @ref ble_gap_opt_slave_latency_disable_t"]
pub const BLE_GAP_OPTS_BLE_GAP_OPT_SLAVE_LATENCY_DISABLE: BLE_GAP_OPTS = 37;
#[doc = "@brief GAP Option IDs.\n IDs that uniquely identify a GAP option."]
pub type BLE_GAP_OPTS = self::c_uint;
#[doc = "< Role count configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_ROLE_COUNT: BLE_GAP_CFGS = 64;
#[doc = "< Device name configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_DEVICE_NAME: BLE_GAP_CFGS = 65;
#[doc = "< Peripheral Preferred Connection Parameters characteristic\ninclusion configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_PPCP_INCL_CONFIG: BLE_GAP_CFGS = 66;
#[doc = "< Central Address Resolution characteristic\ninclusion configuration."]
pub const BLE_GAP_CFGS_BLE_GAP_CFG_CAR_INCL_CONFIG: BLE_GAP_CFGS = 67;
#[doc = "@brief GAP Configuration IDs.\n\n IDs that uniquely identify a GAP configuration."]
pub type BLE_GAP_CFGS = self::c_uint;
#[doc = "< Advertiser role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_ADV: BLE_GAP_TX_POWER_ROLES = 1;
#[doc = "< Scanner and initiator role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_SCAN_INIT: BLE_GAP_TX_POWER_ROLES = 2;
#[doc = "< Connection role."]
pub const BLE_GAP_TX_POWER_ROLES_BLE_GAP_TX_POWER_ROLE_CONN: BLE_GAP_TX_POWER_ROLES = 3;
#[doc = "@brief GAP TX Power roles."]
pub type BLE_GAP_TX_POWER_ROLES = self::c_uint;
#[doc = "@brief Advertising event properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_properties_t {
    #[doc = "< Advertising type. See @ref BLE_GAP_ADV_TYPES."]
    pub type_: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_adv_properties_t"][::core::mem::size_of::<ble_gap_adv_properties_t>() - 2usize];
    ["Alignment of ble_gap_adv_properties_t"][::core::mem::align_of::<ble_gap_adv_properties_t>() - 1usize];
    ["Offset of field: ble_gap_adv_properties_t::type_"]
        [::core::mem::offset_of!(ble_gap_adv_properties_t, type_) - 0usize];
};
impl ble_gap_adv_properties_t {
    #[inline]
    pub fn anonymous(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_anonymous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn anonymous_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_anonymous_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn include_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_include_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn include_tx_power_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_include_tx_power_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(anonymous: u8, include_tx_power: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let anonymous: u8 = unsafe { ::core::mem::transmute(anonymous) };
            anonymous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let include_tx_power: u8 = unsafe { ::core::mem::transmute(include_tx_power) };
            include_tx_power as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Advertising report type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_report_type_t {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_adv_report_type_t"][::core::mem::size_of::<ble_gap_adv_report_type_t>() - 2usize];
    ["Alignment of ble_gap_adv_report_type_t"][::core::mem::align_of::<ble_gap_adv_report_type_t>() - 2usize];
};
impl ble_gap_adv_report_type_t {
    #[inline]
    pub fn connectable(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_connectable(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn connectable_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_connectable_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scannable(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scannable(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scannable_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scannable_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn directed(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_directed(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn directed_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_directed_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_response(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scan_response(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_response_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scan_response_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn extended_pdu(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_extended_pdu(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_pdu_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_extended_pdu_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn status(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn status_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connectable: u16,
        scannable: u16,
        directed: u16,
        scan_response: u16,
        extended_pdu: u16,
        status: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connectable: u16 = unsafe { ::core::mem::transmute(connectable) };
            connectable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scannable: u16 = unsafe { ::core::mem::transmute(scannable) };
            scannable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let directed: u16 = unsafe { ::core::mem::transmute(directed) };
            directed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_response: u16 = unsafe { ::core::mem::transmute(scan_response) };
            scan_response as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let extended_pdu: u16 = unsafe { ::core::mem::transmute(extended_pdu) };
            extended_pdu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let status: u16 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Advertising Auxiliary Pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_aux_pointer_t {
    #[doc = "< Time offset from the beginning of advertising packet to the auxiliary packet in 100 us units."]
    pub aux_offset: u16,
    #[doc = "< Indicates the PHY on which the auxiliary advertising packet is sent. See @ref BLE_GAP_PHYS."]
    pub aux_phy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_aux_pointer_t"][::core::mem::size_of::<ble_gap_aux_pointer_t>() - 4usize];
    ["Alignment of ble_gap_aux_pointer_t"][::core::mem::align_of::<ble_gap_aux_pointer_t>() - 2usize];
    ["Offset of field: ble_gap_aux_pointer_t::aux_offset"]
        [::core::mem::offset_of!(ble_gap_aux_pointer_t, aux_offset) - 0usize];
    ["Offset of field: ble_gap_aux_pointer_t::aux_phy"]
        [::core::mem::offset_of!(ble_gap_aux_pointer_t, aux_phy) - 2usize];
};
#[doc = "@brief Bluetooth Low Energy address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_addr_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< 48-bit address, LSB format.\n@ref addr is not used if @ref addr_type is @ref BLE_GAP_ADDR_TYPE_ANONYMOUS."]
    pub addr: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_addr_t"][::core::mem::size_of::<ble_gap_addr_t>() - 7usize];
    ["Alignment of ble_gap_addr_t"][::core::mem::align_of::<ble_gap_addr_t>() - 1usize];
    ["Offset of field: ble_gap_addr_t::addr"][::core::mem::offset_of!(ble_gap_addr_t, addr) - 1usize];
};
impl ble_gap_addr_t {
    #[inline]
    pub fn addr_id_peer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_addr_id_peer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addr_id_peer_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_addr_id_peer_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addr_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_addr_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addr_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_addr_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(addr_id_peer: u8, addr_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let addr_id_peer: u8 = unsafe { ::core::mem::transmute(addr_id_peer) };
            addr_id_peer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let addr_type: u8 = unsafe { ::core::mem::transmute(addr_type) };
            addr_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP connection parameters.\n\n @note  When ble_conn_params_t is received in an event, both min_conn_interval and\n        max_conn_interval will be equal to the connection interval set by the central.\n\n @note  If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:\n        conn_sup_timeout * 4 > (1 + slave_latency) * max_conn_interval\n        that corresponds to the following Bluetooth Spec requirement:\n        The Supervision_Timeout in milliseconds shall be larger than\n        (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_params_t {
    #[doc = "< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub min_conn_interval: u16,
    #[doc = "< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub max_conn_interval: u16,
    #[doc = "< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS."]
    pub slave_latency: u16,
    #[doc = "< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS."]
    pub conn_sup_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_conn_params_t"][::core::mem::size_of::<ble_gap_conn_params_t>() - 8usize];
    ["Alignment of ble_gap_conn_params_t"][::core::mem::align_of::<ble_gap_conn_params_t>() - 2usize];
    ["Offset of field: ble_gap_conn_params_t::min_conn_interval"]
        [::core::mem::offset_of!(ble_gap_conn_params_t, min_conn_interval) - 0usize];
    ["Offset of field: ble_gap_conn_params_t::max_conn_interval"]
        [::core::mem::offset_of!(ble_gap_conn_params_t, max_conn_interval) - 2usize];
    ["Offset of field: ble_gap_conn_params_t::slave_latency"]
        [::core::mem::offset_of!(ble_gap_conn_params_t, slave_latency) - 4usize];
    ["Offset of field: ble_gap_conn_params_t::conn_sup_timeout"]
        [::core::mem::offset_of!(ble_gap_conn_params_t, conn_sup_timeout) - 6usize];
};
#[doc = "@brief GAP connection security modes.\n\n Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\\n\n Security Mode 1 Level 1: No security is needed (aka open link).\\n\n Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\\n\n Security Mode 1 Level 3: MITM protected encrypted link required.\\n\n Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.\\n\n Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\\n\n Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_sec_mode_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_conn_sec_mode_t"][::core::mem::size_of::<ble_gap_conn_sec_mode_t>() - 1usize];
    ["Alignment of ble_gap_conn_sec_mode_t"][::core::mem::align_of::<ble_gap_conn_sec_mode_t>() - 1usize];
};
impl ble_gap_conn_sec_mode_t {
    #[inline]
    pub fn sm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sm_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sm_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_lv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lv_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lv_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(sm: u8, lv: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sm: u8 = unsafe { ::core::mem::transmute(sm) };
            sm as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let lv: u8 = unsafe { ::core::mem::transmute(lv) };
            lv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP connection security status."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_sec_t {
    #[doc = "< Currently active security mode for this connection."]
    pub sec_mode: ble_gap_conn_sec_mode_t,
    #[doc = "< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures)."]
    pub encr_key_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_conn_sec_t"][::core::mem::size_of::<ble_gap_conn_sec_t>() - 2usize];
    ["Alignment of ble_gap_conn_sec_t"][::core::mem::align_of::<ble_gap_conn_sec_t>() - 1usize];
    ["Offset of field: ble_gap_conn_sec_t::sec_mode"][::core::mem::offset_of!(ble_gap_conn_sec_t, sec_mode) - 0usize];
    ["Offset of field: ble_gap_conn_sec_t::encr_key_size"]
        [::core::mem::offset_of!(ble_gap_conn_sec_t, encr_key_size) - 1usize];
};
#[doc = "@brief Identity Resolving Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_irk_t {
    #[doc = "< Array containing IRK."]
    pub irk: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_irk_t"][::core::mem::size_of::<ble_gap_irk_t>() - 16usize];
    ["Alignment of ble_gap_irk_t"][::core::mem::align_of::<ble_gap_irk_t>() - 1usize];
    ["Offset of field: ble_gap_irk_t::irk"][::core::mem::offset_of!(ble_gap_irk_t, irk) - 0usize];
};
#[doc = "@brief Channel mask (40 bits).\n Every channel is represented with a bit positioned as per channel index defined in Bluetooth Core Specification v5.0,\n Vol 6, Part B, Section 1.4.1. The LSB contained in array element 0 represents channel index 0, and bit 39 represents\n channel index 39. If a bit is set to 1, the channel is not used."]
pub type ble_gap_ch_mask_t = [u8; 5usize];
#[doc = "@brief GAP advertising parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_params_t {
    #[doc = "< The properties of the advertising events."]
    pub properties: ble_gap_adv_properties_t,
    #[doc = "< Address of a known peer.\n@note ble_gap_addr_t::addr_type cannot be\n@ref BLE_GAP_ADDR_TYPE_ANONYMOUS.\n- When privacy is enabled and the local device uses\n@ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses,\nthe device identity list is searched for a matching entry. If\nthe local IRK for that device identity is set, the local IRK\nfor that device will be used to generate the advertiser address\nfield in the advertising packet.\n- If @ref ble_gap_adv_properties_t::type is directed, this must be\nset to the targeted scanner or initiator. If the peer address is\nin the device identity list, the peer IRK for that device will be\nused to generate @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE\ntarget addresses used in the advertising event PDUs."]
    pub p_peer_addr: *const ble_gap_addr_t,
    #[doc = "< Advertising interval in 625 us units. @sa BLE_GAP_ADV_INTERVALS.\n@note If @ref ble_gap_adv_properties_t::type is set to\n@ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE\nadvertising, this parameter is ignored."]
    pub interval: u32,
    #[doc = "< Advertising duration in 10 ms units. When timeout is reached,\nan event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised.\n@sa BLE_GAP_ADV_TIMEOUT_VALUES.\n@note The SoftDevice will always complete at least one advertising\nevent even if the duration is set too low."]
    pub duration: u16,
    #[doc = "< Maximum advertising events that shall be sent prior to disabling\nadvertising. Setting the value to 0 disables the limitation. When\nthe count of advertising events specified by this parameter\n(if not 0) is reached, advertising will be automatically stopped\nand an event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised\n@note If @ref ble_gap_adv_properties_t::type is set to\n@ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE,\nthis parameter is ignored."]
    pub max_adv_evts: u8,
    #[doc = "< Channel mask for primary and secondary advertising channels.\nAt least one of the primary channels, that is channel index 37-39, must be used.\nMasking away secondary advertising channels is not supported."]
    pub channel_mask: ble_gap_ch_mask_t,
    #[doc = "< Filter Policy. @sa BLE_GAP_ADV_FILTER_POLICIES."]
    pub filter_policy: u8,
    #[doc = "< Indicates the PHY on which the primary advertising channel packets\nare transmitted. If set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS\nwill be used.\nValid values are @ref BLE_GAP_PHY_1MBPS and @ref BLE_GAP_PHY_CODED.\n@note The primary_phy shall indicate @ref BLE_GAP_PHY_1MBPS if\n@ref ble_gap_adv_properties_t::type is not an extended advertising type."]
    pub primary_phy: u8,
    #[doc = "< Indicates the PHY on which the secondary advertising channel packets\nare transmitted.\nIf set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS will be used.\nValid values are\n@ref BLE_GAP_PHY_1MBPS, @ref BLE_GAP_PHY_2MBPS, and @ref BLE_GAP_PHY_CODED.\nIf @ref ble_gap_adv_properties_t::type is an extended advertising type\nand connectable, this is the PHY that will be used to establish a\nconnection and send AUX_ADV_IND packets on.\n@note This parameter will be ignored when\n@ref ble_gap_adv_properties_t::type is not an extended advertising type."]
    pub secondary_phy: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_adv_params_t"][::core::mem::size_of::<ble_gap_adv_params_t>() - 24usize];
    ["Alignment of ble_gap_adv_params_t"][::core::mem::align_of::<ble_gap_adv_params_t>() - 4usize];
    ["Offset of field: ble_gap_adv_params_t::properties"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, properties) - 0usize];
    ["Offset of field: ble_gap_adv_params_t::p_peer_addr"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, p_peer_addr) - 4usize];
    ["Offset of field: ble_gap_adv_params_t::interval"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, interval) - 8usize];
    ["Offset of field: ble_gap_adv_params_t::duration"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, duration) - 12usize];
    ["Offset of field: ble_gap_adv_params_t::max_adv_evts"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, max_adv_evts) - 14usize];
    ["Offset of field: ble_gap_adv_params_t::channel_mask"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, channel_mask) - 15usize];
    ["Offset of field: ble_gap_adv_params_t::filter_policy"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, filter_policy) - 20usize];
    ["Offset of field: ble_gap_adv_params_t::primary_phy"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, primary_phy) - 21usize];
    ["Offset of field: ble_gap_adv_params_t::secondary_phy"]
        [::core::mem::offset_of!(ble_gap_adv_params_t, secondary_phy) - 22usize];
};
impl ble_gap_adv_params_t {
    #[inline]
    pub fn set_id(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_set_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_set_id_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_req_notification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scan_req_notification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_req_notification_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_scan_req_notification_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(set_id: u8, scan_req_notification: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let set_id: u8 = unsafe { ::core::mem::transmute(set_id) };
            set_id as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_req_notification: u8 = unsafe { ::core::mem::transmute(scan_req_notification) };
            scan_req_notification as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP advertising data buffers.\n\n The application must provide the buffers for advertisement. The memory shall reside in application RAM, and\n shall never be modified while advertising. The data shall be kept alive until either:\n  - @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised.\n  - @ref BLE_GAP_EVT_CONNECTED is raised with @ref ble_gap_evt_connected_t::adv_handle set to the corresponding\n    advertising handle.\n  - Advertising is stopped.\n  - Advertising data is changed.\n To update advertising data while advertising, provide new buffers to @ref sd_ble_gap_adv_set_configure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_data_t {
    #[doc = "< Advertising data.\n@note\nAdvertising data can only be specified for a @ref ble_gap_adv_properties_t::type\nthat is allowed to contain advertising data."]
    pub adv_data: ble_data_t,
    #[doc = "< Scan response data.\n@note\nScan response data can only be specified for a @ref ble_gap_adv_properties_t::type\nthat is scannable."]
    pub scan_rsp_data: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_adv_data_t"][::core::mem::size_of::<ble_gap_adv_data_t>() - 16usize];
    ["Alignment of ble_gap_adv_data_t"][::core::mem::align_of::<ble_gap_adv_data_t>() - 4usize];
    ["Offset of field: ble_gap_adv_data_t::adv_data"][::core::mem::offset_of!(ble_gap_adv_data_t, adv_data) - 0usize];
    ["Offset of field: ble_gap_adv_data_t::scan_rsp_data"]
        [::core::mem::offset_of!(ble_gap_adv_data_t, scan_rsp_data) - 8usize];
};
#[doc = "@brief GAP scanning parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_scan_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Bitfield of PHYs to scan on. If set to @ref BLE_GAP_PHY_AUTO,\nscan_phys will default to @ref BLE_GAP_PHY_1MBPS.\n- If @ref ble_gap_scan_params_t::extended is set to 0, the only\nsupported PHY is @ref BLE_GAP_PHY_1MBPS.\n- When used with @ref sd_ble_gap_scan_start,\nthe bitfield indicates the PHYs the scanner will use for scanning\non primary advertising channels. The scanner will accept\n@ref BLE_GAP_PHYS_SUPPORTED as secondary advertising channel PHYs.\n- When used with @ref sd_ble_gap_connect, the bitfield indicates\nthe PHYs the initiator will use for scanning on primary advertising\nchannels. The initiator will accept connections initiated on either\nof the @ref BLE_GAP_PHYS_SUPPORTED PHYs.\nIf scan_phys contains @ref BLE_GAP_PHY_1MBPS and/or @ref BLE_GAP_PHY_2MBPS,\nthe primary scan PHY is @ref BLE_GAP_PHY_1MBPS.\nIf scan_phys also contains @ref BLE_GAP_PHY_CODED, the primary scan\nPHY will also contain @ref BLE_GAP_PHY_CODED. If the only scan PHY is\n@ref BLE_GAP_PHY_CODED, the primary scan PHY is\n@ref BLE_GAP_PHY_CODED only."]
    pub scan_phys: u8,
    #[doc = "< Scan interval in 625 us units. @sa BLE_GAP_SCAN_INTERVALS."]
    pub interval: u16,
    #[doc = "< Scan window in 625 us units. @sa BLE_GAP_SCAN_WINDOW.\nIf scan_phys contains both @ref BLE_GAP_PHY_1MBPS and\n@ref BLE_GAP_PHY_CODED interval shall be larger than or\nequal to twice the scan window."]
    pub window: u16,
    #[doc = "< Scan timeout in 10 ms units. @sa BLE_GAP_SCAN_TIMEOUT."]
    pub timeout: u16,
    #[doc = "< Channel mask for primary and secondary advertising channels.\nAt least one of the primary channels, that is channel index 37-39, must be\nset to 0.\nMasking away secondary channels is not supported."]
    pub channel_mask: ble_gap_ch_mask_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_scan_params_t"][::core::mem::size_of::<ble_gap_scan_params_t>() - 14usize];
    ["Alignment of ble_gap_scan_params_t"][::core::mem::align_of::<ble_gap_scan_params_t>() - 2usize];
    ["Offset of field: ble_gap_scan_params_t::scan_phys"]
        [::core::mem::offset_of!(ble_gap_scan_params_t, scan_phys) - 1usize];
    ["Offset of field: ble_gap_scan_params_t::interval"]
        [::core::mem::offset_of!(ble_gap_scan_params_t, interval) - 2usize];
    ["Offset of field: ble_gap_scan_params_t::window"][::core::mem::offset_of!(ble_gap_scan_params_t, window) - 4usize];
    ["Offset of field: ble_gap_scan_params_t::timeout"]
        [::core::mem::offset_of!(ble_gap_scan_params_t, timeout) - 6usize];
    ["Offset of field: ble_gap_scan_params_t::channel_mask"]
        [::core::mem::offset_of!(ble_gap_scan_params_t, channel_mask) - 8usize];
};
impl ble_gap_scan_params_t {
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn extended_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_extended_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn report_incomplete_evts(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_report_incomplete_evts(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn report_incomplete_evts_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_report_incomplete_evts_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_active_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn filter_policy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_filter_policy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn filter_policy_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_filter_policy_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extended: u8,
        report_incomplete_evts: u8,
        active: u8,
        filter_policy: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extended: u8 = unsafe { ::core::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let report_incomplete_evts: u8 = unsafe { ::core::mem::transmute(report_incomplete_evts) };
            report_incomplete_evts as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let filter_policy: u8 = unsafe { ::core::mem::transmute(filter_policy) };
            filter_policy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Privacy.\n\n        The privacy feature provides a way for the device to avoid being tracked over a period of time.\n        The privacy feature, when enabled, hides the local device identity and replaces it with a private address\n        that is automatically refreshed at a specified interval.\n\n        If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).\n        With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,\n        and devices can establish connections without revealing their real identities.\n\n        Both network privacy (@ref BLE_GAP_PRIVACY_MODE_NETWORK_PRIVACY) and device privacy (@ref BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY)\n        are supported.\n\n @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all\n        bonding procedures performed after @ref sd_ble_gap_privacy_set returns.\n        The IRK distributed during bonding procedure is the device IRK that is active when @ref sd_ble_gap_sec_params_reply is called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_privacy_params_t {
    #[doc = "< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF."]
    pub privacy_mode: u8,
    #[doc = "< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE."]
    pub private_addr_type: u8,
    #[doc = "< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S."]
    pub private_addr_cycle_s: u16,
    #[doc = "< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.\nWhen used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.\nBy default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise."]
    pub p_device_irk: *mut ble_gap_irk_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_privacy_params_t"][::core::mem::size_of::<ble_gap_privacy_params_t>() - 8usize];
    ["Alignment of ble_gap_privacy_params_t"][::core::mem::align_of::<ble_gap_privacy_params_t>() - 4usize];
    ["Offset of field: ble_gap_privacy_params_t::privacy_mode"]
        [::core::mem::offset_of!(ble_gap_privacy_params_t, privacy_mode) - 0usize];
    ["Offset of field: ble_gap_privacy_params_t::private_addr_type"]
        [::core::mem::offset_of!(ble_gap_privacy_params_t, private_addr_type) - 1usize];
    ["Offset of field: ble_gap_privacy_params_t::private_addr_cycle_s"]
        [::core::mem::offset_of!(ble_gap_privacy_params_t, private_addr_cycle_s) - 2usize];
    ["Offset of field: ble_gap_privacy_params_t::p_device_irk"]
        [::core::mem::offset_of!(ble_gap_privacy_params_t, p_device_irk) - 4usize];
};
#[doc = "@brief PHY preferences for TX and RX\n @note  tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction.\n @code\n p_gap_phys->tx_phys = BLE_GAP_PHY_1MBPS | BLE_GAP_PHY_2MBPS;\n p_gap_phys->rx_phys = BLE_GAP_PHY_1MBPS | BLE_GAP_PHY_2MBPS;\n @endcode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_phys_t {
    #[doc = "< Preferred transmit PHYs, see @ref BLE_GAP_PHYS."]
    pub tx_phys: u8,
    #[doc = "< Preferred receive PHYs, see @ref BLE_GAP_PHYS."]
    pub rx_phys: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_phys_t"][::core::mem::size_of::<ble_gap_phys_t>() - 2usize];
    ["Alignment of ble_gap_phys_t"][::core::mem::align_of::<ble_gap_phys_t>() - 1usize];
    ["Offset of field: ble_gap_phys_t::tx_phys"][::core::mem::offset_of!(ble_gap_phys_t, tx_phys) - 0usize];
    ["Offset of field: ble_gap_phys_t::rx_phys"][::core::mem::offset_of!(ble_gap_phys_t, rx_phys) - 1usize];
};
#[doc = " @brief Keys that can be exchanged during a bonding procedure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_kdist_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sec_kdist_t"][::core::mem::size_of::<ble_gap_sec_kdist_t>() - 1usize];
    ["Alignment of ble_gap_sec_kdist_t"][::core::mem::align_of::<ble_gap_sec_kdist_t>() - 1usize];
};
impl ble_gap_sec_kdist_t {
    #[inline]
    pub fn enc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn id(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_link_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enc: u8, id: u8, sign: u8, link: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enc: u8 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let id: u8 = unsafe { ::core::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sign: u8 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let link: u8 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP security parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_params_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance."]
    pub min_key_size: u8,
    #[doc = "< Maximum encryption key size in octets between min_key_size and 16."]
    pub max_key_size: u8,
    #[doc = "< Key distribution bitmap: keys that the local device will distribute."]
    pub kdist_own: ble_gap_sec_kdist_t,
    #[doc = "< Key distribution bitmap: keys that the remote device will distribute."]
    pub kdist_peer: ble_gap_sec_kdist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sec_params_t"][::core::mem::size_of::<ble_gap_sec_params_t>() - 5usize];
    ["Alignment of ble_gap_sec_params_t"][::core::mem::align_of::<ble_gap_sec_params_t>() - 1usize];
    ["Offset of field: ble_gap_sec_params_t::min_key_size"]
        [::core::mem::offset_of!(ble_gap_sec_params_t, min_key_size) - 1usize];
    ["Offset of field: ble_gap_sec_params_t::max_key_size"]
        [::core::mem::offset_of!(ble_gap_sec_params_t, max_key_size) - 2usize];
    ["Offset of field: ble_gap_sec_params_t::kdist_own"]
        [::core::mem::offset_of!(ble_gap_sec_params_t, kdist_own) - 3usize];
    ["Offset of field: ble_gap_sec_params_t::kdist_peer"]
        [::core::mem::offset_of!(ble_gap_sec_params_t, kdist_peer) - 4usize];
};
impl ble_gap_sec_params_t {
    #[inline]
    pub fn bond(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bond(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bond_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bond_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mitm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mitm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mitm_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mitm_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lesc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lesc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn keypress(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn keypress_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_keypress_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn io_caps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_io_caps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn io_caps_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_io_caps_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn oob(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oob(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oob_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_oob_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bond: u8,
        mitm: u8,
        lesc: u8,
        keypress: u8,
        io_caps: u8,
        oob: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bond: u8 = unsafe { ::core::mem::transmute(bond) };
            bond as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mitm: u8 = unsafe { ::core::mem::transmute(mitm) };
            mitm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keypress: u8 = unsafe { ::core::mem::transmute(keypress) };
            keypress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let io_caps: u8 = unsafe { ::core::mem::transmute(io_caps) };
            io_caps as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let oob: u8 = unsafe { ::core::mem::transmute(oob) };
            oob as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP Encryption Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_enc_info_t {
    #[doc = "< Long Term Key."]
    pub ltk: [u8; 16usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_enc_info_t"][::core::mem::size_of::<ble_gap_enc_info_t>() - 17usize];
    ["Alignment of ble_gap_enc_info_t"][::core::mem::align_of::<ble_gap_enc_info_t>() - 1usize];
    ["Offset of field: ble_gap_enc_info_t::ltk"][::core::mem::offset_of!(ble_gap_enc_info_t, ltk) - 0usize];
};
impl ble_gap_enc_info_t {
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lesc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lesc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn auth_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_auth_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltk_len(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ltk_len(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltk_len_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ltk_len_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lesc: u8, auth: u8, ltk_len: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auth: u8 = unsafe { ::core::mem::transmute(auth) };
            auth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let ltk_len: u8 = unsafe { ::core::mem::transmute(ltk_len) };
            ltk_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GAP Master Identification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_master_id_t {
    #[doc = "< Encrypted Diversifier."]
    pub ediv: u16,
    #[doc = "< Random Number."]
    pub rand: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_master_id_t"][::core::mem::size_of::<ble_gap_master_id_t>() - 10usize];
    ["Alignment of ble_gap_master_id_t"][::core::mem::align_of::<ble_gap_master_id_t>() - 2usize];
    ["Offset of field: ble_gap_master_id_t::ediv"][::core::mem::offset_of!(ble_gap_master_id_t, ediv) - 0usize];
    ["Offset of field: ble_gap_master_id_t::rand"][::core::mem::offset_of!(ble_gap_master_id_t, rand) - 2usize];
};
#[doc = "@brief GAP Signing Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sign_info_t {
    #[doc = "< Connection Signature Resolving Key."]
    pub csrk: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sign_info_t"][::core::mem::size_of::<ble_gap_sign_info_t>() - 16usize];
    ["Alignment of ble_gap_sign_info_t"][::core::mem::align_of::<ble_gap_sign_info_t>() - 1usize];
    ["Offset of field: ble_gap_sign_info_t::csrk"][::core::mem::offset_of!(ble_gap_sign_info_t, csrk) - 0usize];
};
#[doc = "@brief GAP LE Secure Connections P-256 Public Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_lesc_p256_pk_t {
    #[doc = "< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian."]
    pub pk: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_lesc_p256_pk_t"][::core::mem::size_of::<ble_gap_lesc_p256_pk_t>() - 64usize];
    ["Alignment of ble_gap_lesc_p256_pk_t"][::core::mem::align_of::<ble_gap_lesc_p256_pk_t>() - 1usize];
    ["Offset of field: ble_gap_lesc_p256_pk_t::pk"][::core::mem::offset_of!(ble_gap_lesc_p256_pk_t, pk) - 0usize];
};
#[doc = "@brief GAP LE Secure Connections DHKey."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_lesc_dhkey_t {
    #[doc = "< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian."]
    pub key: [u8; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_lesc_dhkey_t"][::core::mem::size_of::<ble_gap_lesc_dhkey_t>() - 32usize];
    ["Alignment of ble_gap_lesc_dhkey_t"][::core::mem::align_of::<ble_gap_lesc_dhkey_t>() - 1usize];
    ["Offset of field: ble_gap_lesc_dhkey_t::key"][::core::mem::offset_of!(ble_gap_lesc_dhkey_t, key) - 0usize];
};
#[doc = "@brief GAP LE Secure Connections OOB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_lesc_oob_data_t {
    #[doc = "< Bluetooth address of the device."]
    pub addr: ble_gap_addr_t,
    #[doc = "< Random Number."]
    pub r: [u8; 16usize],
    #[doc = "< Confirm Value."]
    pub c: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_lesc_oob_data_t"][::core::mem::size_of::<ble_gap_lesc_oob_data_t>() - 39usize];
    ["Alignment of ble_gap_lesc_oob_data_t"][::core::mem::align_of::<ble_gap_lesc_oob_data_t>() - 1usize];
    ["Offset of field: ble_gap_lesc_oob_data_t::addr"][::core::mem::offset_of!(ble_gap_lesc_oob_data_t, addr) - 0usize];
    ["Offset of field: ble_gap_lesc_oob_data_t::r"][::core::mem::offset_of!(ble_gap_lesc_oob_data_t, r) - 7usize];
    ["Offset of field: ble_gap_lesc_oob_data_t::c"][::core::mem::offset_of!(ble_gap_lesc_oob_data_t, c) - 23usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONNECTED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_connected_t {
    #[doc = "< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1\nand the address is the device's identity address."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< BLE role for this connection, see @ref BLE_GAP_ROLES"]
    pub role: u8,
    #[doc = "< GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
    #[doc = "< Advertising handle in which advertising has ended.\nThis variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH."]
    pub adv_handle: u8,
    #[doc = "< Advertising buffers corresponding to the terminated\nadvertising set. The advertising buffers provided in\n@ref sd_ble_gap_adv_set_configure are now released.\nThis variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH."]
    pub adv_data: ble_gap_adv_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_connected_t"][::core::mem::size_of::<ble_gap_evt_connected_t>() - 36usize];
    ["Alignment of ble_gap_evt_connected_t"][::core::mem::align_of::<ble_gap_evt_connected_t>() - 4usize];
    ["Offset of field: ble_gap_evt_connected_t::peer_addr"]
        [::core::mem::offset_of!(ble_gap_evt_connected_t, peer_addr) - 0usize];
    ["Offset of field: ble_gap_evt_connected_t::role"][::core::mem::offset_of!(ble_gap_evt_connected_t, role) - 7usize];
    ["Offset of field: ble_gap_evt_connected_t::conn_params"]
        [::core::mem::offset_of!(ble_gap_evt_connected_t, conn_params) - 8usize];
    ["Offset of field: ble_gap_evt_connected_t::adv_handle"]
        [::core::mem::offset_of!(ble_gap_evt_connected_t, adv_handle) - 16usize];
    ["Offset of field: ble_gap_evt_connected_t::adv_data"]
        [::core::mem::offset_of!(ble_gap_evt_connected_t, adv_data) - 20usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DISCONNECTED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_disconnected_t {
    #[doc = "< HCI error code, see @ref BLE_HCI_STATUS_CODES."]
    pub reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_disconnected_t"][::core::mem::size_of::<ble_gap_evt_disconnected_t>() - 1usize];
    ["Alignment of ble_gap_evt_disconnected_t"][::core::mem::align_of::<ble_gap_evt_disconnected_t>() - 1usize];
    ["Offset of field: ble_gap_evt_disconnected_t::reason"]
        [::core::mem::offset_of!(ble_gap_evt_disconnected_t, reason) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_param_update_t {
    #[doc = "<  GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_conn_param_update_t"][::core::mem::size_of::<ble_gap_evt_conn_param_update_t>() - 8usize];
    ["Alignment of ble_gap_evt_conn_param_update_t"]
        [::core::mem::align_of::<ble_gap_evt_conn_param_update_t>() - 2usize];
    ["Offset of field: ble_gap_evt_conn_param_update_t::conn_params"]
        [::core::mem::offset_of!(ble_gap_evt_conn_param_update_t, conn_params) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_PHY_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_phy_update_request_t {
    #[doc = "< The PHYs the peer prefers to use."]
    pub peer_preferred_phys: ble_gap_phys_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_phy_update_request_t"][::core::mem::size_of::<ble_gap_evt_phy_update_request_t>() - 2usize];
    ["Alignment of ble_gap_evt_phy_update_request_t"]
        [::core::mem::align_of::<ble_gap_evt_phy_update_request_t>() - 1usize];
    ["Offset of field: ble_gap_evt_phy_update_request_t::peer_preferred_phys"]
        [::core::mem::offset_of!(ble_gap_evt_phy_update_request_t, peer_preferred_phys) - 0usize];
};
#[doc = "@brief Event Structure for @ref BLE_GAP_EVT_PHY_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_phy_update_t {
    #[doc = "< Status of the procedure, see @ref BLE_HCI_STATUS_CODES."]
    pub status: u8,
    #[doc = "< TX PHY for this connection, see @ref BLE_GAP_PHYS."]
    pub tx_phy: u8,
    #[doc = "< RX PHY for this connection, see @ref BLE_GAP_PHYS."]
    pub rx_phy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_phy_update_t"][::core::mem::size_of::<ble_gap_evt_phy_update_t>() - 3usize];
    ["Alignment of ble_gap_evt_phy_update_t"][::core::mem::align_of::<ble_gap_evt_phy_update_t>() - 1usize];
    ["Offset of field: ble_gap_evt_phy_update_t::status"]
        [::core::mem::offset_of!(ble_gap_evt_phy_update_t, status) - 0usize];
    ["Offset of field: ble_gap_evt_phy_update_t::tx_phy"]
        [::core::mem::offset_of!(ble_gap_evt_phy_update_t, tx_phy) - 1usize];
    ["Offset of field: ble_gap_evt_phy_update_t::rx_phy"]
        [::core::mem::offset_of!(ble_gap_evt_phy_update_t, rx_phy) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_params_request_t {
    #[doc = "< Initiator Security Parameters."]
    pub peer_params: ble_gap_sec_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_sec_params_request_t"][::core::mem::size_of::<ble_gap_evt_sec_params_request_t>() - 5usize];
    ["Alignment of ble_gap_evt_sec_params_request_t"]
        [::core::mem::align_of::<ble_gap_evt_sec_params_request_t>() - 1usize];
    ["Offset of field: ble_gap_evt_sec_params_request_t::peer_params"]
        [::core::mem::offset_of!(ble_gap_evt_sec_params_request_t, peer_params) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_INFO_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_info_request_t {
    #[doc = "< Bluetooth address of the peer device."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< Master Identification for LTK lookup."]
    pub master_id: ble_gap_master_id_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_sec_info_request_t"][::core::mem::size_of::<ble_gap_evt_sec_info_request_t>() - 20usize];
    ["Alignment of ble_gap_evt_sec_info_request_t"][::core::mem::align_of::<ble_gap_evt_sec_info_request_t>() - 2usize];
    ["Offset of field: ble_gap_evt_sec_info_request_t::peer_addr"]
        [::core::mem::offset_of!(ble_gap_evt_sec_info_request_t, peer_addr) - 0usize];
    ["Offset of field: ble_gap_evt_sec_info_request_t::master_id"]
        [::core::mem::offset_of!(ble_gap_evt_sec_info_request_t, master_id) - 8usize];
};
impl ble_gap_evt_sec_info_request_t {
    #[inline]
    pub fn enc_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enc_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enc_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enc_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn id_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_id_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_id_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_info_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sign_info_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enc_info: u8, id_info: u8, sign_info: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enc_info: u8 = unsafe { ::core::mem::transmute(enc_info) };
            enc_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let id_info: u8 = unsafe { ::core::mem::transmute(id_info) };
            id_info as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sign_info: u8 = unsafe { ::core::mem::transmute(sign_info) };
            sign_info as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_PASSKEY_DISPLAY."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_passkey_display_t {
    #[doc = "< 6-digit passkey in ASCII ('0'-'9' digits only)."]
    pub passkey: [u8; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_passkey_display_t"][::core::mem::size_of::<ble_gap_evt_passkey_display_t>() - 7usize];
    ["Alignment of ble_gap_evt_passkey_display_t"][::core::mem::align_of::<ble_gap_evt_passkey_display_t>() - 1usize];
    ["Offset of field: ble_gap_evt_passkey_display_t::passkey"]
        [::core::mem::offset_of!(ble_gap_evt_passkey_display_t, passkey) - 0usize];
};
impl ble_gap_evt_passkey_display_t {
    #[inline]
    pub fn match_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_match_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn match_request_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_match_request_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(match_request: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let match_request: u8 = unsafe { ::core::mem::transmute(match_request) };
            match_request as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_KEY_PRESSED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_key_pressed_t {
    #[doc = "< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES."]
    pub kp_not: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_key_pressed_t"][::core::mem::size_of::<ble_gap_evt_key_pressed_t>() - 1usize];
    ["Alignment of ble_gap_evt_key_pressed_t"][::core::mem::align_of::<ble_gap_evt_key_pressed_t>() - 1usize];
    ["Offset of field: ble_gap_evt_key_pressed_t::kp_not"]
        [::core::mem::offset_of!(ble_gap_evt_key_pressed_t, kp_not) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_AUTH_KEY_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_auth_key_request_t {
    #[doc = "< See @ref BLE_GAP_AUTH_KEY_TYPES."]
    pub key_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_auth_key_request_t"][::core::mem::size_of::<ble_gap_evt_auth_key_request_t>() - 1usize];
    ["Alignment of ble_gap_evt_auth_key_request_t"][::core::mem::align_of::<ble_gap_evt_auth_key_request_t>() - 1usize];
    ["Offset of field: ble_gap_evt_auth_key_request_t::key_type"]
        [::core::mem::offset_of!(ble_gap_evt_auth_key_request_t, key_type) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_lesc_dhkey_request_t {
    #[doc = "< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory\ninside the keyset during the call to @ref sd_ble_gap_sec_params_reply."]
    pub p_pk_peer: *mut ble_gap_lesc_p256_pk_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_lesc_dhkey_request_t"][::core::mem::size_of::<ble_gap_evt_lesc_dhkey_request_t>() - 8usize];
    ["Alignment of ble_gap_evt_lesc_dhkey_request_t"]
        [::core::mem::align_of::<ble_gap_evt_lesc_dhkey_request_t>() - 4usize];
    ["Offset of field: ble_gap_evt_lesc_dhkey_request_t::p_pk_peer"]
        [::core::mem::offset_of!(ble_gap_evt_lesc_dhkey_request_t, p_pk_peer) - 0usize];
};
impl ble_gap_evt_lesc_dhkey_request_t {
    #[inline]
    pub fn oobd_req(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oobd_req(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oobd_req_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_oobd_req_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(oobd_req: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let oobd_req: u8 = unsafe { ::core::mem::transmute(oobd_req) };
            oobd_req as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Security levels supported.\n @note  See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_levels_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sec_levels_t"][::core::mem::size_of::<ble_gap_sec_levels_t>() - 1usize];
    ["Alignment of ble_gap_sec_levels_t"][::core::mem::align_of::<ble_gap_sec_levels_t>() - 1usize];
};
impl ble_gap_sec_levels_t {
    #[inline]
    pub fn lv1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lv1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lv1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lv2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lv2_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lv2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lv3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lv3_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lv3_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lv4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lv4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lv4_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lv4_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lv1: u8, lv2: u8, lv3: u8, lv4: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lv1: u8 = unsafe { ::core::mem::transmute(lv1) };
            lv1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lv2: u8 = unsafe { ::core::mem::transmute(lv2) };
            lv2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lv3: u8 = unsafe { ::core::mem::transmute(lv3) };
            lv3 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lv4: u8 = unsafe { ::core::mem::transmute(lv4) };
            lv4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Encryption Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_enc_key_t {
    #[doc = "< Encryption Information."]
    pub enc_info: ble_gap_enc_info_t,
    #[doc = "< Master Identification."]
    pub master_id: ble_gap_master_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_enc_key_t"][::core::mem::size_of::<ble_gap_enc_key_t>() - 28usize];
    ["Alignment of ble_gap_enc_key_t"][::core::mem::align_of::<ble_gap_enc_key_t>() - 2usize];
    ["Offset of field: ble_gap_enc_key_t::enc_info"][::core::mem::offset_of!(ble_gap_enc_key_t, enc_info) - 0usize];
    ["Offset of field: ble_gap_enc_key_t::master_id"][::core::mem::offset_of!(ble_gap_enc_key_t, master_id) - 18usize];
};
#[doc = "@brief Identity Key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_id_key_t {
    #[doc = "< Identity Resolving Key."]
    pub id_info: ble_gap_irk_t,
    #[doc = "< Identity Address."]
    pub id_addr_info: ble_gap_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_id_key_t"][::core::mem::size_of::<ble_gap_id_key_t>() - 23usize];
    ["Alignment of ble_gap_id_key_t"][::core::mem::align_of::<ble_gap_id_key_t>() - 1usize];
    ["Offset of field: ble_gap_id_key_t::id_info"][::core::mem::offset_of!(ble_gap_id_key_t, id_info) - 0usize];
    ["Offset of field: ble_gap_id_key_t::id_addr_info"]
        [::core::mem::offset_of!(ble_gap_id_key_t, id_addr_info) - 16usize];
};
#[doc = "@brief Security Keys."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_keys_t {
    #[doc = "< Encryption Key, or NULL."]
    pub p_enc_key: *mut ble_gap_enc_key_t,
    #[doc = "< Identity Key, or NULL."]
    pub p_id_key: *mut ble_gap_id_key_t,
    #[doc = "< Signing Key, or NULL."]
    pub p_sign_key: *mut ble_gap_sign_info_t,
    #[doc = "< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined\nin the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1"]
    pub p_pk: *mut ble_gap_lesc_p256_pk_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sec_keys_t"][::core::mem::size_of::<ble_gap_sec_keys_t>() - 16usize];
    ["Alignment of ble_gap_sec_keys_t"][::core::mem::align_of::<ble_gap_sec_keys_t>() - 4usize];
    ["Offset of field: ble_gap_sec_keys_t::p_enc_key"][::core::mem::offset_of!(ble_gap_sec_keys_t, p_enc_key) - 0usize];
    ["Offset of field: ble_gap_sec_keys_t::p_id_key"][::core::mem::offset_of!(ble_gap_sec_keys_t, p_id_key) - 4usize];
    ["Offset of field: ble_gap_sec_keys_t::p_sign_key"]
        [::core::mem::offset_of!(ble_gap_sec_keys_t, p_sign_key) - 8usize];
    ["Offset of field: ble_gap_sec_keys_t::p_pk"][::core::mem::offset_of!(ble_gap_sec_keys_t, p_pk) - 12usize];
};
#[doc = "@brief Security key set for both local and peer keys."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_keyset_t {
    #[doc = "< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding."]
    pub keys_own: ble_gap_sec_keys_t,
    #[doc = "< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL."]
    pub keys_peer: ble_gap_sec_keys_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_sec_keyset_t"][::core::mem::size_of::<ble_gap_sec_keyset_t>() - 32usize];
    ["Alignment of ble_gap_sec_keyset_t"][::core::mem::align_of::<ble_gap_sec_keyset_t>() - 4usize];
    ["Offset of field: ble_gap_sec_keyset_t::keys_own"]
        [::core::mem::offset_of!(ble_gap_sec_keyset_t, keys_own) - 0usize];
    ["Offset of field: ble_gap_sec_keyset_t::keys_peer"]
        [::core::mem::offset_of!(ble_gap_sec_keyset_t, keys_peer) - 16usize];
};
#[doc = "@brief Data Length Update Procedure parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_data_length_params_t {
    #[doc = "< Maximum number of payload octets that a Controller supports for transmission of a single Link Layer Data Channel PDU."]
    pub max_tx_octets: u16,
    #[doc = "< Maximum number of payload octets that a Controller supports for reception of a single Link Layer Data Channel PDU."]
    pub max_rx_octets: u16,
    #[doc = "< Maximum time, in microseconds, that a Controller supports for transmission of a single Link Layer Data Channel PDU."]
    pub max_tx_time_us: u16,
    #[doc = "< Maximum time, in microseconds, that a Controller supports for reception of a single Link Layer Data Channel PDU."]
    pub max_rx_time_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_data_length_params_t"][::core::mem::size_of::<ble_gap_data_length_params_t>() - 8usize];
    ["Alignment of ble_gap_data_length_params_t"][::core::mem::align_of::<ble_gap_data_length_params_t>() - 2usize];
    ["Offset of field: ble_gap_data_length_params_t::max_tx_octets"]
        [::core::mem::offset_of!(ble_gap_data_length_params_t, max_tx_octets) - 0usize];
    ["Offset of field: ble_gap_data_length_params_t::max_rx_octets"]
        [::core::mem::offset_of!(ble_gap_data_length_params_t, max_rx_octets) - 2usize];
    ["Offset of field: ble_gap_data_length_params_t::max_tx_time_us"]
        [::core::mem::offset_of!(ble_gap_data_length_params_t, max_tx_time_us) - 4usize];
    ["Offset of field: ble_gap_data_length_params_t::max_rx_time_us"]
        [::core::mem::offset_of!(ble_gap_data_length_params_t, max_rx_time_us) - 6usize];
};
#[doc = "@brief Data Length Update Procedure local limitation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_data_length_limitation_t {
    #[doc = "< If > 0, the requested TX packet length is too long by this many octets."]
    pub tx_payload_limited_octets: u16,
    #[doc = "< If > 0, the requested RX packet length is too long by this many octets."]
    pub rx_payload_limited_octets: u16,
    #[doc = "< If > 0, the requested combination of TX and RX packet lengths is too long by this many microseconds."]
    pub tx_rx_time_limited_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_data_length_limitation_t"][::core::mem::size_of::<ble_gap_data_length_limitation_t>() - 6usize];
    ["Alignment of ble_gap_data_length_limitation_t"]
        [::core::mem::align_of::<ble_gap_data_length_limitation_t>() - 2usize];
    ["Offset of field: ble_gap_data_length_limitation_t::tx_payload_limited_octets"]
        [::core::mem::offset_of!(ble_gap_data_length_limitation_t, tx_payload_limited_octets) - 0usize];
    ["Offset of field: ble_gap_data_length_limitation_t::rx_payload_limited_octets"]
        [::core::mem::offset_of!(ble_gap_data_length_limitation_t, rx_payload_limited_octets) - 2usize];
    ["Offset of field: ble_gap_data_length_limitation_t::tx_rx_time_limited_us"]
        [::core::mem::offset_of!(ble_gap_data_length_limitation_t, tx_rx_time_limited_us) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_AUTH_STATUS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_auth_status_t {
    #[doc = "< Authentication status, see @ref BLE_GAP_SEC_STATUS."]
    pub auth_status: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Levels supported in Security Mode 1."]
    pub sm1_levels: ble_gap_sec_levels_t,
    #[doc = "< Levels supported in Security Mode 2."]
    pub sm2_levels: ble_gap_sec_levels_t,
    #[doc = "< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set."]
    pub kdist_own: ble_gap_sec_kdist_t,
    #[doc = "< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set."]
    pub kdist_peer: ble_gap_sec_kdist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_auth_status_t"][::core::mem::size_of::<ble_gap_evt_auth_status_t>() - 6usize];
    ["Alignment of ble_gap_evt_auth_status_t"][::core::mem::align_of::<ble_gap_evt_auth_status_t>() - 1usize];
    ["Offset of field: ble_gap_evt_auth_status_t::auth_status"]
        [::core::mem::offset_of!(ble_gap_evt_auth_status_t, auth_status) - 0usize];
    ["Offset of field: ble_gap_evt_auth_status_t::sm1_levels"]
        [::core::mem::offset_of!(ble_gap_evt_auth_status_t, sm1_levels) - 2usize];
    ["Offset of field: ble_gap_evt_auth_status_t::sm2_levels"]
        [::core::mem::offset_of!(ble_gap_evt_auth_status_t, sm2_levels) - 3usize];
    ["Offset of field: ble_gap_evt_auth_status_t::kdist_own"]
        [::core::mem::offset_of!(ble_gap_evt_auth_status_t, kdist_own) - 4usize];
    ["Offset of field: ble_gap_evt_auth_status_t::kdist_peer"]
        [::core::mem::offset_of!(ble_gap_evt_auth_status_t, kdist_peer) - 5usize];
};
impl ble_gap_evt_auth_status_t {
    #[inline]
    pub fn error_src(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_error_src(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn error_src_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_error_src_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bonded(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bonded(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bonded_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bonded_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lesc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lesc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(error_src: u8, bonded: u8, lesc: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let error_src: u8 = unsafe { ::core::mem::transmute(error_src) };
            error_src as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bonded: u8 = unsafe { ::core::mem::transmute(bonded) };
            bonded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_SEC_UPDATE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_sec_update_t {
    #[doc = "< Connection security level."]
    pub conn_sec: ble_gap_conn_sec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_conn_sec_update_t"][::core::mem::size_of::<ble_gap_evt_conn_sec_update_t>() - 2usize];
    ["Alignment of ble_gap_evt_conn_sec_update_t"][::core::mem::align_of::<ble_gap_evt_conn_sec_update_t>() - 1usize];
    ["Offset of field: ble_gap_evt_conn_sec_update_t::conn_sec"]
        [::core::mem::offset_of!(ble_gap_evt_conn_sec_update_t, conn_sec) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_evt_timeout_t {
    #[doc = "< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES."]
    pub src: u8,
    #[doc = "< Event Parameters."]
    pub params: ble_gap_evt_timeout_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_evt_timeout_t__bindgen_ty_1 {
    #[doc = "< If source is set to @ref BLE_GAP_TIMEOUT_SRC_SCAN, the released\nscan buffer is contained in this field."]
    pub adv_report_buffer: ble_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_timeout_t__bindgen_ty_1"]
        [::core::mem::size_of::<ble_gap_evt_timeout_t__bindgen_ty_1>() - 8usize];
    ["Alignment of ble_gap_evt_timeout_t__bindgen_ty_1"]
        [::core::mem::align_of::<ble_gap_evt_timeout_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_gap_evt_timeout_t__bindgen_ty_1::adv_report_buffer"]
        [::core::mem::offset_of!(ble_gap_evt_timeout_t__bindgen_ty_1, adv_report_buffer) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_timeout_t"][::core::mem::size_of::<ble_gap_evt_timeout_t>() - 12usize];
    ["Alignment of ble_gap_evt_timeout_t"][::core::mem::align_of::<ble_gap_evt_timeout_t>() - 4usize];
    ["Offset of field: ble_gap_evt_timeout_t::src"][::core::mem::offset_of!(ble_gap_evt_timeout_t, src) - 0usize];
    ["Offset of field: ble_gap_evt_timeout_t::params"][::core::mem::offset_of!(ble_gap_evt_timeout_t, params) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_RSSI_CHANGED."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_rssi_changed_t {
    #[doc = "< Received Signal Strength Indication in dBm.\n@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Data Channel Index on which the Signal Strength is measured (0-36)."]
    pub ch_index: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_rssi_changed_t"][::core::mem::size_of::<ble_gap_evt_rssi_changed_t>() - 2usize];
    ["Alignment of ble_gap_evt_rssi_changed_t"][::core::mem::align_of::<ble_gap_evt_rssi_changed_t>() - 1usize];
    ["Offset of field: ble_gap_evt_rssi_changed_t::rssi"]
        [::core::mem::offset_of!(ble_gap_evt_rssi_changed_t, rssi) - 0usize];
    ["Offset of field: ble_gap_evt_rssi_changed_t::ch_index"]
        [::core::mem::offset_of!(ble_gap_evt_rssi_changed_t, ch_index) - 1usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_ADV_SET_TERMINATED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_adv_set_terminated_t {
    #[doc = "< Reason for why the advertising set terminated. See\n@ref BLE_GAP_EVT_ADV_SET_TERMINATED_REASON."]
    pub reason: u8,
    #[doc = "< Advertising handle in which advertising has ended."]
    pub adv_handle: u8,
    #[doc = "< If @ref ble_gap_adv_params_t::max_adv_evts was not set to 0,\nthis field indicates the number of completed advertising events."]
    pub num_completed_adv_events: u8,
    #[doc = "< Advertising buffers corresponding to the terminated\nadvertising set. The advertising buffers provided in\n@ref sd_ble_gap_adv_set_configure are now released."]
    pub adv_data: ble_gap_adv_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_adv_set_terminated_t"][::core::mem::size_of::<ble_gap_evt_adv_set_terminated_t>() - 20usize];
    ["Alignment of ble_gap_evt_adv_set_terminated_t"]
        [::core::mem::align_of::<ble_gap_evt_adv_set_terminated_t>() - 4usize];
    ["Offset of field: ble_gap_evt_adv_set_terminated_t::reason"]
        [::core::mem::offset_of!(ble_gap_evt_adv_set_terminated_t, reason) - 0usize];
    ["Offset of field: ble_gap_evt_adv_set_terminated_t::adv_handle"]
        [::core::mem::offset_of!(ble_gap_evt_adv_set_terminated_t, adv_handle) - 1usize];
    ["Offset of field: ble_gap_evt_adv_set_terminated_t::num_completed_adv_events"]
        [::core::mem::offset_of!(ble_gap_evt_adv_set_terminated_t, num_completed_adv_events) - 2usize];
    ["Offset of field: ble_gap_evt_adv_set_terminated_t::adv_data"]
        [::core::mem::offset_of!(ble_gap_evt_adv_set_terminated_t, adv_data) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_ADV_REPORT.\n\n @note If @ref ble_gap_adv_report_type_t::status is set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA,\n       not all fields in the advertising report may be available.\n\n @note When ble_gap_adv_report_type_t::status is not set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA,\n       scanning will be paused. To continue scanning, call @ref sd_ble_gap_scan_start."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_adv_report_t {
    #[doc = "< Advertising report type. See @ref ble_gap_adv_report_type_t."]
    pub type_: ble_gap_adv_report_type_t,
    #[doc = "< Bluetooth address of the peer device. If the peer_addr is resolved:\n@ref ble_gap_addr_t::addr_id_peer is set to 1 and the address is the\npeer's identity address."]
    pub peer_addr: ble_gap_addr_t,
    #[doc = "< Contains the target address of the advertising event if\n@ref ble_gap_adv_report_type_t::directed is set to 1. If the\nSoftDevice was able to resolve the address,\n@ref ble_gap_addr_t::addr_id_peer is set to 1 and the direct_addr\ncontains the local identity address. If the target address of the\nadvertising event is @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE,\nand the SoftDevice was unable to resolve it, the application may try\nto resolve this address to find out if the advertising event was\ndirected to us."]
    pub direct_addr: ble_gap_addr_t,
    #[doc = "< Indicates the PHY on which the primary advertising packet was received.\nSee @ref BLE_GAP_PHYS."]
    pub primary_phy: u8,
    #[doc = "< Indicates the PHY on which the secondary advertising packet was received.\nSee @ref BLE_GAP_PHYS. This field is set to @ref BLE_GAP_PHY_NOT_SET if no packets\nwere received on a secondary advertising channel."]
    pub secondary_phy: u8,
    #[doc = "< TX Power reported by the advertiser in the last packet header received.\nThis field is set to @ref BLE_GAP_POWER_LEVEL_INVALID if the\nlast received packet did not contain the Tx Power field.\n@note TX Power is only included in extended advertising packets."]
    pub tx_power: i8,
    #[doc = "< Received Signal Strength Indication in dBm of the last packet received.\n@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Channel Index on which the last advertising packet is received (0-39)."]
    pub ch_index: u8,
    #[doc = "< Set ID of the received advertising data. Set ID is not present\nif set to @ref BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE."]
    pub set_id: u8,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< Received advertising or scan response data. If\n@ref ble_gap_adv_report_type_t::status is not set to\n@ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA, the data buffer provided\nin @ref sd_ble_gap_scan_start is now released."]
    pub data: ble_data_t,
    #[doc = "< The offset and PHY of the next advertising packet in this extended advertising\nevent. @note This field is only set if @ref ble_gap_adv_report_type_t::status\nis set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA."]
    pub aux_pointer: ble_gap_aux_pointer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_adv_report_t"][::core::mem::size_of::<ble_gap_evt_adv_report_t>() - 36usize];
    ["Alignment of ble_gap_evt_adv_report_t"][::core::mem::align_of::<ble_gap_evt_adv_report_t>() - 4usize];
    ["Offset of field: ble_gap_evt_adv_report_t::type_"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, type_) - 0usize];
    ["Offset of field: ble_gap_evt_adv_report_t::peer_addr"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, peer_addr) - 2usize];
    ["Offset of field: ble_gap_evt_adv_report_t::direct_addr"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, direct_addr) - 9usize];
    ["Offset of field: ble_gap_evt_adv_report_t::primary_phy"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, primary_phy) - 16usize];
    ["Offset of field: ble_gap_evt_adv_report_t::secondary_phy"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, secondary_phy) - 17usize];
    ["Offset of field: ble_gap_evt_adv_report_t::tx_power"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, tx_power) - 18usize];
    ["Offset of field: ble_gap_evt_adv_report_t::rssi"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, rssi) - 19usize];
    ["Offset of field: ble_gap_evt_adv_report_t::ch_index"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, ch_index) - 20usize];
    ["Offset of field: ble_gap_evt_adv_report_t::set_id"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, set_id) - 21usize];
    ["Offset of field: ble_gap_evt_adv_report_t::data"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, data) - 24usize];
    ["Offset of field: ble_gap_evt_adv_report_t::aux_pointer"]
        [::core::mem::offset_of!(ble_gap_evt_adv_report_t, aux_pointer) - 32usize];
};
impl ble_gap_evt_adv_report_t {
    #[inline]
    pub fn data_id(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_data_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_id_raw(this: *const Self) -> u16 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_data_id_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(data_id: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let data_id: u16 = unsafe { ::core::mem::transmute(data_id) };
            data_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SEC_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_sec_request_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_sec_request_t"][::core::mem::size_of::<ble_gap_evt_sec_request_t>() - 1usize];
    ["Alignment of ble_gap_evt_sec_request_t"][::core::mem::align_of::<ble_gap_evt_sec_request_t>() - 1usize];
};
impl ble_gap_evt_sec_request_t {
    #[inline]
    pub fn bond(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bond(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bond_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bond_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mitm(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mitm(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mitm_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mitm_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lesc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lesc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lesc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lesc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn keypress(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn keypress_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_keypress_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(bond: u8, mitm: u8, lesc: u8, keypress: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bond: u8 = unsafe { ::core::mem::transmute(bond) };
            bond as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mitm: u8 = unsafe { ::core::mem::transmute(mitm) };
            mitm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lesc: u8 = unsafe { ::core::mem::transmute(lesc) };
            lesc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keypress: u8 = unsafe { ::core::mem::transmute(keypress) };
            keypress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_conn_param_update_request_t {
    #[doc = "<  GAP Connection Parameters."]
    pub conn_params: ble_gap_conn_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_conn_param_update_request_t"]
        [::core::mem::size_of::<ble_gap_evt_conn_param_update_request_t>() - 8usize];
    ["Alignment of ble_gap_evt_conn_param_update_request_t"]
        [::core::mem::align_of::<ble_gap_evt_conn_param_update_request_t>() - 2usize];
    ["Offset of field: ble_gap_evt_conn_param_update_request_t::conn_params"]
        [::core::mem::offset_of!(ble_gap_evt_conn_param_update_request_t, conn_params) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_SCAN_REQ_REPORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_scan_req_report_t {
    #[doc = "< Advertising handle for the advertising set which received the Scan Request"]
    pub adv_handle: u8,
    #[doc = "< Received Signal Strength Indication in dBm.\n@note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement."]
    pub rssi: i8,
    #[doc = "< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1\nand the address is the device's identity address."]
    pub peer_addr: ble_gap_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_scan_req_report_t"][::core::mem::size_of::<ble_gap_evt_scan_req_report_t>() - 9usize];
    ["Alignment of ble_gap_evt_scan_req_report_t"][::core::mem::align_of::<ble_gap_evt_scan_req_report_t>() - 1usize];
    ["Offset of field: ble_gap_evt_scan_req_report_t::adv_handle"]
        [::core::mem::offset_of!(ble_gap_evt_scan_req_report_t, adv_handle) - 0usize];
    ["Offset of field: ble_gap_evt_scan_req_report_t::rssi"]
        [::core::mem::offset_of!(ble_gap_evt_scan_req_report_t, rssi) - 1usize];
    ["Offset of field: ble_gap_evt_scan_req_report_t::peer_addr"]
        [::core::mem::offset_of!(ble_gap_evt_scan_req_report_t, peer_addr) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_data_length_update_request_t {
    #[doc = "< Peer data length parameters."]
    pub peer_params: ble_gap_data_length_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_data_length_update_request_t"]
        [::core::mem::size_of::<ble_gap_evt_data_length_update_request_t>() - 8usize];
    ["Alignment of ble_gap_evt_data_length_update_request_t"]
        [::core::mem::align_of::<ble_gap_evt_data_length_update_request_t>() - 2usize];
    ["Offset of field: ble_gap_evt_data_length_update_request_t::peer_params"]
        [::core::mem::offset_of!(ble_gap_evt_data_length_update_request_t, peer_params) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE.\n\n @note This event may also be raised after a PHY Update procedure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_data_length_update_t {
    #[doc = "< The effective data length parameters."]
    pub effective_params: ble_gap_data_length_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_data_length_update_t"][::core::mem::size_of::<ble_gap_evt_data_length_update_t>() - 8usize];
    ["Alignment of ble_gap_evt_data_length_update_t"]
        [::core::mem::align_of::<ble_gap_evt_data_length_update_t>() - 2usize];
    ["Offset of field: ble_gap_evt_data_length_update_t::effective_params"]
        [::core::mem::offset_of!(ble_gap_evt_data_length_update_t, effective_params) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_evt_qos_channel_survey_report_t {
    #[doc = "< The measured energy on the Bluetooth Low Energy\nchannels, in dBm, indexed by Channel Index.\nIf no measurement is available for the given channel, channel_energy is set to\n@ref BLE_GAP_POWER_LEVEL_INVALID."]
    pub channel_energy: [i8; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_qos_channel_survey_report_t"]
        [::core::mem::size_of::<ble_gap_evt_qos_channel_survey_report_t>() - 40usize];
    ["Alignment of ble_gap_evt_qos_channel_survey_report_t"]
        [::core::mem::align_of::<ble_gap_evt_qos_channel_survey_report_t>() - 1usize];
    ["Offset of field: ble_gap_evt_qos_channel_survey_report_t::channel_energy"]
        [::core::mem::offset_of!(ble_gap_evt_qos_channel_survey_report_t, channel_energy) - 0usize];
};
#[doc = "@brief GAP event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_evt_t {
    #[doc = "< Connection Handle on which event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_gap_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_evt_t__bindgen_ty_1 {
    #[doc = "< Connected Event Parameters."]
    pub connected: ble_gap_evt_connected_t,
    #[doc = "< Disconnected Event Parameters."]
    pub disconnected: ble_gap_evt_disconnected_t,
    #[doc = "< Connection Parameter Update Parameters."]
    pub conn_param_update: ble_gap_evt_conn_param_update_t,
    #[doc = "< Security Parameters Request Event Parameters."]
    pub sec_params_request: ble_gap_evt_sec_params_request_t,
    #[doc = "< Security Information Request Event Parameters."]
    pub sec_info_request: ble_gap_evt_sec_info_request_t,
    #[doc = "< Passkey Display Event Parameters."]
    pub passkey_display: ble_gap_evt_passkey_display_t,
    #[doc = "< Key Pressed Event Parameters."]
    pub key_pressed: ble_gap_evt_key_pressed_t,
    #[doc = "< Authentication Key Request Event Parameters."]
    pub auth_key_request: ble_gap_evt_auth_key_request_t,
    #[doc = "< LE Secure Connections DHKey calculation request."]
    pub lesc_dhkey_request: ble_gap_evt_lesc_dhkey_request_t,
    #[doc = "< Authentication Status Event Parameters."]
    pub auth_status: ble_gap_evt_auth_status_t,
    #[doc = "< Connection Security Update Event Parameters."]
    pub conn_sec_update: ble_gap_evt_conn_sec_update_t,
    #[doc = "< Timeout Event Parameters."]
    pub timeout: ble_gap_evt_timeout_t,
    #[doc = "< RSSI Event Parameters."]
    pub rssi_changed: ble_gap_evt_rssi_changed_t,
    #[doc = "< Advertising Report Event Parameters."]
    pub adv_report: ble_gap_evt_adv_report_t,
    #[doc = "< Advertising Set Terminated Event Parameters."]
    pub adv_set_terminated: ble_gap_evt_adv_set_terminated_t,
    #[doc = "< Security Request Event Parameters."]
    pub sec_request: ble_gap_evt_sec_request_t,
    #[doc = "< Connection Parameter Update Parameters."]
    pub conn_param_update_request: ble_gap_evt_conn_param_update_request_t,
    #[doc = "< Scan Request Report Parameters."]
    pub scan_req_report: ble_gap_evt_scan_req_report_t,
    #[doc = "< PHY Update Request Event Parameters."]
    pub phy_update_request: ble_gap_evt_phy_update_request_t,
    #[doc = "< PHY Update Parameters."]
    pub phy_update: ble_gap_evt_phy_update_t,
    #[doc = "< Data Length Update Request Event Parameters."]
    pub data_length_update_request: ble_gap_evt_data_length_update_request_t,
    #[doc = "< Data Length Update Event Parameters."]
    pub data_length_update: ble_gap_evt_data_length_update_t,
    #[doc = "< Quality of Service (QoS) Channel Survey Report Parameters."]
    pub qos_channel_survey_report: ble_gap_evt_qos_channel_survey_report_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_gap_evt_t__bindgen_ty_1>() - 40usize];
    ["Alignment of ble_gap_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_gap_evt_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::connected"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, connected) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::disconnected"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, disconnected) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::conn_param_update"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, conn_param_update) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::sec_params_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, sec_params_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::sec_info_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, sec_info_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::passkey_display"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, passkey_display) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::key_pressed"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, key_pressed) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::auth_key_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, auth_key_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::lesc_dhkey_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, lesc_dhkey_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::auth_status"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, auth_status) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::conn_sec_update"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, conn_sec_update) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::timeout"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, timeout) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::rssi_changed"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, rssi_changed) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::adv_report"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, adv_report) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::adv_set_terminated"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, adv_set_terminated) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::sec_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, sec_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::conn_param_update_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, conn_param_update_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::scan_req_report"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, scan_req_report) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::phy_update_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, phy_update_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::phy_update"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, phy_update) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::data_length_update_request"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, data_length_update_request) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::data_length_update"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, data_length_update) - 0usize];
    ["Offset of field: ble_gap_evt_t__bindgen_ty_1::qos_channel_survey_report"]
        [::core::mem::offset_of!(ble_gap_evt_t__bindgen_ty_1, qos_channel_survey_report) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_evt_t"][::core::mem::size_of::<ble_gap_evt_t>() - 44usize];
    ["Alignment of ble_gap_evt_t"][::core::mem::align_of::<ble_gap_evt_t>() - 4usize];
    ["Offset of field: ble_gap_evt_t::conn_handle"][::core::mem::offset_of!(ble_gap_evt_t, conn_handle) - 0usize];
    ["Offset of field: ble_gap_evt_t::params"][::core::mem::offset_of!(ble_gap_evt_t, params) - 4usize];
};
#[doc = " @brief BLE GAP connection configuration parameters, set with @ref sd_ble_cfg_set.\n\n @retval ::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero.\n @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:\n                                    - The sum of conn_count for all connection configurations combined exceeds UINT8_MAX.\n                                    - The event length is smaller than @ref BLE_GAP_EVENT_LENGTH_MIN."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_cfg_t {
    #[doc = "< The number of concurrent connections the application can create with this configuration.\nThe default and minimum value is @ref BLE_GAP_CONN_COUNT_DEFAULT."]
    pub conn_count: u8,
    #[doc = "< The time set aside for this connection on every connection interval in 1.25 ms units.\nThe default value is @ref BLE_GAP_EVENT_LENGTH_DEFAULT, the minimum value is @ref BLE_GAP_EVENT_LENGTH_MIN.\nThe event length and the connection interval are the primary parameters\nfor setting the throughput of a connection.\nSee the SoftDevice Specification for details on throughput."]
    pub event_length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_conn_cfg_t"][::core::mem::size_of::<ble_gap_conn_cfg_t>() - 4usize];
    ["Alignment of ble_gap_conn_cfg_t"][::core::mem::align_of::<ble_gap_conn_cfg_t>() - 2usize];
    ["Offset of field: ble_gap_conn_cfg_t::conn_count"]
        [::core::mem::offset_of!(ble_gap_conn_cfg_t, conn_count) - 0usize];
    ["Offset of field: ble_gap_conn_cfg_t::event_length"]
        [::core::mem::offset_of!(ble_gap_conn_cfg_t, event_length) - 2usize];
};
#[doc = " @brief Configuration of maximum concurrent connections in the different connected roles, set with\n @ref sd_ble_cfg_set.\n\n @retval ::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too\n                                    large. The maximum supported sum of concurrent connections is\n                                    @ref BLE_GAP_ROLE_COUNT_COMBINED_MAX.\n @retval ::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count.\n @retval ::NRF_ERROR_RESOURCES      The adv_set_count is too large. The maximum\n                                    supported advertising handles is\n                                    @ref BLE_GAP_ADV_SET_COUNT_MAX."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_role_count_t {
    #[doc = "< Maximum number of advertising sets. Default value is @ref BLE_GAP_ADV_SET_COUNT_DEFAULT."]
    pub adv_set_count: u8,
    #[doc = "< Maximum number of connections concurrently acting as a peripheral. Default value is @ref BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT."]
    pub periph_role_count: u8,
    #[doc = "< Maximum number of connections concurrently acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT."]
    pub central_role_count: u8,
    #[doc = "< Number of SMP instances shared between all connections acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT."]
    pub central_sec_count: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_cfg_role_count_t"][::core::mem::size_of::<ble_gap_cfg_role_count_t>() - 5usize];
    ["Alignment of ble_gap_cfg_role_count_t"][::core::mem::align_of::<ble_gap_cfg_role_count_t>() - 1usize];
    ["Offset of field: ble_gap_cfg_role_count_t::adv_set_count"]
        [::core::mem::offset_of!(ble_gap_cfg_role_count_t, adv_set_count) - 0usize];
    ["Offset of field: ble_gap_cfg_role_count_t::periph_role_count"]
        [::core::mem::offset_of!(ble_gap_cfg_role_count_t, periph_role_count) - 1usize];
    ["Offset of field: ble_gap_cfg_role_count_t::central_role_count"]
        [::core::mem::offset_of!(ble_gap_cfg_role_count_t, central_role_count) - 2usize];
    ["Offset of field: ble_gap_cfg_role_count_t::central_sec_count"]
        [::core::mem::offset_of!(ble_gap_cfg_role_count_t, central_sec_count) - 3usize];
};
impl ble_gap_cfg_role_count_t {
    #[inline]
    pub fn qos_channel_survey_role_available(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_channel_survey_role_available(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qos_channel_survey_role_available_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_qos_channel_survey_role_available_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(qos_channel_survey_role_available: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let qos_channel_survey_role_available: u8 =
                unsafe { ::core::mem::transmute(qos_channel_survey_role_available) };
            qos_channel_survey_role_available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Device name and its properties, set with @ref sd_ble_cfg_set.\n\n @note  If the device name is not configured, the default device name will be\n        @ref BLE_GAP_DEVNAME_DEFAULT, the maximum device name length will be\n        @ref BLE_GAP_DEVNAME_DEFAULT_LEN, vloc will be set to @ref BLE_GATTS_VLOC_STACK and the device name\n        will have no write access.\n\n @note  If @ref max_len is more than @ref BLE_GAP_DEVNAME_DEFAULT_LEN and vloc is set to @ref BLE_GATTS_VLOC_STACK,\n        the attribute table size must be increased to have room for the longer device name (see\n        @ref sd_ble_cfg_set and @ref ble_gatts_cfg_attr_tab_size_t).\n\n @note  If vloc is @ref BLE_GATTS_VLOC_STACK :\n        - p_value must point to non-volatile memory (flash) or be NULL.\n        - If p_value is NULL, the device name will initially be empty.\n\n @note  If vloc is @ref BLE_GATTS_VLOC_USER :\n        - p_value cannot be NULL.\n        - If the device name is writable, p_value must point to volatile memory (RAM).\n\n @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:\n                                    - Invalid device name location (vloc).\n                                    - Invalid device name security mode.\n @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:\n                                    - The device name length is invalid (must be between 0 and @ref BLE_GAP_DEVNAME_MAX_LEN).\n                                    - The device name length is too long for the given Attribute Table.\n @retval ::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_device_name_t {
    #[doc = "< Write permissions."]
    pub write_perm: ble_gap_conn_sec_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Pointer to where the value (device name) is stored or will be stored."]
    pub p_value: *mut u8,
    #[doc = "< Current length in bytes of the memory pointed to by p_value."]
    pub current_len: u16,
    #[doc = "< Maximum length in bytes of the memory pointed to by p_value."]
    pub max_len: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_cfg_device_name_t"][::core::mem::size_of::<ble_gap_cfg_device_name_t>() - 12usize];
    ["Alignment of ble_gap_cfg_device_name_t"][::core::mem::align_of::<ble_gap_cfg_device_name_t>() - 4usize];
    ["Offset of field: ble_gap_cfg_device_name_t::write_perm"]
        [::core::mem::offset_of!(ble_gap_cfg_device_name_t, write_perm) - 0usize];
    ["Offset of field: ble_gap_cfg_device_name_t::p_value"]
        [::core::mem::offset_of!(ble_gap_cfg_device_name_t, p_value) - 4usize];
    ["Offset of field: ble_gap_cfg_device_name_t::current_len"]
        [::core::mem::offset_of!(ble_gap_cfg_device_name_t, current_len) - 8usize];
    ["Offset of field: ble_gap_cfg_device_name_t::max_len"]
        [::core::mem::offset_of!(ble_gap_cfg_device_name_t, max_len) - 10usize];
};
impl ble_gap_cfg_device_name_t {
    #[inline]
    pub fn vloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_vloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vloc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_vloc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(vloc: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let vloc: u8 = unsafe { ::core::mem::transmute(vloc) };
            vloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Peripheral Preferred Connection Parameters include configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_ppcp_incl_cfg_t {
    #[doc = "< Inclusion configuration of the Peripheral Preferred Connection Parameters characteristic.\nSee @ref BLE_GAP_CHAR_INCL_CONFIG. Default is @ref BLE_GAP_PPCP_INCL_CONFIG_DEFAULT."]
    pub include_cfg: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_cfg_ppcp_incl_cfg_t"][::core::mem::size_of::<ble_gap_cfg_ppcp_incl_cfg_t>() - 1usize];
    ["Alignment of ble_gap_cfg_ppcp_incl_cfg_t"][::core::mem::align_of::<ble_gap_cfg_ppcp_incl_cfg_t>() - 1usize];
    ["Offset of field: ble_gap_cfg_ppcp_incl_cfg_t::include_cfg"]
        [::core::mem::offset_of!(ble_gap_cfg_ppcp_incl_cfg_t, include_cfg) - 0usize];
};
#[doc = "@brief Central Address Resolution include configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_cfg_car_incl_cfg_t {
    #[doc = "< Inclusion configuration of the Central Address Resolution characteristic.\nSee @ref BLE_GAP_CHAR_INCL_CONFIG. Default is @ref BLE_GAP_CAR_INCL_CONFIG_DEFAULT."]
    pub include_cfg: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_cfg_car_incl_cfg_t"][::core::mem::size_of::<ble_gap_cfg_car_incl_cfg_t>() - 1usize];
    ["Alignment of ble_gap_cfg_car_incl_cfg_t"][::core::mem::align_of::<ble_gap_cfg_car_incl_cfg_t>() - 1usize];
    ["Offset of field: ble_gap_cfg_car_incl_cfg_t::include_cfg"]
        [::core::mem::offset_of!(ble_gap_cfg_car_incl_cfg_t, include_cfg) - 0usize];
};
#[doc = "@brief Configuration structure for GAP configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_cfg_t {
    #[doc = "< Role count configuration, cfg_id is @ref BLE_GAP_CFG_ROLE_COUNT."]
    pub role_count_cfg: ble_gap_cfg_role_count_t,
    #[doc = "< Device name configuration, cfg_id is @ref BLE_GAP_CFG_DEVICE_NAME."]
    pub device_name_cfg: ble_gap_cfg_device_name_t,
    #[doc = "< Peripheral Preferred Connection Parameters characteristic include\nconfiguration, cfg_id is @ref BLE_GAP_CFG_PPCP_INCL_CONFIG."]
    pub ppcp_include_cfg: ble_gap_cfg_ppcp_incl_cfg_t,
    #[doc = "< Central Address Resolution characteristic include configuration,\ncfg_id is @ref BLE_GAP_CFG_CAR_INCL_CONFIG."]
    pub car_include_cfg: ble_gap_cfg_car_incl_cfg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_cfg_t"][::core::mem::size_of::<ble_gap_cfg_t>() - 12usize];
    ["Alignment of ble_gap_cfg_t"][::core::mem::align_of::<ble_gap_cfg_t>() - 4usize];
    ["Offset of field: ble_gap_cfg_t::role_count_cfg"][::core::mem::offset_of!(ble_gap_cfg_t, role_count_cfg) - 0usize];
    ["Offset of field: ble_gap_cfg_t::device_name_cfg"]
        [::core::mem::offset_of!(ble_gap_cfg_t, device_name_cfg) - 0usize];
    ["Offset of field: ble_gap_cfg_t::ppcp_include_cfg"]
        [::core::mem::offset_of!(ble_gap_cfg_t, ppcp_include_cfg) - 0usize];
    ["Offset of field: ble_gap_cfg_t::car_include_cfg"]
        [::core::mem::offset_of!(ble_gap_cfg_t, car_include_cfg) - 0usize];
};
#[doc = "@brief Channel Map option.\n\n @details Used with @ref sd_ble_opt_get to get the current channel map\n          or @ref sd_ble_opt_set to set a new channel map. When setting the\n          channel map, it applies to all current and future connections. When getting the\n          current channel map, it applies to a single connection and the connection handle\n          must be supplied.\n\n @note Setting the channel map may take some time, depending on connection parameters.\n       The time taken may be different for each connection and the get operation will\n       return the previous channel map until the new one has taken effect.\n\n @note After setting the channel map, by spec it can not be set again until at least 1 s has passed.\n       See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.\n\n @retval ::NRF_SUCCESS Get or set successful.\n @retval ::NRF_ERROR_INVALID_PARAM One or more of the following is true:\n                                   - Less then two bits in @ref ch_map are set.\n                                   - Bits for primary advertising channels (37-39) are set.\n @retval ::NRF_ERROR_BUSY Channel map was set again before enough time had passed.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_ch_map_t {
    #[doc = "< Connection Handle (only applicable for get)"]
    pub conn_handle: u16,
    #[doc = "< Channel Map (37-bit)."]
    pub ch_map: [u8; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_ch_map_t"][::core::mem::size_of::<ble_gap_opt_ch_map_t>() - 8usize];
    ["Alignment of ble_gap_opt_ch_map_t"][::core::mem::align_of::<ble_gap_opt_ch_map_t>() - 2usize];
    ["Offset of field: ble_gap_opt_ch_map_t::conn_handle"]
        [::core::mem::offset_of!(ble_gap_opt_ch_map_t, conn_handle) - 0usize];
    ["Offset of field: ble_gap_opt_ch_map_t::ch_map"][::core::mem::offset_of!(ble_gap_opt_ch_map_t, ch_map) - 2usize];
};
#[doc = "@brief Local connection latency option.\n\n @details Local connection latency is a feature which enables the slave to improve\n          current consumption by ignoring the slave latency set by the peer. The\n          local connection latency can only be set to a multiple of the slave latency,\n          and cannot be longer than half of the supervision timeout.\n\n @details Used with @ref sd_ble_opt_set to set the local connection latency. The\n          @ref sd_ble_opt_get is not supported for this option, but the actual\n          local connection latency (unless set to NULL) is set as a return parameter\n          when setting the option.\n\n @note The latency set will be truncated down to the closest slave latency event\n       multiple, or the nearest multiple before half of the supervision timeout.\n\n @note The local connection latency is disabled by default, and needs to be enabled for new\n       connections and whenever the connection is updated.\n\n @retval ::NRF_SUCCESS Set successfully.\n @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_local_conn_latency_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    #[doc = "< Requested local connection latency."]
    pub requested_latency: u16,
    #[doc = "< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value)."]
    pub p_actual_latency: *mut u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_local_conn_latency_t"][::core::mem::size_of::<ble_gap_opt_local_conn_latency_t>() - 8usize];
    ["Alignment of ble_gap_opt_local_conn_latency_t"]
        [::core::mem::align_of::<ble_gap_opt_local_conn_latency_t>() - 4usize];
    ["Offset of field: ble_gap_opt_local_conn_latency_t::conn_handle"]
        [::core::mem::offset_of!(ble_gap_opt_local_conn_latency_t, conn_handle) - 0usize];
    ["Offset of field: ble_gap_opt_local_conn_latency_t::requested_latency"]
        [::core::mem::offset_of!(ble_gap_opt_local_conn_latency_t, requested_latency) - 2usize];
    ["Offset of field: ble_gap_opt_local_conn_latency_t::p_actual_latency"]
        [::core::mem::offset_of!(ble_gap_opt_local_conn_latency_t, p_actual_latency) - 4usize];
};
#[doc = "@brief Disable slave latency\n\n @details Used with @ref sd_ble_opt_set to temporarily disable slave latency of a peripheral connection\n          (see @ref ble_gap_conn_params_t::slave_latency). And to re-enable it again. When disabled, the\n          peripheral will ignore the slave_latency set by the central.\n\n @note  Shall only be called on peripheral links.\n\n @retval ::NRF_SUCCESS Set successfully.\n @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_slave_latency_disable_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_slave_latency_disable_t"]
        [::core::mem::size_of::<ble_gap_opt_slave_latency_disable_t>() - 4usize];
    ["Alignment of ble_gap_opt_slave_latency_disable_t"]
        [::core::mem::align_of::<ble_gap_opt_slave_latency_disable_t>() - 2usize];
    ["Offset of field: ble_gap_opt_slave_latency_disable_t::conn_handle"]
        [::core::mem::offset_of!(ble_gap_opt_slave_latency_disable_t, conn_handle) - 0usize];
};
impl ble_gap_opt_slave_latency_disable_t {
    #[inline]
    pub fn disable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_disable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(disable: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable: u8 = unsafe { ::core::mem::transmute(disable) };
            disable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Passkey Option.\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}\n @endmscs\n\n @details Structure containing the passkey to be used during pairing. This can be used with @ref\n          sd_ble_opt_set to make the SoftDevice use a preprogrammed passkey for authentication\n          instead of generating a random one.\n\n @note Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks.\n\n @note @ref sd_ble_opt_get is not supported for this option.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_passkey_t {
    #[doc = "< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required."]
    pub p_passkey: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_passkey_t"][::core::mem::size_of::<ble_gap_opt_passkey_t>() - 4usize];
    ["Alignment of ble_gap_opt_passkey_t"][::core::mem::align_of::<ble_gap_opt_passkey_t>() - 4usize];
    ["Offset of field: ble_gap_opt_passkey_t::p_passkey"]
        [::core::mem::offset_of!(ble_gap_opt_passkey_t, p_passkey) - 0usize];
};
#[doc = "@brief Compatibility mode 1 option.\n\n @details This can be used with @ref sd_ble_opt_set to enable and disable\n          compatibility mode 1. Compatibility mode 1 is disabled by default.\n\n @note Compatibility mode 1 enables interoperability with devices that do not support a value of\n       0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a\n       limited set of legacy peripheral devices from another vendor. Enabling this compatibility\n       mode will only have an effect if the local device will act as a central device and\n       initiate a connection to a peripheral device. In that case it may lead to the connection\n       creation taking up to one connection interval longer to complete for all connections.\n\n  @retval ::NRF_SUCCESS Set successfully.\n  @retval ::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_compat_mode_1_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_compat_mode_1_t"][::core::mem::size_of::<ble_gap_opt_compat_mode_1_t>() - 1usize];
    ["Alignment of ble_gap_opt_compat_mode_1_t"][::core::mem::align_of::<ble_gap_opt_compat_mode_1_t>() - 1usize];
};
impl ble_gap_opt_compat_mode_1_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Authenticated payload timeout option.\n\n @details This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other\n          than the default of @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX.\n\n @note The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated\n       if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted\n       link.\n\n @note The LE ping procedure will be initiated before the timer expires to give the peer a chance\n       to reset the timer. In addition the stack will try to prioritize running of LE ping over other\n       activities to increase chances of finishing LE ping before timer expires. To avoid side-effects\n       on other activities, it is recommended to use high timeout values.\n       Recommended timeout > 2*(connInterval * (6 + connSlaveLatency)).\n\n @retval ::NRF_SUCCESS Set successfully.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_opt_auth_payload_timeout_t {
    #[doc = "< Connection Handle"]
    pub conn_handle: u16,
    #[doc = "< Requested timeout in 10 ms unit, see @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT."]
    pub auth_payload_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_auth_payload_timeout_t"]
        [::core::mem::size_of::<ble_gap_opt_auth_payload_timeout_t>() - 4usize];
    ["Alignment of ble_gap_opt_auth_payload_timeout_t"]
        [::core::mem::align_of::<ble_gap_opt_auth_payload_timeout_t>() - 2usize];
    ["Offset of field: ble_gap_opt_auth_payload_timeout_t::conn_handle"]
        [::core::mem::offset_of!(ble_gap_opt_auth_payload_timeout_t, conn_handle) - 0usize];
    ["Offset of field: ble_gap_opt_auth_payload_timeout_t::auth_payload_timeout"]
        [::core::mem::offset_of!(ble_gap_opt_auth_payload_timeout_t, auth_payload_timeout) - 2usize];
};
#[doc = "@brief Option structure for GAP options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_opt_t {
    #[doc = "< Parameters for the Channel Map option."]
    pub ch_map: ble_gap_opt_ch_map_t,
    #[doc = "< Parameters for the Local connection latency option"]
    pub local_conn_latency: ble_gap_opt_local_conn_latency_t,
    #[doc = "< Parameters for the Passkey option."]
    pub passkey: ble_gap_opt_passkey_t,
    #[doc = "< Parameters for the compatibility mode 1 option."]
    pub compat_mode_1: ble_gap_opt_compat_mode_1_t,
    #[doc = "< Parameters for the authenticated payload timeout option."]
    pub auth_payload_timeout: ble_gap_opt_auth_payload_timeout_t,
    #[doc = "< Parameters for the Disable slave latency option"]
    pub slave_latency_disable: ble_gap_opt_slave_latency_disable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_opt_t"][::core::mem::size_of::<ble_gap_opt_t>() - 8usize];
    ["Alignment of ble_gap_opt_t"][::core::mem::align_of::<ble_gap_opt_t>() - 4usize];
    ["Offset of field: ble_gap_opt_t::ch_map"][::core::mem::offset_of!(ble_gap_opt_t, ch_map) - 0usize];
    ["Offset of field: ble_gap_opt_t::local_conn_latency"]
        [::core::mem::offset_of!(ble_gap_opt_t, local_conn_latency) - 0usize];
    ["Offset of field: ble_gap_opt_t::passkey"][::core::mem::offset_of!(ble_gap_opt_t, passkey) - 0usize];
    ["Offset of field: ble_gap_opt_t::compat_mode_1"][::core::mem::offset_of!(ble_gap_opt_t, compat_mode_1) - 0usize];
    ["Offset of field: ble_gap_opt_t::auth_payload_timeout"]
        [::core::mem::offset_of!(ble_gap_opt_t, auth_payload_timeout) - 0usize];
    ["Offset of field: ble_gap_opt_t::slave_latency_disable"]
        [::core::mem::offset_of!(ble_gap_opt_t, slave_latency_disable) - 0usize];
};
#[doc = "@brief  Connection event triggering parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_event_trigger_t {
    #[doc = "< PPI channel to use. This channel should be regarded as reserved until\nconnection event PPI task triggering is stopped.\nThe PPI channel ID can not be one of the PPI channels reserved by\nthe SoftDevice. See @ref NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK."]
    pub ppi_ch_id: u8,
    #[doc = "< Task Endpoint to trigger."]
    pub task_endpoint: u32,
    #[doc = "< The connection event on which the task triggering should start."]
    pub conn_evt_counter_start: u16,
    #[doc = "< Trigger period. Valid range is [1, 32767].\nIf the device is in slave role and slave latency is enabled,\nthis parameter should be set to a multiple of (slave latency + 1)\nto ensure low power operation."]
    pub period_in_events: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gap_conn_event_trigger_t"][::core::mem::size_of::<ble_gap_conn_event_trigger_t>() - 12usize];
    ["Alignment of ble_gap_conn_event_trigger_t"][::core::mem::align_of::<ble_gap_conn_event_trigger_t>() - 4usize];
    ["Offset of field: ble_gap_conn_event_trigger_t::ppi_ch_id"]
        [::core::mem::offset_of!(ble_gap_conn_event_trigger_t, ppi_ch_id) - 0usize];
    ["Offset of field: ble_gap_conn_event_trigger_t::task_endpoint"]
        [::core::mem::offset_of!(ble_gap_conn_event_trigger_t, task_endpoint) - 4usize];
    ["Offset of field: ble_gap_conn_event_trigger_t::conn_evt_counter_start"]
        [::core::mem::offset_of!(ble_gap_conn_event_trigger_t, conn_evt_counter_start) - 8usize];
    ["Offset of field: ble_gap_conn_event_trigger_t::period_in_events"]
        [::core::mem::offset_of!(ble_gap_conn_event_trigger_t, period_in_events) - 10usize];
};

#[doc = "@brief Set the local Bluetooth identity address.\n\n        The local Bluetooth identity address is the address that identifies this device to other peers.\n        The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.\n\n @note  The identity address cannot be changed while advertising, scanning or creating a connection.\n\n @note  This address will be distributed to the peer during bonding.\n        If the address changes, the address stored in the peer device will not be valid and the ability to\n        reconnect using the old address will be lost.\n\n @note  By default the SoftDevice will set an address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC upon being\n        enabled. The address is a random number populated during the IC manufacturing process and remains unchanged\n        for the lifetime of each IC.\n\n @mscs\n @mmsc{@ref BLE_GAP_ADV_MSC}\n @endmscs\n\n @param[in] p_addr Pointer to address structure.\n\n @retval ::NRF_SUCCESS Address successfully set.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.\n @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.\n @retval ::NRF_ERROR_INVALID_STATE The identity address cannot be changed while advertising,\n                                   scanning or creating a connection."]
#[inline(always)]
pub unsafe fn sd_ble_gap_addr_set(p_addr: *const ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 108",
        inout("r0") to_asm(p_addr) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get local Bluetooth identity address.\n\n @note  This will always return the identity address irrespective of the privacy settings,\n        i.e. the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.\n\n @param[out] p_addr Pointer to address structure to be filled in.\n\n @retval ::NRF_SUCCESS Address successfully retrieved.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid or NULL pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_addr_get(p_addr: *mut ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 109",
        inout("r0") to_asm(p_addr) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the Bluetooth device address used by the advertiser.\n\n @note  This function will return the local Bluetooth address used in advertising PDUs. When\n        using privacy, the SoftDevice will generate a new private address every\n        @ref ble_gap_privacy_params_t::private_addr_cycle_s configured using\n        @ref sd_ble_gap_privacy_set. Hence depending on when the application calls this API, the\n        address returned may not be the latest address that is used in the advertising PDUs.\n\n @param[in]  adv_handle The advertising handle to get the address from.\n @param[out] p_addr     Pointer to address structure to be filled in.\n\n @retval ::NRF_SUCCESS                  Address successfully retrieved.\n @retval ::NRF_ERROR_INVALID_ADDR       Invalid or NULL pointer supplied.\n @retval ::BLE_ERROR_INVALID_ADV_HANDLE The provided advertising handle was not found.\n @retval ::NRF_ERROR_INVALID_STATE      The advertising set is currently not advertising."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_addr_get(adv_handle: u8, p_addr: *mut ble_gap_addr_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 147",
        inout("r0") to_asm(adv_handle) => ret,
        inout("r1") to_asm(p_addr) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the active whitelist in the SoftDevice.\n\n @note  Only one whitelist can be used at a time and the whitelist is shared between the BLE roles.\n        The whitelist cannot be set if a BLE role is using the whitelist.\n\n @note  If an address is resolved using the information in the device identity list, then the whitelist\n        filter policy applies to the peer identity address and not the resolvable address sent on air.\n\n @mscs\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}\n @endmscs\n\n @param[in] pp_wl_addrs Pointer to a whitelist of peer addresses, if NULL the whitelist will be cleared.\n @param[in] len         Length of the whitelist, maximum @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT.\n\n @retval ::NRF_SUCCESS The whitelist is successfully set/cleared.\n @retval ::NRF_ERROR_INVALID_ADDR The whitelist (or one of its entries) provided is invalid.\n @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE The whitelist is in use by a BLE role and cannot be set or cleared.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.\n @retval ::NRF_ERROR_DATA_SIZE The given whitelist size is invalid (zero or too large); this can only return when\n                               pp_wl_addrs is not NULL."]
#[inline(always)]
pub unsafe fn sd_ble_gap_whitelist_set(pp_wl_addrs: *const *const ble_gap_addr_t, len: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 110",
        inout("r0") to_asm(pp_wl_addrs) => ret,
        inout("r1") to_asm(len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set device identity list.\n\n @note  Only one device identity list can be used at a time and the list is shared between the BLE roles.\n        The device identity list cannot be set if a BLE role is using the list.\n\n @param[in] pp_id_keys     Pointer to an array of peer identity addresses and peer IRKs, if NULL the device identity list will be cleared.\n @param[in] pp_local_irks  Pointer to an array of local IRKs. Each entry in the array maps to the entry in pp_id_keys at the same index.\n                           To fill in the list with the currently set device IRK for all peers, set to NULL.\n @param[in] len            Length of the device identity list, maximum @ref BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT.\n\n @mscs\n @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS The device identity list successfully set/cleared.\n @retval ::NRF_ERROR_INVALID_ADDR The device identity list (or one of its entries) provided is invalid.\n                                  This code may be returned if the local IRK list also has an invalid entry.\n @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE The device identity list is in use and cannot be set or cleared.\n @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE The device identity list contains multiple entries with the same identity address.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.\n @retval ::NRF_ERROR_DATA_SIZE The given device identity list size invalid (zero or too large); this can\n                               only return when pp_id_keys is not NULL."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_identities_set(
    pp_id_keys: *const *const ble_gap_id_key_t,
    pp_local_irks: *const *const ble_gap_irk_t,
    len: u8,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 111",
        inout("r0") to_asm(pp_id_keys) => ret,
        inout("r1") to_asm(pp_local_irks) => _,
        inout("r2") to_asm(len) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set privacy settings.\n\n @note  Privacy settings cannot be changed while advertising, scanning or creating a connection.\n\n @param[in] p_privacy_params Privacy settings.\n\n @mscs\n @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Set successfully.\n @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.\n @retval ::NRF_ERROR_INVALID_ADDR The pointer to privacy settings is NULL or invalid.\n                                  Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.\n @retval ::NRF_ERROR_INVALID_PARAM Out of range parameters are provided.\n @retval ::NRF_ERROR_NOT_SUPPORTED The SoftDevice does not support privacy if the Central Address Resolution\ncharacteristic is not configured to be included and the SoftDevice is configured\nto support central roles.\nSee @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t.\n @retval ::NRF_ERROR_INVALID_STATE Privacy settings cannot be changed while advertising, scanning\n                                   or creating a connection."]
#[inline(always)]
pub unsafe fn sd_ble_gap_privacy_set(p_privacy_params: *const ble_gap_privacy_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 112",
        inout("r0") to_asm(p_privacy_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get privacy settings.\n\n @note ::ble_gap_privacy_params_t::p_device_irk must be initialized to NULL or a valid address before this function is called.\n       If it is initialized to a valid address, the address pointed to will contain the current device IRK on return.\n\n @param[in,out] p_privacy_params Privacy settings.\n\n @retval ::NRF_SUCCESS            Privacy settings read.\n @retval ::NRF_ERROR_INVALID_ADDR The pointer given for returning the privacy settings may be NULL or invalid.\n                                  Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer."]
#[inline(always)]
pub unsafe fn sd_ble_gap_privacy_get(p_privacy_params: *mut ble_gap_privacy_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 113",
        inout("r0") to_asm(p_privacy_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Configure an advertising set. Set, clear or update advertising and scan response data.\n\n @note  The format of the advertising data will be checked by this call to ensure interoperability.\n        Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and\n        duplicating the local name in the advertising data and scan response data.\n\n @note In order to update advertising data while advertising, new advertising buffers must be provided.\n\n @mscs\n @mmsc{@ref BLE_GAP_ADV_MSC}\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @endmscs\n\n @param[in,out] p_adv_handle                         Provide a pointer to a handle containing @ref BLE_GAP_ADV_SET_HANDLE_NOT_SET to configure\n                                                     a new advertising set. On success, a new handle is then returned through the pointer.\n                                                     Provide a pointer to an existing advertising handle to configure an existing advertising set.\n @param[in]     p_adv_data                           Advertising data. If set to NULL, no advertising data will be used. See @ref ble_gap_adv_data_t.\n @param[in]     p_adv_params                         Advertising parameters. When this function is used to update advertising data while advertising,\n                                                     this parameter must be NULL. See @ref ble_gap_adv_params_t.\n\n @retval ::NRF_SUCCESS                               Advertising set successfully configured.\n @retval ::NRF_ERROR_INVALID_PARAM                   Invalid parameter(s) supplied:\n                                                      - Invalid advertising data configuration specified. See @ref ble_gap_adv_data_t.\n                                                      - Invalid configuration of p_adv_params. See @ref ble_gap_adv_params_t.\n                                                      - Use of whitelist requested but whitelist has not been set,\n                                                        see @ref sd_ble_gap_whitelist_set.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR            ble_gap_adv_params_t::p_peer_addr is invalid.\n @retval ::NRF_ERROR_INVALID_STATE                   Invalid state to perform operation. Either:\n                                                     - It is invalid to provide non-NULL advertising set parameters while advertising.\n                                                     - It is invalid to provide the same data buffers while advertising. To update\n                                                       advertising data, provide new advertising buffers.\n @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.\n @retval ::BLE_ERROR_INVALID_ADV_HANDLE              The provided advertising handle was not found. Use @ref BLE_GAP_ADV_SET_HANDLE_NOT_SET to\n                                                     configure a new advertising handle.\n @retval ::NRF_ERROR_INVALID_ADDR                    Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_FLAGS                   Invalid combination of advertising flags supplied.\n @retval ::NRF_ERROR_INVALID_DATA                    Invalid data type(s) supplied. Check the advertising data format specification\n                                                     given in Bluetooth Specification Version 5.0, Volume 3, Part C, Chapter 11.\n @retval ::NRF_ERROR_INVALID_LENGTH                  Invalid data length(s) supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED                   Unsupported data length or advertising parameter configuration.\n @retval ::NRF_ERROR_NO_MEM                          Not enough memory to configure a new advertising handle. Update an\n                                                     existing advertising handle instead.\n @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_set_configure(
    p_adv_handle: *mut u8,
    p_adv_data: *const ble_gap_adv_data_t,
    p_adv_params: *const ble_gap_adv_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 114",
        inout("r0") to_asm(p_adv_handle) => ret,
        inout("r1") to_asm(p_adv_data) => _,
        inout("r2") to_asm(p_adv_params) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).\n\n @note Only one advertiser may be active at any time.\n\n @events\n @event{@ref BLE_GAP_EVT_CONNECTED, Generated after connection has been established through connectable advertising.}\n @event{@ref BLE_GAP_EVT_ADV_SET_TERMINATED, Advertising set has terminated.}\n @event{@ref BLE_GAP_EVT_SCAN_REQ_REPORT, A scan request was received.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_ADV_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}\n @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @endmscs\n\n @param[in] adv_handle   Advertising handle to advertise on, received from @ref sd_ble_gap_adv_set_configure.\n @param[in] conn_cfg_tag Tag identifying a configuration set by @ref sd_ble_cfg_set or\n                         @ref BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration. For non-connectable\n                         advertising, this is ignored.\n\n @retval ::NRF_SUCCESS                  The BLE stack has started advertising.\n @retval ::NRF_ERROR_INVALID_STATE      adv_handle is not configured or already advertising.\n @retval ::NRF_ERROR_CONN_COUNT         The limit of available connections for this connection configuration\n                                        tag has been reached; connectable advertiser cannot be started.\n                                        To increase the number of available connections,\n                                        use @ref sd_ble_cfg_set with @ref BLE_GAP_CFG_ROLE_COUNT or @ref BLE_CONN_CFG_GAP.\n @retval ::BLE_ERROR_INVALID_ADV_HANDLE Advertising handle not found. Configure a new adveriting handle with @ref sd_ble_gap_adv_set_configure.\n @retval ::NRF_ERROR_NOT_FOUND          conn_cfg_tag not found.\n @retval ::NRF_ERROR_INVALID_PARAM      Invalid parameter(s) supplied:\n                                        - Invalid configuration of p_adv_params. See @ref ble_gap_adv_params_t.\n                                        - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.\n @retval ::NRF_ERROR_RESOURCES          Either:\n                                        - adv_handle is configured with connectable advertising, but the event_length parameter\n                                          associated with conn_cfg_tag is too small to be able to establish a connection on\n                                          the selected advertising phys. Use @ref sd_ble_cfg_set to increase the event length.\n                                        - Not enough BLE role slots available.\nStop one or more currently active roles (Central, Peripheral, Broadcaster or Observer) and try again.\n                                        - p_adv_params is configured with connectable advertising, but the event_length parameter\n                                          associated with conn_cfg_tag is too small to be able to establish a connection on\n                                          the selected advertising phys. Use @ref sd_ble_cfg_set to increase the event length."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_start(adv_handle: u8, conn_cfg_tag: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 115",
        inout("r0") to_asm(adv_handle) => ret,
        inout("r1") to_asm(conn_cfg_tag) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).\n\n @mscs\n @mmsc{@ref BLE_GAP_ADV_MSC}\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @endmscs\n\n @param[in] adv_handle The advertising handle that should stop advertising.\n\n @retval ::NRF_SUCCESS The BLE stack has stopped advertising.\n @retval ::BLE_ERROR_INVALID_ADV_HANDLE Invalid advertising handle.\n @retval ::NRF_ERROR_INVALID_STATE The advertising handle is not advertising."]
#[inline(always)]
pub unsafe fn sd_ble_gap_adv_stop(adv_handle: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 116",
        inout("r0") to_asm(adv_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Update connection parameters.\n\n @details In the central role this will initiate a Link Layer connection parameter update procedure,\n          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for\n          the central to perform the procedure. In both cases, and regardless of success or failure, the application\n          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.\n\n @details This function can be used as a central both to reply to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST or to start the procedure unrequested.\n\n @events\n @event{@ref BLE_GAP_EVT_CONN_PARAM_UPDATE, Result of the connection parameter update procedure.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_CPU_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}\n @mmsc{@ref BLE_GAP_MULTILINK_CPU_MSC}\n @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_CPU_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,\n                           the parameters in the PPCP characteristic of the GAP service will be used instead.\n                           If NULL is provided on a central role and in response to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST, the peripheral request will be rejected\n\n @retval ::NRF_SUCCESS The Connection Update procedure has been started successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.\n @retval ::NRF_ERROR_INVALID_STATE Disconnection in progress or link has not been established.\n @retval ::NRF_ERROR_BUSY Procedure already in progress, wait for pending procedures to complete and retry.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_param_update(conn_handle: u16, p_conn_params: *const ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 117",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_conn_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Disconnect (GAP Link Termination).\n\n @details This call initiates the disconnection procedure, and its completion will be communicated to the application\n          with a @ref BLE_GAP_EVT_DISCONNECTED event.\n\n @events\n @event{@ref BLE_GAP_EVT_DISCONNECTED, Generated when disconnection procedure is complete.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_CONN_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES (accepted values are @ref BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION and @ref BLE_HCI_CONN_INTERVAL_UNACCEPTABLE).\n\n @retval ::NRF_SUCCESS The disconnection procedure has been started successfully.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_INVALID_STATE Disconnection in progress or link has not been established."]
#[inline(always)]
pub unsafe fn sd_ble_gap_disconnect(conn_handle: u16, hci_status_code: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 118",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(hci_status_code) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the radio's transmit power.\n\n @param[in] role The role to set the transmit power for, see @ref BLE_GAP_TX_POWER_ROLES for\n                 possible roles.\n @param[in] handle   The handle parameter is interpreted depending on role:\n                     - If role is @ref BLE_GAP_TX_POWER_ROLE_CONN, this value is the specific connection handle.\n                     - If role is @ref BLE_GAP_TX_POWER_ROLE_ADV, the advertising set identified with the advertising handle,\n                       will use the specified transmit power, and include it in the advertising packet headers if\n                       @ref ble_gap_adv_properties_t::include_tx_power set.\n                     - For all other roles handle is ignored.\n @param[in] tx_power Radio transmit power in dBm (see note for accepted values).\n\n @note Supported tx_power values: -40dBm, -20dBm, -16dBm, -12dBm, -8dBm, -4dBm, 0dBm, +2dBm, +3dBm, +4dBm, +5dBm, +6dBm, +7dBm and +8dBm.\n @note The initiator will have the same transmit power as the scanner.\n @note When a connection is created it will inherit the transmit power from the initiator or\n       advertiser leading to the connection.\n\n @retval ::NRF_SUCCESS Successfully changed the transmit power.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::BLE_ERROR_INVALID_ADV_HANDLE Advertising handle not found.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_tx_power_set(role: u8, handle: u16, tx_power: i8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 119",
        inout("r0") to_asm(role) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(tx_power) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP Appearance value.\n\n @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.\n\n @retval ::NRF_SUCCESS  Appearance value set successfully.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_appearance_set(appearance: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 120",
        inout("r0") to_asm(appearance) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP Appearance value.\n\n @param[out] p_appearance Pointer to appearance (16-bit) to be filled in, see @ref BLE_APPEARANCES.\n\n @retval ::NRF_SUCCESS Appearance value retrieved successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_appearance_get(p_appearance: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 121",
        inout("r0") to_asm(p_appearance) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP Peripheral Preferred Connection Parameters.\n\n @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.\n\n @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED The characteristic is not included in the Attribute Table,\nsee @ref ble_gap_cfg_ppcp_incl_cfg_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_ppcp_set(p_conn_params: *const ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 122",
        inout("r0") to_asm(p_conn_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP Peripheral Preferred Connection Parameters.\n\n @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.\n\n @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED The characteristic is not included in the Attribute Table,\nsee @ref ble_gap_cfg_ppcp_incl_cfg_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_ppcp_get(p_conn_params: *mut ble_gap_conn_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 123",
        inout("r0") to_asm(p_conn_params) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set GAP device name.\n\n @note  If the device name is located in application flash memory (see @ref ble_gap_cfg_device_name_t),\n        it cannot be changed. Then @ref NRF_ERROR_FORBIDDEN will be returned.\n\n @param[in] p_write_perm Write permissions for the Device Name characteristic, see @ref ble_gap_conn_sec_mode_t.\n @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.\n @param[in] len Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).\n\n @retval ::NRF_SUCCESS GAP device name and permissions set successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.\n @retval ::NRF_ERROR_FORBIDDEN Device name is not writable."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_name_set(
    p_write_perm: *const ble_gap_conn_sec_mode_t,
    p_dev_name: *const u8,
    len: u16,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 124",
        inout("r0") to_asm(p_write_perm) => ret,
        inout("r1") to_asm(p_dev_name) => _,
        inout("r2") to_asm(len) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get GAP device name.\n\n @note  If the device name is longer than the size of the supplied buffer,\n        p_len will return the complete device name length,\n        and not the number of bytes actually returned in p_dev_name.\n        The application may use this information to allocate a suitable buffer size.\n\n @param[out]    p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed. Set to NULL to obtain the complete device name length.\n @param[in,out] p_len      Length of the buffer pointed by p_dev_name, complete device name length on output.\n\n @retval ::NRF_SUCCESS GAP device name retrieved successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_device_name_get(p_dev_name: *mut u8, p_len: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 125",
        inout("r0") to_asm(p_dev_name) => ret,
        inout("r1") to_asm(p_len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate the GAP Authentication procedure.\n\n @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),\n          otherwise in the peripheral role, an SMP Security Request will be sent.\n\n @events\n @event{Depending on the security parameters set and the packet exchanges with the peer\\, the following events may be generated:}\n @event{@ref BLE_GAP_EVT_SEC_PARAMS_REQUEST}\n @event{@ref BLE_GAP_EVT_SEC_INFO_REQUEST}\n @event{@ref BLE_GAP_EVT_PASSKEY_DISPLAY}\n @event{@ref BLE_GAP_EVT_KEY_PRESSED}\n @event{@ref BLE_GAP_EVT_AUTH_KEY_REQUEST}\n @event{@ref BLE_GAP_EVT_LESC_DHKEY_REQUEST}\n @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE}\n @event{@ref BLE_GAP_EVT_AUTH_STATUS}\n @event{@ref BLE_GAP_EVT_TIMEOUT}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_SEC_REQ_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure.\n                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used.\n                         In the central role, this pointer may be NULL to reject a Security Request.\n\n @retval ::NRF_SUCCESS Successfully initiated authentication procedure.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - No link has been established.\n                                   - An encryption is already executing or queued.\n @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.\n                                   Distribution of own Identity Information is only supported if the Central\n                                   Address Resolution characteristic is configured to be included or\n                                   the Softdevice is configured to support peripheral roles only.\n                                   See @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t.\n @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited."]
#[inline(always)]
pub unsafe fn sd_ble_gap_authenticate(conn_handle: u16, p_sec_params: *const ble_gap_sec_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 126",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sec_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with GAP security parameters.\n\n @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.\n @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.\n\n @events\n @event{This function is used during authentication procedures, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_JW_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_PERIPH_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_CONFIRM_FAIL_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_KS_TOO_SMALL_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_APP_ERROR_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_REMOTE_PAIRING_FAIL_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_PAIRING_TIMEOUT_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.\n @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure. In the central role this must be set to NULL, as the parameters have\n                         already been provided during a previous call to @ref sd_ble_gap_authenticate.\n @param[in,out] p_sec_keyset Pointer to a @ref ble_gap_sec_keyset_t security keyset structure. Any keys generated and/or distributed as a result of the ongoing security procedure\n                         will be stored into the memory referenced by the pointers inside this structure. The keys will be stored and available to the application\n                         upon reception of a @ref BLE_GAP_EVT_AUTH_STATUS event.\n                         Note that the SoftDevice expects the application to provide memory for storing the\n                         peer's keys. So it must be ensured that the relevant pointers inside this structure are not NULL. The pointers to the local key\n                         can, however, be NULL, in which case, the local key data will not be available to the application upon reception of the\n                         @ref BLE_GAP_EVT_AUTH_STATUS event.\n\n @retval ::NRF_SUCCESS Successfully accepted security parameter from the application.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Security parameters has not been requested.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.\n                                   Distribution of own Identity Information is only supported if the Central\n                                   Address Resolution characteristic is configured to be included or\n                                   the Softdevice is configured to support peripheral roles only.\n                                   See @ref ble_gap_cfg_car_incl_cfg_t and @ref ble_gap_cfg_role_count_t."]
#[inline(always)]
pub unsafe fn sd_ble_gap_sec_params_reply(
    conn_handle: u16,
    sec_status: u8,
    p_sec_params: *const ble_gap_sec_params_t,
    p_sec_keyset: *const ble_gap_sec_keyset_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 127",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(sec_status) => _,
        inout("r2") to_asm(p_sec_params) => _,
        inout("r3") to_asm(p_sec_keyset) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with an authentication key.\n\n @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST or a @ref BLE_GAP_EVT_PASSKEY_DISPLAY, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.\n @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.\n\n @events\n @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.\n @param[in] p_key If key type is @ref BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.\n                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination)\n                     or NULL when confirming LE Secure Connections Numeric Comparison.\n                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in little-endian format.\n\n @retval ::NRF_SUCCESS Authentication key successfully set.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Authentication key has not been requested.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_auth_key_reply(conn_handle: u16, key_type: u8, p_key: *const u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 128",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(key_type) => _,
        inout("r2") to_asm(p_key) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with an LE Secure connections DHKey.\n\n @details This function is only used to reply to a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.\n @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.\n\n @events\n @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_dhkey LE Secure Connections DHKey.\n\n @retval ::NRF_SUCCESS DHKey successfully set.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - The peer is not authenticated.\n                                   - The application has not pulled a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_dhkey_reply(conn_handle: u16, p_dhkey: *const ble_gap_lesc_dhkey_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 129",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_dhkey) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Notify the peer of a local keypress.\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] kp_not See @ref BLE_GAP_KP_NOT_TYPES.\n\n @retval ::NRF_SUCCESS Keypress notification successfully queued for transmission.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - Authentication key not requested.\n                                   - Passkey has not been entered.\n                                   - Keypresses have not been enabled by both peers.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time."]
#[inline(always)]
pub unsafe fn sd_ble_gap_keypress_notify(conn_handle: u16, kp_not: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 130",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(kp_not) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Generate a set of OOB data to send to a peer out of band.\n\n @note  The @ref ble_gap_addr_t included in the OOB data returned will be the currently active one (or, if a connection has already been established,\n        the one used during connection setup). The application may manually overwrite it with an updated value.\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle. Can be @ref BLE_CONN_HANDLE_INVALID if a BLE connection has not been established yet.\n @param[in] p_pk_own LE Secure Connections local P-256 Public Key.\n @param[out] p_oobd_own The OOB data to be sent out of band to a peer.\n\n @retval ::NRF_SUCCESS OOB data successfully generated.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_oob_data_get(
    conn_handle: u16,
    p_pk_own: *const ble_gap_lesc_p256_pk_t,
    p_oobd_own: *mut ble_gap_lesc_oob_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 131",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_pk_own) => _,
        inout("r2") to_asm(p_oobd_own) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Provide the OOB data sent/received out of band.\n\n @note  An authentication procedure with OOB selected as an algorithm must be in progress when calling this function.\n @note  A @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event with the oobd_req set to 1 must have been received prior to calling this function.\n\n @events\n @event{This function is used during authentication procedures\\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_oobd_own The OOB data sent out of band to a peer or NULL if the peer has not received OOB data.\n                       Must correspond to @ref ble_gap_sec_params_t::oob flag in @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST.\n @param[in] p_oobd_peer The OOB data received out of band from a peer or NULL if none received.\n                        Must correspond to @ref ble_gap_sec_params_t::oob flag\n                        in @ref sd_ble_gap_authenticate in the central role or\n                        in @ref sd_ble_gap_sec_params_reply in the peripheral role.\n\n @retval ::NRF_SUCCESS OOB data accepted.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - Authentication key not requested\n                                   - Not expecting LESC OOB data\n                                   - Have not actually exchanged passkeys.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_lesc_oob_data_set(
    conn_handle: u16,
    p_oobd_own: *const ble_gap_lesc_oob_data_t,
    p_oobd_peer: *const ble_gap_lesc_oob_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 132",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_oobd_own) => _,
        inout("r2") to_asm(p_oobd_peer) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate GAP Encryption procedure.\n\n @details In the central role, this function will initiate the encryption procedure using the encryption information provided.\n\n @events\n @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE, The connection security has been updated.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_ENC_MSC}\n @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_master_id Pointer to a @ref ble_gap_master_id_t master identification structure.\n @param[in] p_enc_info  Pointer to a @ref ble_gap_enc_info_t encryption information structure.\n\n @retval ::NRF_SUCCESS Successfully initiated authentication procedure.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE No link has been established.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role.\n @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry."]
#[inline(always)]
pub unsafe fn sd_ble_gap_encrypt(
    conn_handle: u16,
    p_master_id: *const ble_gap_master_id_t,
    p_enc_info: *const ble_gap_enc_info_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 133",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_master_id) => _,
        inout("r2") to_asm(p_enc_info) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply with GAP security information.\n\n @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in @ref NRF_ERROR_INVALID_STATE.\n @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.\n @note    Data signing is not yet supported, and p_sign_info must therefore be NULL.\n\n @mscs\n @mmsc{@ref BLE_GAP_PERIPH_ENC_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.\n @param[in] p_id_info Pointer to a @ref ble_gap_irk_t identity information structure. May be NULL to signal none is available.\n @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.\n\n @retval ::NRF_SUCCESS Successfully accepted security information.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - No link has been established.\n                                   - No @ref BLE_GAP_EVT_SEC_REQUEST pending.\n                                   - Encryption information provided by the app without being requested. See @ref ble_gap_evt_sec_info_request_t::enc_info.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_sec_info_reply(
    conn_handle: u16,
    p_enc_info: *const ble_gap_enc_info_t,
    p_id_info: *const ble_gap_irk_t,
    p_sign_info: *const ble_gap_sign_info_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 134",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_enc_info) => _,
        inout("r2") to_asm(p_id_info) => _,
        inout("r3") to_asm(p_sign_info) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the current connection security.\n\n @param[in]  conn_handle Connection handle.\n @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.\n\n @retval ::NRF_SUCCESS Current connection security successfully retrieved.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_sec_get(conn_handle: u16, p_conn_sec: *mut ble_gap_conn_sec_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 135",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_conn_sec) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start reporting the received signal strength to the application.\n\n        A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.\n\n @events\n @event{@ref BLE_GAP_EVT_RSSI_CHANGED, New RSSI data available. How often the event is generated is\n                                       dependent on the settings of the <code>threshold_dbm</code>\n                                       and <code>skip_count</code> input parameters.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}\n @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}\n @endmscs\n\n @param[in] conn_handle        Connection handle.\n @param[in] threshold_dbm      Minimum change in dBm before triggering the @ref BLE_GAP_EVT_RSSI_CHANGED event. Events are disabled if threshold_dbm equals @ref BLE_GAP_RSSI_THRESHOLD_INVALID.\n @param[in] skip_count         Number of RSSI samples with a change of threshold_dbm or more before sending a new @ref BLE_GAP_EVT_RSSI_CHANGED event.\n\n @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting.\n @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is already ongoing.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_start(conn_handle: u16, threshold_dbm: u8, skip_count: u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 136",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(threshold_dbm) => _,
        inout("r2") to_asm(skip_count) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop reporting the received signal strength.\n\n @note  An RSSI change detected before the call but not yet received by the application\n        may be reported after @ref sd_ble_gap_rssi_stop has been called.\n\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}\n @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}\n @endmscs\n\n @param[in] conn_handle Connection handle.\n\n @retval ::NRF_SUCCESS                   Successfully deactivated RSSI reporting.\n @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_stop(conn_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 137",
        inout("r0") to_asm(conn_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the received signal strength for the last connection event.\n\n        @ref sd_ble_gap_rssi_start must be called to start reporting RSSI before using this function. @ref NRF_ERROR_NOT_FOUND\n        will be returned until RSSI was sampled for the first time after calling @ref sd_ble_gap_rssi_start.\n @note ERRATA-153 requires the rssi sample to be compensated based on a temperature measurement.\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}\n @endmscs\n\n @param[in]  conn_handle Connection handle.\n @param[out] p_rssi      Pointer to the location where the RSSI measurement shall be stored.\n @param[out] p_ch_index  Pointer to the location where Channel Index for the RSSI measurement shall be stored.\n\n @retval ::NRF_SUCCESS                   Successfully read the RSSI.\n @retval ::NRF_ERROR_NOT_FOUND           No sample is available.\n @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing."]
#[inline(always)]
pub unsafe fn sd_ble_gap_rssi_get(conn_handle: u16, p_rssi: *mut i8, p_ch_index: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 142",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_rssi) => _,
        inout("r2") to_asm(p_ch_index) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Start or continue scanning (GAP Discovery procedure, Observer Procedure).\n\n @note    A call to this function will require the application to keep the memory pointed by\n          p_adv_report_buffer alive until the buffer is released. The buffer is released when the scanner is stopped\n          or when this function is called with another buffer.\n\n @note    The scanner will automatically stop in the following cases:\n           - @ref sd_ble_gap_scan_stop is called.\n           - @ref sd_ble_gap_connect is called.\n           - A @ref BLE_GAP_EVT_TIMEOUT with source set to @ref BLE_GAP_TIMEOUT_SRC_SCAN is received.\n           - When a @ref BLE_GAP_EVT_ADV_REPORT event is received and @ref ble_gap_adv_report_type_t::status is not set to\n             @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA. In this case scanning is only paused to let the application\n             access received data. The application must call this function to continue scanning, or call @ref sd_ble_gap_scan_stop\n             to stop scanning.\n\n @note    If a @ref BLE_GAP_EVT_ADV_REPORT event is received with @ref ble_gap_adv_report_type_t::status set to\n          @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA, the scanner will continue scanning, and the application will\n          receive more reports from this advertising event. The following reports will include the old and new received data.\n\n @events\n @event{@ref BLE_GAP_EVT_ADV_REPORT, An advertising or scan response packet has been received.}\n @event{@ref BLE_GAP_EVT_TIMEOUT, Scanner has timed out.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_SCAN_MSC}\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @endmscs\n\n @param[in] p_scan_params       Pointer to scan parameters structure. When this function is used to continue\n                                scanning, this parameter must be NULL.\n @param[in] p_adv_report_buffer Pointer to buffer used to store incoming advertising data.\n                                The memory pointed to should be kept alive until the scanning is stopped.\n                                See @ref BLE_GAP_SCAN_BUFFER_SIZE for minimum and maximum buffer size.\n                                If the scanner receives advertising data larger than can be stored in the buffer,\n                                a @ref BLE_GAP_EVT_ADV_REPORT will be raised with @ref ble_gap_adv_report_type_t::status\n                                set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_TRUNCATED.\n\n @retval ::NRF_SUCCESS Successfully initiated scanning procedure.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either:\n                                   - Scanning is already ongoing and p_scan_params was not NULL\n                                   - Scanning is not running and p_scan_params was NULL.\n                                   - The scanner has timed out when this function is called to continue scanning.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. See @ref ble_gap_scan_params_t.\n @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported parameters supplied. See @ref ble_gap_scan_params_t.\n @retval ::NRF_ERROR_INVALID_LENGTH The provided buffer length is invalid. See @ref BLE_GAP_SCAN_BUFFER_MIN.\n @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.\n                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again"]
#[inline(always)]
pub unsafe fn sd_ble_gap_scan_start(
    p_scan_params: *const ble_gap_scan_params_t,
    p_adv_report_buffer: *const ble_data_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 138",
        inout("r0") to_asm(p_scan_params) => ret,
        inout("r1") to_asm(p_adv_report_buffer) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Stop scanning (GAP Discovery procedure, Observer Procedure).\n\n @note The buffer provided in @ref sd_ble_gap_scan_start is released.\n\n @mscs\n @mmsc{@ref BLE_GAP_SCAN_MSC}\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Successfully stopped scanning procedure.\n @retval ::NRF_ERROR_INVALID_STATE Not in the scanning state."]
#[inline(always)]
pub unsafe fn sd_ble_gap_scan_stop() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 139",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Create a connection (GAP Link Establishment).\n\n @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function.\n       The scanning procedure will be stopped even if the function returns an error.\n\n @events\n @event{@ref BLE_GAP_EVT_CONNECTED, A connection was established.}\n @event{@ref BLE_GAP_EVT_TIMEOUT, Failed to establish a connection.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_WL_SHARE_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}\n @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}\n @endmscs\n\n @param[in] p_peer_addr   Pointer to peer identity address. If @ref ble_gap_scan_params_t::filter_policy is set to use\n                          whitelist, then p_peer_addr is ignored.\n @param[in] p_scan_params Pointer to scan parameters structure.\n @param[in] p_conn_params Pointer to desired connection parameters.\n @param[in] conn_cfg_tag  Tag identifying a configuration set by @ref sd_ble_cfg_set or\n                          @ref BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration.\n\n @retval ::NRF_SUCCESS Successfully initiated connection procedure.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n                                   - Invalid parameter(s) in p_scan_params or p_conn_params.\n                                   - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.\n                                   - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set.\n @retval ::NRF_ERROR_NOT_FOUND conn_cfg_tag not found.\n @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an\n                                   existing locally initiated connect procedure, which must complete before initiating again.\n @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address.\n @retval ::NRF_ERROR_CONN_COUNT The limit of available connections for this connection configuration tag has been reached.\n                                To increase the number of available connections,\n                                use @ref sd_ble_cfg_set with @ref BLE_GAP_CFG_ROLE_COUNT or @ref BLE_CONN_CFG_GAP.\n @retval ::NRF_ERROR_RESOURCES Either:\n                                 - Not enough BLE role slots available.\n                                   Stop one or more currently active roles (Central, Peripheral or Observer) and try again.\n                                 - The event_length parameter associated with conn_cfg_tag is too small to be able to\n                                   establish a connection on the selected @ref ble_gap_scan_params_t::scan_phys.\n                                   Use @ref sd_ble_cfg_set to increase the event length."]
#[inline(always)]
pub unsafe fn sd_ble_gap_connect(
    p_peer_addr: *const ble_gap_addr_t,
    p_scan_params: *const ble_gap_scan_params_t,
    p_conn_params: *const ble_gap_conn_params_t,
    conn_cfg_tag: u8,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 140",
        inout("r0") to_asm(p_peer_addr) => ret,
        inout("r1") to_asm(p_scan_params) => _,
        inout("r2") to_asm(p_conn_params) => _,
        inout("r3") to_asm(conn_cfg_tag) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Cancel a connection establishment.\n\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Successfully canceled an ongoing connection procedure.\n @retval ::NRF_ERROR_INVALID_STATE No locally initiated connect procedure started or connection\n                                   completed occurred."]
#[inline(always)]
pub unsafe fn sd_ble_gap_connect_cancel() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 141",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or respond to a PHY Update Procedure\n\n @details   This function is used to initiate or respond to a PHY Update Procedure. It will always\n            generate a @ref BLE_GAP_EVT_PHY_UPDATE event if successfully executed.\n            If this function is used to initiate a PHY Update procedure and the only option\n            provided in @ref ble_gap_phys_t::tx_phys and @ref ble_gap_phys_t::rx_phys is the\n            currently active PHYs in the respective directions, the SoftDevice will generate a\n            @ref BLE_GAP_EVT_PHY_UPDATE with the current PHYs set and will not initiate the\n            procedure in the Link Layer.\n\n            If @ref ble_gap_phys_t::tx_phys or @ref ble_gap_phys_t::rx_phys is @ref BLE_GAP_PHY_AUTO,\n            then the stack will select PHYs based on the peer's PHY preferences and the local link\n            configuration. The PHY Update procedure will for this case result in a PHY combination\n            that respects the time constraints configured with @ref sd_ble_cfg_set and the current\n            link layer data length.\n\n            When acting as a central, the SoftDevice will select the fastest common PHY in each direction.\n\n            If the peer does not support the PHY Update Procedure, then the resulting\n            @ref BLE_GAP_EVT_PHY_UPDATE event will have a status set to\n            @ref BLE_HCI_UNSUPPORTED_REMOTE_FEATURE.\n\n            If the PHY Update procedure was rejected by the peer due to a procedure collision, the status\n            will be @ref BLE_HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION or\n            @ref BLE_HCI_DIFFERENT_TRANSACTION_COLLISION.\n            If the peer responds to the PHY Update procedure with invalid parameters, the status\n            will be @ref BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS.\n            If the PHY Update procedure was rejected by the peer for a different reason, the status will\n            contain the reason as specified by the peer.\n\n @events\n @event{@ref BLE_GAP_EVT_PHY_UPDATE, Result of the PHY Update Procedure.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GAP_CENTRAL_PHY_UPDATE}\n @mmsc{@ref BLE_GAP_PERIPHERAL_PHY_UPDATE}\n @endmscs\n\n @param[in] conn_handle   Connection handle to indicate the connection for which the PHY Update is requested.\n @param[in] p_gap_phys    Pointer to PHY structure.\n\n @retval ::NRF_SUCCESS Successfully requested a PHY Update.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_INVALID_STATE No link has been established.\n @retval ::NRF_ERROR_RESOURCES The connection event length configured for this link is not sufficient for the combination of\n                               @ref ble_gap_phys_t::tx_phys, @ref ble_gap_phys_t::rx_phys, and @ref ble_gap_data_length_params_t.\n                               The connection event length is configured with @ref BLE_CONN_CFG_GAP using @ref sd_ble_cfg_set.\n @retval ::NRF_ERROR_BUSY Procedure is already in progress or not allowed at this time. Process pending events and wait for the pending procedure to complete and retry.\n"]
#[inline(always)]
pub unsafe fn sd_ble_gap_phy_update(conn_handle: u16, p_gap_phys: *const ble_gap_phys_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 143",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_gap_phys) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Initiate or respond to a Data Length Update Procedure.\n\n @note If the application uses @ref BLE_GAP_DATA_LENGTH_AUTO for one or more members of\n       p_dl_params, the SoftDevice will choose the highest value supported in current\n       configuration and connection parameters.\n @note  If the link PHY is Coded, the SoftDevice will ensure that the MaxTxTime and/or MaxRxTime\n        used in the Data Length Update procedure is at least 2704 us. Otherwise, MaxTxTime and\n        MaxRxTime will be limited to maximum 2120 us.\n\n @param[in]   conn_handle       Connection handle.\n @param[in]   p_dl_params       Pointer to local parameters to be used in Data Length Update\n                                Procedure. Set any member to @ref BLE_GAP_DATA_LENGTH_AUTO to let\n                                the SoftDevice automatically decide the value for that member.\n                                Set to NULL to use automatic values for all members.\n @param[out]  p_dl_limitation   Pointer to limitation to be written when local device does not\n                                have enough resources or does not support the requested Data Length\n                                Update parameters. Ignored if NULL.\n\n @mscs\n @mmsc{@ref BLE_GAP_DATA_LENGTH_UPDATE_PROCEDURE_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Successfully set Data Length Extension initiation/response parameters.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter supplied.\n @retval ::NRF_ERROR_INVALID_STATE No link has been established.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied.\n @retval ::NRF_ERROR_NOT_SUPPORTED The requested parameters are not supported by the SoftDevice. Inspect\n                                   p_dl_limitation to see which parameter is not supported.\n @retval ::NRF_ERROR_RESOURCES The connection event length configured for this link is not sufficient for the requested parameters.\n                               Use @ref sd_ble_cfg_set with @ref BLE_CONN_CFG_GAP to increase the connection event length.\n                               Inspect p_dl_limitation to see where the limitation is.\n @retval ::NRF_ERROR_BUSY Peer has already initiated a Data Length Update Procedure. Process the\n                          pending @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST event to respond."]
#[inline(always)]
pub unsafe fn sd_ble_gap_data_length_update(
    conn_handle: u16,
    p_dl_params: *const ble_gap_data_length_params_t,
    p_dl_limitation: *mut ble_gap_data_length_limitation_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 144",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_dl_params) => _,
        inout("r2") to_asm(p_dl_limitation) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Start the Quality of Service (QoS) channel survey module.\n\n @details The channel survey module provides measurements of the energy levels on\n          the Bluetooth Low Energy channels. When the module is enabled, @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT\n          events will periodically report the measured energy levels for each channel.\n\n @note    The measurements are scheduled with lower priority than other Bluetooth Low Energy roles,\n          Radio Timeslot API events and Flash API events.\n\n @note    The channel survey module will attempt to do measurements so that the average interval\n          between measurements will be interval_us. However due to the channel survey module\n          having the lowest priority of all roles and modules, this may not be possible. In that\n          case fewer than expected channel survey reports may be given.\n\n @note    In order to use the channel survey module, @ref ble_gap_cfg_role_count_t::qos_channel_survey_role_available\n          must be set. This is done using @ref sd_ble_cfg_set.\n\n @param[in]   interval_us      Requested average interval for the measurements and reports. See\n                               @ref BLE_GAP_QOS_CHANNEL_SURVEY_INTERVALS for valid ranges. If set\n                               to @ref BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_CONTINUOUS, the channel\n                               survey role will be scheduled at every available opportunity.\n\n @retval ::NRF_SUCCESS             The module is successfully started.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter supplied. interval_us is out of the\n                                   allowed range.\n @retval ::NRF_ERROR_INVALID_STATE Trying to start the module when already running.\n @retval ::NRF_ERROR_RESOURCES     The channel survey module is not available to the application.\n                                   Set @ref ble_gap_cfg_role_count_t::qos_channel_survey_role_available using\n                                   @ref sd_ble_cfg_set."]
#[inline(always)]
pub unsafe fn sd_ble_gap_qos_channel_survey_start(interval_us: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 145",
        inout("r0") to_asm(interval_us) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Stop the Quality of Service (QoS) channel survey module.\n\n @note    The SoftDevice may generate one @ref BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT event after this\n          function is called.\n\n @retval ::NRF_SUCCESS             The module is successfully stopped.\n @retval ::NRF_ERROR_INVALID_STATE Trying to stop the module when it is not running."]
#[inline(always)]
pub unsafe fn sd_ble_gap_qos_channel_survey_stop() -> u32 {
    let ret: u32;
    core::arch::asm!("svc 146",
        lateout("r0") ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Obtain the next connection event counter value.\n\n @details The connection event counter is initialized to zero on the first connection event. The value is incremented\n          by one for each connection event. For more information see Bluetooth Core Specification v5.0, Vol 6, Part B,\n          Section 4.5.1.\n\n @note    The connection event counter obtained through this API will be outdated if this API is called\n          at the same time as the connection event counter is incremented.\n\n @note    This API will always return the last connection event counter + 1.\n          The actual connection event may be multiple connection events later if:\n           - Slave latency is enabled and there is no data to transmit or receive.\n           - Another role is scheduled with a higher priority at the same time as the next connection event.\n\n @param[in]   conn_handle       Connection handle.\n @param[out]  p_counter         Pointer to the variable where the next connection event counter will be written.\n\n @retval ::NRF_SUCCESS                   The connection event counter was successfully retrieved.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter supplied.\n @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gap_next_conn_evt_counter_get(conn_handle: u16, p_counter: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 148",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_counter) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Start triggering a given task on connection event start.\n\n @details When enabled, this feature will trigger a PPI task at the start of connection events.\n          The application can configure the SoftDevice to trigger every N connection events starting from\n          a given connection event counter. See also @ref ble_gap_conn_event_trigger_t.\n\n @param[in]   conn_handle   Connection handle.\n @param[in]   p_params      Connection event trigger parameters.\n\n @retval ::NRF_SUCCESS                   Success.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM       Invalid parameter supplied. See @ref ble_gap_conn_event_trigger_t.\n @retval ::NRF_ERROR_INVALID_STATE       Either:\n                                         - Trying to start connection event triggering when it is already ongoing.\n                                         - @ref ble_gap_conn_event_trigger_t::conn_evt_counter_start is in the past.\n                                           Use @ref sd_ble_gap_next_conn_evt_counter_get to find a new value\nto be used as ble_gap_conn_event_trigger_t::conn_evt_counter_start."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_evt_trigger_start(
    conn_handle: u16,
    p_params: *const ble_gap_conn_event_trigger_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 149",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief   Stop triggering the task configured using @ref sd_ble_gap_conn_evt_trigger_start.\n\n @param[in]   conn_handle   Connection handle.\n\n @retval ::NRF_SUCCESS                   Success.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.\n @retval ::NRF_ERROR_INVALID_STATE       Trying to stop connection event triggering when it is not enabled."]
#[inline(always)]
pub unsafe fn sd_ble_gap_conn_evt_trigger_stop(conn_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 150",
        inout("r0") to_asm(conn_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Add a service."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SERVICE_ADD: BLE_GATTS_SVCS = 168;
#[doc = "< Add an included service."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_INCLUDE_ADD: BLE_GATTS_SVCS = 169;
#[doc = "< Add a characteristic."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_CHARACTERISTIC_ADD: BLE_GATTS_SVCS = 170;
#[doc = "< Add a generic attribute."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_DESCRIPTOR_ADD: BLE_GATTS_SVCS = 171;
#[doc = "< Set an attribute value."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_VALUE_SET: BLE_GATTS_SVCS = 172;
#[doc = "< Get an attribute value."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_VALUE_GET: BLE_GATTS_SVCS = 173;
#[doc = "< Handle Value Notification or Indication."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_HVX: BLE_GATTS_SVCS = 174;
#[doc = "< Perform a Service Changed Indication to one or more peers."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SERVICE_CHANGED: BLE_GATTS_SVCS = 175;
#[doc = "< Reply to an authorization request for a read or write operation on one or more attributes."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_RW_AUTHORIZE_REPLY: BLE_GATTS_SVCS = 176;
#[doc = "< Set the persistent system attributes for a connection."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SYS_ATTR_SET: BLE_GATTS_SVCS = 177;
#[doc = "< Retrieve the persistent system attributes."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_SYS_ATTR_GET: BLE_GATTS_SVCS = 178;
#[doc = "< Retrieve the first valid user handle."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_INITIAL_USER_HANDLE_GET: BLE_GATTS_SVCS = 179;
#[doc = "< Retrieve the UUID and/or metadata of an attribute."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_ATTR_GET: BLE_GATTS_SVCS = 180;
#[doc = "< Reply to Exchange MTU Request."]
pub const BLE_GATTS_SVCS_SD_BLE_GATTS_EXCHANGE_MTU_REPLY: BLE_GATTS_SVCS = 181;
#[doc = " @brief GATTS API SVC numbers."]
pub type BLE_GATTS_SVCS = self::c_uint;
#[doc = "< Write operation performed.                                           \\n See @ref ble_gatts_evt_write_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_WRITE: BLE_GATTS_EVTS = 80;
#[doc = "< Read/Write Authorization request.                                    \\n Reply with @ref sd_ble_gatts_rw_authorize_reply. \\n See @ref ble_gatts_evt_rw_authorize_request_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST: BLE_GATTS_EVTS = 81;
#[doc = "< A persistent system attribute access is pending.                     \\n Respond with @ref sd_ble_gatts_sys_attr_set.     \\n See @ref ble_gatts_evt_sys_attr_missing_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_SYS_ATTR_MISSING: BLE_GATTS_EVTS = 82;
#[doc = "< Handle Value Confirmation.                                           \\n See @ref ble_gatts_evt_hvc_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_HVC: BLE_GATTS_EVTS = 83;
#[doc = "< Service Changed Confirmation.                                        \\n No additional event structure applies."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_SC_CONFIRM: BLE_GATTS_EVTS = 84;
#[doc = "< Exchange MTU Request.                                                \\n Reply with @ref sd_ble_gatts_exchange_mtu_reply. \\n See @ref ble_gatts_evt_exchange_mtu_request_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST: BLE_GATTS_EVTS = 85;
#[doc = "< Peer failed to respond to an ATT request in time.                    \\n See @ref ble_gatts_evt_timeout_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_TIMEOUT: BLE_GATTS_EVTS = 86;
#[doc = "< Handle Value Notification transmission complete.                     \\n See @ref ble_gatts_evt_hvn_tx_complete_t."]
pub const BLE_GATTS_EVTS_BLE_GATTS_EVT_HVN_TX_COMPLETE: BLE_GATTS_EVTS = 87;
#[doc = " @brief GATT Server Event IDs."]
pub type BLE_GATTS_EVTS = self::c_uint;
#[doc = "< Service changed configuration."]
pub const BLE_GATTS_CFGS_BLE_GATTS_CFG_SERVICE_CHANGED: BLE_GATTS_CFGS = 160;
#[doc = "< Attribute table size configuration."]
pub const BLE_GATTS_CFGS_BLE_GATTS_CFG_ATTR_TAB_SIZE: BLE_GATTS_CFGS = 161;
#[doc = "@brief GATTS Configuration IDs.\n\n IDs that uniquely identify a GATTS configuration."]
pub type BLE_GATTS_CFGS = self::c_uint;
#[doc = " @brief BLE GATTS connection configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_conn_cfg_t {
    #[doc = "< Minimum guaranteed number of Handle Value Notifications that can be queued for transmission.\nThe default value is @ref BLE_GATTS_HVN_TX_QUEUE_SIZE_DEFAULT"]
    pub hvn_tx_queue_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_conn_cfg_t"][::core::mem::size_of::<ble_gatts_conn_cfg_t>() - 1usize];
    ["Alignment of ble_gatts_conn_cfg_t"][::core::mem::align_of::<ble_gatts_conn_cfg_t>() - 1usize];
    ["Offset of field: ble_gatts_conn_cfg_t::hvn_tx_queue_size"]
        [::core::mem::offset_of!(ble_gatts_conn_cfg_t, hvn_tx_queue_size) - 0usize];
};
#[doc = "@brief Attribute metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_attr_md_t {
    #[doc = "< Read permissions."]
    pub read_perm: ble_gap_conn_sec_mode_t,
    #[doc = "< Write permissions."]
    pub write_perm: ble_gap_conn_sec_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_attr_md_t"][::core::mem::size_of::<ble_gatts_attr_md_t>() - 3usize];
    ["Alignment of ble_gatts_attr_md_t"][::core::mem::align_of::<ble_gatts_attr_md_t>() - 1usize];
    ["Offset of field: ble_gatts_attr_md_t::read_perm"]
        [::core::mem::offset_of!(ble_gatts_attr_md_t, read_perm) - 0usize];
    ["Offset of field: ble_gatts_attr_md_t::write_perm"]
        [::core::mem::offset_of!(ble_gatts_attr_md_t, write_perm) - 1usize];
};
impl ble_gatts_attr_md_t {
    #[inline]
    pub fn vlen(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vlen_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_vlen_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_vloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vloc_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_vloc_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rd_auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rd_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rd_auth_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rd_auth_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wr_auth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wr_auth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wr_auth_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wr_auth_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(vlen: u8, vloc: u8, rd_auth: u8, wr_auth: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlen: u8 = unsafe { ::core::mem::transmute(vlen) };
            vlen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let vloc: u8 = unsafe { ::core::mem::transmute(vloc) };
            vloc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rd_auth: u8 = unsafe { ::core::mem::transmute(rd_auth) };
            rd_auth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wr_auth: u8 = unsafe { ::core::mem::transmute(wr_auth) };
            wr_auth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_attr_t {
    #[doc = "< Pointer to the attribute UUID."]
    pub p_uuid: *const ble_uuid_t,
    #[doc = "< Pointer to the attribute metadata structure."]
    pub p_attr_md: *const ble_gatts_attr_md_t,
    #[doc = "< Initial attribute value length in bytes."]
    pub init_len: u16,
    #[doc = "< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized."]
    pub init_offs: u16,
    #[doc = "< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values."]
    pub max_len: u16,
    #[doc = "< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer\nthat remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location.\nThe stack may access that memory directly without the application's knowledge. For writable characteristics, this value must not be a location in flash memory."]
    pub p_value: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_attr_t"][::core::mem::size_of::<ble_gatts_attr_t>() - 20usize];
    ["Alignment of ble_gatts_attr_t"][::core::mem::align_of::<ble_gatts_attr_t>() - 4usize];
    ["Offset of field: ble_gatts_attr_t::p_uuid"][::core::mem::offset_of!(ble_gatts_attr_t, p_uuid) - 0usize];
    ["Offset of field: ble_gatts_attr_t::p_attr_md"][::core::mem::offset_of!(ble_gatts_attr_t, p_attr_md) - 4usize];
    ["Offset of field: ble_gatts_attr_t::init_len"][::core::mem::offset_of!(ble_gatts_attr_t, init_len) - 8usize];
    ["Offset of field: ble_gatts_attr_t::init_offs"][::core::mem::offset_of!(ble_gatts_attr_t, init_offs) - 10usize];
    ["Offset of field: ble_gatts_attr_t::max_len"][::core::mem::offset_of!(ble_gatts_attr_t, max_len) - 12usize];
    ["Offset of field: ble_gatts_attr_t::p_value"][::core::mem::offset_of!(ble_gatts_attr_t, p_value) - 16usize];
};
#[doc = "@brief GATT Attribute Value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_value_t {
    #[doc = "< Length in bytes to be written or read. Length in bytes written or read after successful return."]
    pub len: u16,
    #[doc = "< Attribute value offset."]
    pub offset: u16,
    #[doc = "< Pointer to where value is stored or will be stored.\nIf value is stored in user memory, only the attribute length is updated when p_value == NULL.\nSet to NULL when reading to obtain the complete length of the attribute value"]
    pub p_value: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_value_t"][::core::mem::size_of::<ble_gatts_value_t>() - 8usize];
    ["Alignment of ble_gatts_value_t"][::core::mem::align_of::<ble_gatts_value_t>() - 4usize];
    ["Offset of field: ble_gatts_value_t::len"][::core::mem::offset_of!(ble_gatts_value_t, len) - 0usize];
    ["Offset of field: ble_gatts_value_t::offset"][::core::mem::offset_of!(ble_gatts_value_t, offset) - 2usize];
    ["Offset of field: ble_gatts_value_t::p_value"][::core::mem::offset_of!(ble_gatts_value_t, p_value) - 4usize];
};
#[doc = "@brief GATT Characteristic Presentation Format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_pf_t {
    #[doc = "< Format of the value, see @ref BLE_GATT_CPF_FORMATS."]
    pub format: u8,
    #[doc = "< Exponent for integer data types."]
    pub exponent: i8,
    #[doc = "< Unit from Bluetooth Assigned Numbers."]
    pub unit: u16,
    #[doc = "< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES."]
    pub name_space: u8,
    #[doc = "< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES."]
    pub desc: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_char_pf_t"][::core::mem::size_of::<ble_gatts_char_pf_t>() - 8usize];
    ["Alignment of ble_gatts_char_pf_t"][::core::mem::align_of::<ble_gatts_char_pf_t>() - 2usize];
    ["Offset of field: ble_gatts_char_pf_t::format"][::core::mem::offset_of!(ble_gatts_char_pf_t, format) - 0usize];
    ["Offset of field: ble_gatts_char_pf_t::exponent"][::core::mem::offset_of!(ble_gatts_char_pf_t, exponent) - 1usize];
    ["Offset of field: ble_gatts_char_pf_t::unit"][::core::mem::offset_of!(ble_gatts_char_pf_t, unit) - 2usize];
    ["Offset of field: ble_gatts_char_pf_t::name_space"]
        [::core::mem::offset_of!(ble_gatts_char_pf_t, name_space) - 4usize];
    ["Offset of field: ble_gatts_char_pf_t::desc"][::core::mem::offset_of!(ble_gatts_char_pf_t, desc) - 6usize];
};
#[doc = "@brief GATT Characteristic metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_md_t {
    #[doc = "< Characteristic Properties."]
    pub char_props: ble_gatt_char_props_t,
    #[doc = "< Characteristic Extended Properties."]
    pub char_ext_props: ble_gatt_char_ext_props_t,
    #[doc = "< Pointer to a UTF-8 encoded string (non-NULL terminated), NULL if the descriptor is not required."]
    pub p_char_user_desc: *const u8,
    #[doc = "< The maximum size in bytes of the user description descriptor."]
    pub char_user_desc_max_size: u16,
    #[doc = "< The size of the user description, must be smaller or equal to char_user_desc_max_size."]
    pub char_user_desc_size: u16,
    #[doc = "< Pointer to a presentation format structure or NULL if the CPF descriptor is not required."]
    pub p_char_pf: *const ble_gatts_char_pf_t,
    #[doc = "< Attribute metadata for the User Description descriptor, or NULL for default values."]
    pub p_user_desc_md: *const ble_gatts_attr_md_t,
    #[doc = "< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values."]
    pub p_cccd_md: *const ble_gatts_attr_md_t,
    #[doc = "< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values."]
    pub p_sccd_md: *const ble_gatts_attr_md_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_char_md_t"][::core::mem::size_of::<ble_gatts_char_md_t>() - 28usize];
    ["Alignment of ble_gatts_char_md_t"][::core::mem::align_of::<ble_gatts_char_md_t>() - 4usize];
    ["Offset of field: ble_gatts_char_md_t::char_props"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, char_props) - 0usize];
    ["Offset of field: ble_gatts_char_md_t::char_ext_props"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, char_ext_props) - 1usize];
    ["Offset of field: ble_gatts_char_md_t::p_char_user_desc"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, p_char_user_desc) - 4usize];
    ["Offset of field: ble_gatts_char_md_t::char_user_desc_max_size"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, char_user_desc_max_size) - 8usize];
    ["Offset of field: ble_gatts_char_md_t::char_user_desc_size"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, char_user_desc_size) - 10usize];
    ["Offset of field: ble_gatts_char_md_t::p_char_pf"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, p_char_pf) - 12usize];
    ["Offset of field: ble_gatts_char_md_t::p_user_desc_md"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, p_user_desc_md) - 16usize];
    ["Offset of field: ble_gatts_char_md_t::p_cccd_md"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, p_cccd_md) - 20usize];
    ["Offset of field: ble_gatts_char_md_t::p_sccd_md"]
        [::core::mem::offset_of!(ble_gatts_char_md_t, p_sccd_md) - 24usize];
};
#[doc = "@brief GATT Characteristic Definition Handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_char_handles_t {
    #[doc = "< Handle to the characteristic value."]
    pub value_handle: u16,
    #[doc = "< Handle to the User Description descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub user_desc_handle: u16,
    #[doc = "< Handle to the Client Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub cccd_handle: u16,
    #[doc = "< Handle to the Server Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present."]
    pub sccd_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_char_handles_t"][::core::mem::size_of::<ble_gatts_char_handles_t>() - 8usize];
    ["Alignment of ble_gatts_char_handles_t"][::core::mem::align_of::<ble_gatts_char_handles_t>() - 2usize];
    ["Offset of field: ble_gatts_char_handles_t::value_handle"]
        [::core::mem::offset_of!(ble_gatts_char_handles_t, value_handle) - 0usize];
    ["Offset of field: ble_gatts_char_handles_t::user_desc_handle"]
        [::core::mem::offset_of!(ble_gatts_char_handles_t, user_desc_handle) - 2usize];
    ["Offset of field: ble_gatts_char_handles_t::cccd_handle"]
        [::core::mem::offset_of!(ble_gatts_char_handles_t, cccd_handle) - 4usize];
    ["Offset of field: ble_gatts_char_handles_t::sccd_handle"]
        [::core::mem::offset_of!(ble_gatts_char_handles_t, sccd_handle) - 6usize];
};
#[doc = "@brief GATT HVx parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_hvx_params_t {
    #[doc = "< Characteristic Value Handle."]
    pub handle: u16,
    #[doc = "< Indication or Notification, see @ref BLE_GATT_HVX_TYPES."]
    pub type_: u8,
    #[doc = "< Offset within the attribute value."]
    pub offset: u16,
    #[doc = "< Length in bytes to be written, length in bytes written after return."]
    pub p_len: *mut u16,
    #[doc = "< Actual data content, use NULL to use the current attribute value."]
    pub p_data: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_hvx_params_t"][::core::mem::size_of::<ble_gatts_hvx_params_t>() - 16usize];
    ["Alignment of ble_gatts_hvx_params_t"][::core::mem::align_of::<ble_gatts_hvx_params_t>() - 4usize];
    ["Offset of field: ble_gatts_hvx_params_t::handle"]
        [::core::mem::offset_of!(ble_gatts_hvx_params_t, handle) - 0usize];
    ["Offset of field: ble_gatts_hvx_params_t::type_"][::core::mem::offset_of!(ble_gatts_hvx_params_t, type_) - 2usize];
    ["Offset of field: ble_gatts_hvx_params_t::offset"]
        [::core::mem::offset_of!(ble_gatts_hvx_params_t, offset) - 4usize];
    ["Offset of field: ble_gatts_hvx_params_t::p_len"][::core::mem::offset_of!(ble_gatts_hvx_params_t, p_len) - 8usize];
    ["Offset of field: ble_gatts_hvx_params_t::p_data"]
        [::core::mem::offset_of!(ble_gatts_hvx_params_t, p_data) - 12usize];
};
#[doc = "@brief GATT Authorization parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_authorize_params_t {
    #[doc = "< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES."]
    pub gatt_status: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Offset of the attribute value being updated."]
    pub offset: u16,
    #[doc = "< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX."]
    pub len: u16,
    #[doc = "< Pointer to new value used to update the attribute value."]
    pub p_data: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_authorize_params_t"][::core::mem::size_of::<ble_gatts_authorize_params_t>() - 12usize];
    ["Alignment of ble_gatts_authorize_params_t"][::core::mem::align_of::<ble_gatts_authorize_params_t>() - 4usize];
    ["Offset of field: ble_gatts_authorize_params_t::gatt_status"]
        [::core::mem::offset_of!(ble_gatts_authorize_params_t, gatt_status) - 0usize];
    ["Offset of field: ble_gatts_authorize_params_t::offset"]
        [::core::mem::offset_of!(ble_gatts_authorize_params_t, offset) - 4usize];
    ["Offset of field: ble_gatts_authorize_params_t::len"]
        [::core::mem::offset_of!(ble_gatts_authorize_params_t, len) - 6usize];
    ["Offset of field: ble_gatts_authorize_params_t::p_data"]
        [::core::mem::offset_of!(ble_gatts_authorize_params_t, p_data) - 8usize];
};
impl ble_gatts_authorize_params_t {
    #[inline]
    pub fn update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_update_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(update: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update: u8 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief GATT Read or Write Authorize Reply parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatts_rw_authorize_reply_params_t {
    #[doc = "< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES."]
    pub type_: u8,
    #[doc = "< Reply Parameters."]
    pub params: ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1 {
    #[doc = "< Read authorization parameters."]
    pub read: ble_gatts_authorize_params_t,
    #[doc = "< Write authorization parameters."]
    pub write: ble_gatts_authorize_params_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1"]
        [::core::mem::size_of::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>() - 12usize];
    ["Alignment of ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1"]
        [::core::mem::align_of::<ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1::read"]
        [::core::mem::offset_of!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1, read) - 0usize];
    ["Offset of field: ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1::write"]
        [::core::mem::offset_of!(ble_gatts_rw_authorize_reply_params_t__bindgen_ty_1, write) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_rw_authorize_reply_params_t"]
        [::core::mem::size_of::<ble_gatts_rw_authorize_reply_params_t>() - 16usize];
    ["Alignment of ble_gatts_rw_authorize_reply_params_t"]
        [::core::mem::align_of::<ble_gatts_rw_authorize_reply_params_t>() - 4usize];
    ["Offset of field: ble_gatts_rw_authorize_reply_params_t::type_"]
        [::core::mem::offset_of!(ble_gatts_rw_authorize_reply_params_t, type_) - 0usize];
    ["Offset of field: ble_gatts_rw_authorize_reply_params_t::params"]
        [::core::mem::offset_of!(ble_gatts_rw_authorize_reply_params_t, params) - 4usize];
};
#[doc = "@brief Service Changed Inclusion configuration parameters, set with @ref sd_ble_cfg_set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_cfg_service_changed_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_cfg_service_changed_t"][::core::mem::size_of::<ble_gatts_cfg_service_changed_t>() - 1usize];
    ["Alignment of ble_gatts_cfg_service_changed_t"]
        [::core::mem::align_of::<ble_gatts_cfg_service_changed_t>() - 1usize];
};
impl ble_gatts_cfg_service_changed_t {
    #[inline]
    pub fn service_changed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_service_changed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn service_changed_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_service_changed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(service_changed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let service_changed: u8 = unsafe { ::core::mem::transmute(service_changed) };
            service_changed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Attribute table size configuration parameters, set with @ref sd_ble_cfg_set.\n\n @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:\n                                    - The specified Attribute Table size is too small.\n                                      The minimum acceptable size is defined by @ref BLE_GATTS_ATTR_TAB_SIZE_MIN.\n                                    - The specified Attribute Table size is not a multiple of 4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_cfg_attr_tab_size_t {
    #[doc = "< Attribute table size. Default is @ref BLE_GATTS_ATTR_TAB_SIZE_DEFAULT, minimum is @ref BLE_GATTS_ATTR_TAB_SIZE_MIN."]
    pub attr_tab_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_cfg_attr_tab_size_t"][::core::mem::size_of::<ble_gatts_cfg_attr_tab_size_t>() - 4usize];
    ["Alignment of ble_gatts_cfg_attr_tab_size_t"][::core::mem::align_of::<ble_gatts_cfg_attr_tab_size_t>() - 4usize];
    ["Offset of field: ble_gatts_cfg_attr_tab_size_t::attr_tab_size"]
        [::core::mem::offset_of!(ble_gatts_cfg_attr_tab_size_t, attr_tab_size) - 0usize];
};
#[doc = "@brief Config structure for GATTS configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatts_cfg_t {
    #[doc = "< Include service changed characteristic, cfg_id is @ref BLE_GATTS_CFG_SERVICE_CHANGED."]
    pub service_changed: ble_gatts_cfg_service_changed_t,
    #[doc = "< Attribute table size, cfg_id is @ref BLE_GATTS_CFG_ATTR_TAB_SIZE."]
    pub attr_tab_size: ble_gatts_cfg_attr_tab_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_cfg_t"][::core::mem::size_of::<ble_gatts_cfg_t>() - 4usize];
    ["Alignment of ble_gatts_cfg_t"][::core::mem::align_of::<ble_gatts_cfg_t>() - 4usize];
    ["Offset of field: ble_gatts_cfg_t::service_changed"]
        [::core::mem::offset_of!(ble_gatts_cfg_t, service_changed) - 0usize];
    ["Offset of field: ble_gatts_cfg_t::attr_tab_size"]
        [::core::mem::offset_of!(ble_gatts_cfg_t, attr_tab_size) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_WRITE."]
#[repr(C)]
#[derive(Debug)]
pub struct ble_gatts_evt_write_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Attribute UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Type of write operation, see @ref BLE_GATTS_OPS."]
    pub op: u8,
    #[doc = "< Writing operation deferred due to authorization requirement. Application may use @ref sd_ble_gatts_value_set to finalize the writing operation."]
    pub auth_required: u8,
    #[doc = "< Offset for the write operation."]
    pub offset: u16,
    #[doc = "< Length of the received data."]
    pub len: u16,
    #[doc = "< Received data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.\nSee @ref sd_ble_evt_get for more information on how to use event structures with variable length array members."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_write_t"][::core::mem::size_of::<ble_gatts_evt_write_t>() - 12usize];
    ["Alignment of ble_gatts_evt_write_t"][::core::mem::align_of::<ble_gatts_evt_write_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_write_t::handle"][::core::mem::offset_of!(ble_gatts_evt_write_t, handle) - 0usize];
    ["Offset of field: ble_gatts_evt_write_t::uuid"][::core::mem::offset_of!(ble_gatts_evt_write_t, uuid) - 2usize];
    ["Offset of field: ble_gatts_evt_write_t::op"][::core::mem::offset_of!(ble_gatts_evt_write_t, op) - 6usize];
    ["Offset of field: ble_gatts_evt_write_t::auth_required"]
        [::core::mem::offset_of!(ble_gatts_evt_write_t, auth_required) - 7usize];
    ["Offset of field: ble_gatts_evt_write_t::offset"][::core::mem::offset_of!(ble_gatts_evt_write_t, offset) - 8usize];
    ["Offset of field: ble_gatts_evt_write_t::len"][::core::mem::offset_of!(ble_gatts_evt_write_t, len) - 10usize];
    ["Offset of field: ble_gatts_evt_write_t::data"][::core::mem::offset_of!(ble_gatts_evt_write_t, data) - 12usize];
};
#[doc = "@brief Event substructure for authorized read requests, see @ref ble_gatts_evt_rw_authorize_request_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_read_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
    #[doc = "< Attribute UUID."]
    pub uuid: ble_uuid_t,
    #[doc = "< Offset for the read operation."]
    pub offset: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_read_t"][::core::mem::size_of::<ble_gatts_evt_read_t>() - 8usize];
    ["Alignment of ble_gatts_evt_read_t"][::core::mem::align_of::<ble_gatts_evt_read_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_read_t::handle"][::core::mem::offset_of!(ble_gatts_evt_read_t, handle) - 0usize];
    ["Offset of field: ble_gatts_evt_read_t::uuid"][::core::mem::offset_of!(ble_gatts_evt_read_t, uuid) - 2usize];
    ["Offset of field: ble_gatts_evt_read_t::offset"][::core::mem::offset_of!(ble_gatts_evt_read_t, offset) - 6usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST."]
#[repr(C)]
pub struct ble_gatts_evt_rw_authorize_request_t {
    #[doc = "< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES."]
    pub type_: u8,
    #[doc = "< Request Parameters."]
    pub request: ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1 {
    #[doc = "< Attribute Read Parameters."]
    pub read: __BindgenUnionField<ble_gatts_evt_read_t>,
    #[doc = "< Attribute Write Parameters."]
    pub write: __BindgenUnionField<ble_gatts_evt_write_t>,
    pub bindgen_union_field: [u16; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1"]
        [::core::mem::size_of::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>() - 12usize];
    ["Alignment of ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1"]
        [::core::mem::align_of::<ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1::read"]
        [::core::mem::offset_of!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1, read) - 0usize];
    ["Offset of field: ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1::write"]
        [::core::mem::offset_of!(ble_gatts_evt_rw_authorize_request_t__bindgen_ty_1, write) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_rw_authorize_request_t"]
        [::core::mem::size_of::<ble_gatts_evt_rw_authorize_request_t>() - 14usize];
    ["Alignment of ble_gatts_evt_rw_authorize_request_t"]
        [::core::mem::align_of::<ble_gatts_evt_rw_authorize_request_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_rw_authorize_request_t::type_"]
        [::core::mem::offset_of!(ble_gatts_evt_rw_authorize_request_t, type_) - 0usize];
    ["Offset of field: ble_gatts_evt_rw_authorize_request_t::request"]
        [::core::mem::offset_of!(ble_gatts_evt_rw_authorize_request_t, request) - 2usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_SYS_ATTR_MISSING."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_sys_attr_missing_t {
    #[doc = "< Hint (currently unused)."]
    pub hint: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_sys_attr_missing_t"][::core::mem::size_of::<ble_gatts_evt_sys_attr_missing_t>() - 1usize];
    ["Alignment of ble_gatts_evt_sys_attr_missing_t"]
        [::core::mem::align_of::<ble_gatts_evt_sys_attr_missing_t>() - 1usize];
    ["Offset of field: ble_gatts_evt_sys_attr_missing_t::hint"]
        [::core::mem::offset_of!(ble_gatts_evt_sys_attr_missing_t, hint) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_HVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_hvc_t {
    #[doc = "< Attribute Handle."]
    pub handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_hvc_t"][::core::mem::size_of::<ble_gatts_evt_hvc_t>() - 2usize];
    ["Alignment of ble_gatts_evt_hvc_t"][::core::mem::align_of::<ble_gatts_evt_hvc_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_hvc_t::handle"][::core::mem::offset_of!(ble_gatts_evt_hvc_t, handle) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_exchange_mtu_request_t {
    #[doc = "< Client RX MTU size."]
    pub client_rx_mtu: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_exchange_mtu_request_t"]
        [::core::mem::size_of::<ble_gatts_evt_exchange_mtu_request_t>() - 2usize];
    ["Alignment of ble_gatts_evt_exchange_mtu_request_t"]
        [::core::mem::align_of::<ble_gatts_evt_exchange_mtu_request_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_exchange_mtu_request_t::client_rx_mtu"]
        [::core::mem::offset_of!(ble_gatts_evt_exchange_mtu_request_t, client_rx_mtu) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_TIMEOUT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_timeout_t {
    #[doc = "< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES."]
    pub src: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_timeout_t"][::core::mem::size_of::<ble_gatts_evt_timeout_t>() - 1usize];
    ["Alignment of ble_gatts_evt_timeout_t"][::core::mem::align_of::<ble_gatts_evt_timeout_t>() - 1usize];
    ["Offset of field: ble_gatts_evt_timeout_t::src"][::core::mem::offset_of!(ble_gatts_evt_timeout_t, src) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_GATTS_EVT_HVN_TX_COMPLETE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatts_evt_hvn_tx_complete_t {
    #[doc = "< Number of notification transmissions completed."]
    pub count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_hvn_tx_complete_t"][::core::mem::size_of::<ble_gatts_evt_hvn_tx_complete_t>() - 1usize];
    ["Alignment of ble_gatts_evt_hvn_tx_complete_t"]
        [::core::mem::align_of::<ble_gatts_evt_hvn_tx_complete_t>() - 1usize];
    ["Offset of field: ble_gatts_evt_hvn_tx_complete_t::count"]
        [::core::mem::offset_of!(ble_gatts_evt_hvn_tx_complete_t, count) - 0usize];
};
#[doc = "@brief GATTS event structure."]
#[repr(C)]
pub struct ble_gatts_evt_t {
    #[doc = "< Connection Handle on which the event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event Parameters."]
    pub params: ble_gatts_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_gatts_evt_t__bindgen_ty_1 {
    #[doc = "< Write Event Parameters."]
    pub write: __BindgenUnionField<ble_gatts_evt_write_t>,
    #[doc = "< Read or Write Authorize Request Parameters."]
    pub authorize_request: __BindgenUnionField<ble_gatts_evt_rw_authorize_request_t>,
    #[doc = "< System attributes missing."]
    pub sys_attr_missing: __BindgenUnionField<ble_gatts_evt_sys_attr_missing_t>,
    #[doc = "< Handle Value Confirmation Event Parameters."]
    pub hvc: __BindgenUnionField<ble_gatts_evt_hvc_t>,
    #[doc = "< Exchange MTU Request Event Parameters."]
    pub exchange_mtu_request: __BindgenUnionField<ble_gatts_evt_exchange_mtu_request_t>,
    #[doc = "< Timeout Event."]
    pub timeout: __BindgenUnionField<ble_gatts_evt_timeout_t>,
    #[doc = "< Handle Value Notification transmission complete Event Parameters."]
    pub hvn_tx_complete: __BindgenUnionField<ble_gatts_evt_hvn_tx_complete_t>,
    pub bindgen_union_field: [u16; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_gatts_evt_t__bindgen_ty_1>() - 14usize];
    ["Alignment of ble_gatts_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_gatts_evt_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::write"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, write) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::authorize_request"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, authorize_request) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::sys_attr_missing"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, sys_attr_missing) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::hvc"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, hvc) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::exchange_mtu_request"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, exchange_mtu_request) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::timeout"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, timeout) - 0usize];
    ["Offset of field: ble_gatts_evt_t__bindgen_ty_1::hvn_tx_complete"]
        [::core::mem::offset_of!(ble_gatts_evt_t__bindgen_ty_1, hvn_tx_complete) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_gatts_evt_t"][::core::mem::size_of::<ble_gatts_evt_t>() - 16usize];
    ["Alignment of ble_gatts_evt_t"][::core::mem::align_of::<ble_gatts_evt_t>() - 2usize];
    ["Offset of field: ble_gatts_evt_t::conn_handle"][::core::mem::offset_of!(ble_gatts_evt_t, conn_handle) - 0usize];
    ["Offset of field: ble_gatts_evt_t::params"][::core::mem::offset_of!(ble_gatts_evt_t, params) - 2usize];
};

#[doc = "@brief Add a service declaration to the Attribute Table.\n\n @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to\n       add a secondary service declaration that is not referenced by another service later in the Attribute Table.\n\n @mscs\n @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}\n @endmscs\n\n @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.\n @param[in] p_uuid    Pointer to service UUID.\n @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.\n\n @retval ::NRF_SUCCESS Successfully added a service declaration.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.\n @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_service_add(type_: u8, p_uuid: *const ble_uuid_t, p_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 168",
        inout("r0") to_asm(type_) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add an include declaration to the Attribute Table.\n\n @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential population is supported at this time).\n\n @note The included service must already be present in the Attribute Table prior to this call.\n\n @mscs\n @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}\n @endmscs\n\n @param[in] service_handle    Handle of the service where the included service is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.\n @param[in] inc_srvc_handle   Handle of the included service.\n @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored.\n\n @retval ::NRF_SUCCESS Successfully added an include declaration.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.\n @retval ::NRF_ERROR_NOT_SUPPORTED Feature is not supported, service_handle must be that of the last added service.\n @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.\n @retval ::NRF_ERROR_NOT_FOUND Attribute not found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_include_add(service_handle: u16, inc_srvc_handle: u16, p_include_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 169",
        inout("r0") to_asm(service_handle) => ret,
        inout("r1") to_asm(inc_srvc_handle) => _,
        inout("r2") to_asm(p_include_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the Attribute Table.\n\n @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential population is supported at this time).\n\n @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writable auxiliaries bits,\n       readable (no security) and writable (selectable) CCCDs and SCCDs and valid presentation format values.\n\n @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.\n\n @mscs\n @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}\n @endmscs\n\n @param[in] service_handle    Handle of the service where the characteristic is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.\n @param[in] p_char_md         Characteristic metadata.\n @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value.\n @param[out] p_handles        Pointer to the structure where the assigned handles will be stored.\n\n @retval ::NRF_SUCCESS Successfully added a characteristic.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.\n @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_characteristic_add(
    service_handle: u16,
    p_char_md: *const ble_gatts_char_md_t,
    p_attr_char_value: *const ble_gatts_attr_t,
    p_handles: *mut ble_gatts_char_handles_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 170",
        inout("r0") to_asm(service_handle) => ret,
        inout("r1") to_asm(p_char_md) => _,
        inout("r2") to_asm(p_attr_char_value) => _,
        inout("r3") to_asm(p_handles) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a descriptor to the Attribute Table.\n\n @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential population is supported at this time).\n\n @mscs\n @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}\n @endmscs\n\n @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.\n @param[in] p_attr        Pointer to the attribute structure.\n @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored.\n\n @retval ::NRF_SUCCESS Successfully added a descriptor.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.\n @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required.\n @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_descriptor_add(
    char_handle: u16,
    p_attr: *const ble_gatts_attr_t,
    p_handle: *mut u16,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 171",
        inout("r0") to_asm(char_handle) => ret,
        inout("r1") to_asm(p_attr) => _,
        inout("r2") to_asm(p_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set the value of a given attribute.\n\n @note Values other than system attributes can be set at any time, regardless of whether any active connections exist.\n\n @mscs\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}\n @endmscs\n\n @param[in] conn_handle  Connection handle. Ignored if the value does not belong to a system attribute.\n @param[in] handle       Attribute handle.\n @param[in,out] p_value  Attribute value information.\n\n @retval ::NRF_SUCCESS Successfully set the value of the attribute.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::NRF_ERROR_NOT_FOUND Attribute not found.\n @retval ::NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied on a system attribute."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_value_set(conn_handle: u16, handle: u16, p_value: *mut ble_gatts_value_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 172",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(p_value) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get the value of a given attribute.\n\n @note                 If the attribute value is longer than the size of the supplied buffer,\n                       @ref ble_gatts_value_t::len will return the total attribute value length (excluding offset),\n                       and not the number of bytes actually returned in @ref ble_gatts_value_t::p_value.\n                       The application may use this information to allocate a suitable buffer size.\n\n @note                 When retrieving system attribute values with this function, the connection handle\n                       may refer to an already disconnected connection. Refer to the documentation of\n                       @ref sd_ble_gatts_sys_attr_get for further information.\n\n @param[in] conn_handle  Connection handle. Ignored if the value does not belong to a system attribute.\n @param[in] handle       Attribute handle.\n @param[in,out] p_value  Attribute value information.\n\n @retval ::NRF_SUCCESS Successfully retrieved the value of the attribute.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_NOT_FOUND Attribute not found.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid attribute offset supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied on a system attribute.\n @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_value_get(conn_handle: u16, handle: u16, p_value: *mut ble_gatts_value_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 173",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(handle) => _,
        inout("r2") to_asm(p_value) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Notify or Indicate an attribute value.\n\n @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation\n          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that\n          the application can atomically perform a value update and a server initiated transaction with a single API call.\n\n @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution.\n          The Attribute Table has been updated if one of the following error codes is returned: @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY,\n          @ref NRF_ERROR_FORBIDDEN, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and @ref NRF_ERROR_RESOURCES.\n          The caller can check whether the value has been updated by looking at the contents of *(@ref ble_gatts_hvx_params_t::p_len).\n\n @note    Only one indication procedure can be ongoing per connection at a time.\n          If the application tries to indicate an attribute value while another indication procedure is ongoing,\n          the function call will return @ref NRF_ERROR_BUSY.\n          A @ref BLE_GATTS_EVT_HVC event will be issued as soon as the confirmation arrives from the peer.\n\n @note    The number of Handle Value Notifications that can be queued is configured by @ref ble_gatts_conn_cfg_t::hvn_tx_queue_size\n          When the queue is full, the function call will return @ref NRF_ERROR_RESOURCES.\n          A @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event will be issued as soon as the transmission of the notification is complete.\n\n @note    The application can keep track of the available queue element count for notifications by following the procedure below:\n          - Store initial queue element count in a variable.\n          - Decrement the variable, which stores the currently available queue element count, by one when a call to this function returns @ref NRF_SUCCESS.\n          - Increment the variable, which stores the current available queue element count, by the count variable in @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event.\n\n @events\n @event{@ref BLE_GATTS_EVT_HVN_TX_COMPLETE, Notification transmission complete.}\n @event{@ref BLE_GATTS_EVT_HVC, Confirmation received from the peer.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}\n @mmsc{@ref BLE_GATTS_HVN_MSC}\n @mmsc{@ref BLE_GATTS_HVI_MSC}\n @mmsc{@ref BLE_GATTS_HVX_DISABLED_MSC}\n @endmscs\n\n @param[in] conn_handle      Connection handle.\n @param[in,out] p_hvx_params Pointer to an HVx parameters structure. If @ref ble_gatts_hvx_params_t::p_data\n                             contains a non-NULL pointer the attribute value will be updated with the contents\n                             pointed by it before sending the notification or indication. If the attribute value\n                             is updated, @ref ble_gatts_hvx_params_t::p_len is updated by the SoftDevice to\n                             contain the number of actual bytes written, else it will be set to 0.\n\n @retval ::NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:\n                                   - Invalid Connection State\n                                   - Notifications and/or indications not enabled in the CCCD\n                                   - An ATT_MTU exchange is ongoing\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.\n @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated.\n @retval ::NRF_ERROR_NOT_FOUND Attribute not found.\n @retval ::NRF_ERROR_FORBIDDEN The connection's current security level is lower than the one required by the write permissions of the CCCD associated with this characteristic.\n @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.\n @retval ::NRF_ERROR_BUSY For @ref BLE_GATT_HVX_INDICATION Procedure already in progress. Wait for a @ref BLE_GATTS_EVT_HVC event and retry.\n @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.\n @retval ::NRF_ERROR_RESOURCES Too many notifications queued.\n                               Wait for a @ref BLE_GATTS_EVT_HVN_TX_COMPLETE event and retry.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_hvx(conn_handle: u16, p_hvx_params: *const ble_gatts_hvx_params_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 174",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_hvx_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Indicate the Service Changed attribute value.\n\n @details This call will send a Handle Value Indication to one or more peers connected to inform them that the Attribute\n          Table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will\n          be issued.\n\n @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here.\n\n @events\n @event{@ref BLE_GATTS_EVT_SC_CONFIRM, Confirmation of attribute table change received from peer.}\n @endevents\n\n @mscs\n @mmsc{@ref BLE_GATTS_SC_MSC}\n @endmscs\n\n @param[in] conn_handle  Connection handle.\n @param[in] start_handle Start of affected attribute handle range.\n @param[in] end_handle   End of affected attribute handle range.\n\n @retval ::NRF_SUCCESS Successfully queued the Service Changed indication for transmission.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_NOT_SUPPORTED Service Changed not enabled at initialization. See @ref\n                                   sd_ble_cfg_set and @ref ble_gatts_cfg_service_changed_t.\n @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:\n                                   - Invalid Connection State\n                                   - Notifications and/or indications not enabled in the CCCD\n                                   - An ATT_MTU exchange is ongoing\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.\n @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application.\n @retval ::NRF_ERROR_BUSY Procedure already in progress.\n @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_service_changed(conn_handle: u16, start_handle: u16, end_handle: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 175",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(start_handle) => _,
        inout("r2") to_asm(end_handle) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Respond to a Read/Write authorization request.\n\n @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application.\n\n @mscs\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}\n @mmsc{@ref BLE_GATTS_READ_REQ_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_WRITE_REQ_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_PEER_CANCEL_MSC}\n @endmscs\n\n @param[in] conn_handle                 Connection handle.\n @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application.\n\n @note @ref ble_gatts_authorize_params_t::p_data is ignored when this function is used to respond\n       to a @ref BLE_GATTS_AUTHORIZE_TYPE_READ event if @ref ble_gatts_authorize_params_t::update\n       is set to 0.\n\n @retval ::NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, Attribute Table updated.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_BUSY            The stack is busy, process pending events and retry.\n @retval ::NRF_ERROR_INVALID_ADDR    Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending.\n @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,\n                                         handle supplied does not match requested handle,\n                                         or invalid data to be written provided by the application.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_rw_authorize_reply(
    conn_handle: u16,
    p_rw_authorize_reply_params: *const ble_gatts_rw_authorize_reply_params_t,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 176",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_rw_authorize_reply_params) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Update persistent system attribute information.\n\n @details Supply information about persistent system attributes to the stack,\n          previously obtained using @ref sd_ble_gatts_sys_attr_get.\n          This call is only allowed for active connections, and is usually\n          made immediately after a connection is established with an known bonded device,\n          often as a response to a @ref BLE_GATTS_EVT_SYS_ATTR_MISSING.\n\n          p_sysattrs may point directly to the application's stored copy of the system attributes\n          obtained using @ref sd_ble_gatts_sys_attr_get.\n          If the pointer is NULL, the system attribute info is initialized, assuming that\n          the application does not have any previously saved system attribute data for this device.\n\n @note The state of persistent system attributes is reset upon connection establishment and then remembered for its duration.\n\n @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially.\n       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or\n       reset the SoftDevice to return to a known state.\n\n @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be modified.\n @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be modified.\n\n @mscs\n @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}\n @mmsc{@ref BLE_GATTS_SYS_ATTRS_UNK_PEER_MSC}\n @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}\n @endmscs\n\n @param[in]  conn_handle        Connection handle.\n @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL.\n @param[in]  len                Size of data pointed by p_sys_attr_data, in octets.\n @param[in]  flags              Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS\n\n @retval ::NRF_SUCCESS Successfully set the system attribute information.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.\n @retval ::NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.\n @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_sys_attr_set(conn_handle: u16, p_sys_attr_data: *const u8, len: u16, flags: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 177",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sys_attr_data) => _,
        inout("r2") to_asm(len) => _,
        inout("r3") to_asm(flags) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve persistent system attribute information from the stack.\n\n @details This call is used to retrieve information about values to be stored persistently by the application\n          during the lifetime of a connection or after it has been terminated. When a new connection is established with the same bonded device,\n          the system attribute information retrieved with this function should be restored using using @ref sd_ble_gatts_sys_attr_set.\n          If retrieved after disconnection, the data should be read before a new connection established. The connection handle for\n          the previous, now disconnected, connection will remain valid until a new one is created to allow this API call to refer to it.\n          Connection handles belonging to active connections can be used as well, but care should be taken since the system attributes\n          may be written to at any time by the peer during a connection's lifetime.\n\n @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be returned.\n @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be returned.\n\n @mscs\n @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}\n @endmscs\n\n @param[in]     conn_handle       Connection handle of the recently terminated connection.\n @param[out]    p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. The format of the data is described\n                                  in @ref BLE_GATTS_SYS_ATTRS_FORMAT. NULL can be provided to obtain the length of the data.\n @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditionally updated to actual length of system attribute data.\n @param[in]     flags             Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS\n\n @retval ::NRF_SUCCESS Successfully retrieved the system attribute information.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.\n @retval ::NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer.\n @retval ::NRF_ERROR_NOT_FOUND No system attributes found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_sys_attr_get(
    conn_handle: u16,
    p_sys_attr_data: *mut u8,
    p_len: *mut u16,
    flags: u32,
) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 178",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_sys_attr_data) => _,
        inout("r2") to_asm(p_len) => _,
        inout("r3") to_asm(flags) => _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve the first valid user attribute handle.\n\n @param[out] p_handle   Pointer to an integer where the handle will be stored.\n\n @retval ::NRF_SUCCESS Successfully retrieved the handle.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_initial_user_handle_get(p_handle: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 179",
        inout("r0") to_asm(p_handle) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Retrieve the attribute UUID and/or metadata.\n\n @param[in]  handle Attribute handle\n @param[out] p_uuid UUID of the attribute. Use NULL to omit this field.\n @param[out] p_md Metadata of the attribute. Use NULL to omit this field.\n\n @retval ::NRF_SUCCESS Successfully retrieved the attribute metadata,\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied. Returned when both @c p_uuid and @c p_md are NULL.\n @retval ::NRF_ERROR_NOT_FOUND Attribute was not found."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_attr_get(handle: u16, p_uuid: *mut ble_uuid_t, p_md: *mut ble_gatts_attr_md_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 180",
        inout("r0") to_asm(handle) => ret,
        inout("r1") to_asm(p_uuid) => _,
        inout("r2") to_asm(p_md) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Reply to an ATT_MTU exchange request by sending an Exchange MTU Response to the client.\n\n @details This function is only used to reply to a @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event.\n\n @details The SoftDevice sets ATT_MTU to the minimum of:\n          - The Client RX MTU value from @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST, and\n          - The Server RX MTU value.\n\n          However, the SoftDevice never sets ATT_MTU lower than @ref BLE_GATT_ATT_MTU_DEFAULT.\n\n @mscs\n @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}\n @endmscs\n\n @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.\n @param[in] server_rx_mtu  Server RX MTU size.\n                           - The minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT.\n                           - The maximum value is @ref ble_gatt_conn_cfg_t::att_mtu in the connection configuration\n                             used for this connection.\n                           - The value must be equal to Client RX MTU size given in @ref sd_ble_gattc_exchange_mtu_request\n                             if an ATT_MTU exchange has already been performed in the other direction.\n\n @retval ::NRF_SUCCESS Successfully sent response to the client.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied.\n @retval ::NRF_ERROR_TIMEOUT There has been a GATT procedure timeout. No new GATT procedure can be performed without reestablishing the connection."]
#[inline(always)]
pub unsafe fn sd_ble_gatts_exchange_mtu_reply(conn_handle: u16, server_rx_mtu: u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 181",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(server_rx_mtu) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "< Enable and initialize the BLE stack"]
pub const BLE_COMMON_SVCS_SD_BLE_ENABLE: BLE_COMMON_SVCS = 96;
#[doc = "< Get an event from the pending events queue."]
pub const BLE_COMMON_SVCS_SD_BLE_EVT_GET: BLE_COMMON_SVCS = 97;
#[doc = "< Add a Vendor Specific base UUID."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_VS_ADD: BLE_COMMON_SVCS = 98;
#[doc = "< Decode UUID bytes."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_DECODE: BLE_COMMON_SVCS = 99;
#[doc = "< Encode UUID bytes."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_ENCODE: BLE_COMMON_SVCS = 100;
#[doc = "< Get the local version information (company ID, Link Layer Version, Link Layer Subversion)."]
pub const BLE_COMMON_SVCS_SD_BLE_VERSION_GET: BLE_COMMON_SVCS = 101;
#[doc = "< User Memory Reply."]
pub const BLE_COMMON_SVCS_SD_BLE_USER_MEM_REPLY: BLE_COMMON_SVCS = 102;
#[doc = "< Set a BLE option."]
pub const BLE_COMMON_SVCS_SD_BLE_OPT_SET: BLE_COMMON_SVCS = 103;
#[doc = "< Get a BLE option."]
pub const BLE_COMMON_SVCS_SD_BLE_OPT_GET: BLE_COMMON_SVCS = 104;
#[doc = "< Add a configuration to the BLE stack."]
pub const BLE_COMMON_SVCS_SD_BLE_CFG_SET: BLE_COMMON_SVCS = 105;
#[doc = "< Remove a Vendor Specific base UUID."]
pub const BLE_COMMON_SVCS_SD_BLE_UUID_VS_REMOVE: BLE_COMMON_SVCS = 106;
#[doc = " @brief Common API SVC numbers."]
pub type BLE_COMMON_SVCS = self::c_uint;
#[doc = "< User Memory request. @ref ble_evt_user_mem_request_t"]
pub const BLE_COMMON_EVTS_BLE_EVT_USER_MEM_REQUEST: BLE_COMMON_EVTS = 1;
#[doc = "< User Memory release. @ref ble_evt_user_mem_release_t"]
pub const BLE_COMMON_EVTS_BLE_EVT_USER_MEM_RELEASE: BLE_COMMON_EVTS = 2;
#[doc = " @brief BLE Module Independent Event IDs."]
pub type BLE_COMMON_EVTS = self::c_uint;
#[doc = "< BLE GAP specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GAP: BLE_CONN_CFGS = 32;
#[doc = "< BLE GATTC specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATTC: BLE_CONN_CFGS = 33;
#[doc = "< BLE GATTS specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATTS: BLE_CONN_CFGS = 34;
#[doc = "< BLE GATT specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_GATT: BLE_CONN_CFGS = 35;
#[doc = "< BLE L2CAP specific connection configuration."]
pub const BLE_CONN_CFGS_BLE_CONN_CFG_L2CAP: BLE_CONN_CFGS = 36;
#[doc = "@brief BLE Connection Configuration IDs.\n\n IDs that uniquely identify a connection configuration."]
pub type BLE_CONN_CFGS = self::c_uint;
#[doc = "< Vendor specific base UUID configuration"]
pub const BLE_COMMON_CFGS_BLE_COMMON_CFG_VS_UUID: BLE_COMMON_CFGS = 1;
#[doc = "@brief BLE Common Configuration IDs.\n\n IDs that uniquely identify a common configuration."]
pub type BLE_COMMON_CFGS = self::c_uint;
#[doc = "< PA and LNA options"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_PA_LNA: BLE_COMMON_OPTS = 1;
#[doc = "< Extended connection events option"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_CONN_EVT_EXT: BLE_COMMON_OPTS = 2;
#[doc = "< Extended RC calibration option"]
pub const BLE_COMMON_OPTS_BLE_COMMON_OPT_EXTENDED_RC_CAL: BLE_COMMON_OPTS = 3;
#[doc = "@brief Common Option IDs.\n IDs that uniquely identify a common option."]
pub type BLE_COMMON_OPTS = self::c_uint;
#[doc = "@brief User Memory Block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_user_mem_block_t {
    #[doc = "< Pointer to the start of the user memory block."]
    pub p_mem: *mut u8,
    #[doc = "< Length in bytes of the user memory block."]
    pub len: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_user_mem_block_t"][::core::mem::size_of::<ble_user_mem_block_t>() - 8usize];
    ["Alignment of ble_user_mem_block_t"][::core::mem::align_of::<ble_user_mem_block_t>() - 4usize];
    ["Offset of field: ble_user_mem_block_t::p_mem"][::core::mem::offset_of!(ble_user_mem_block_t, p_mem) - 0usize];
    ["Offset of field: ble_user_mem_block_t::len"][::core::mem::offset_of!(ble_user_mem_block_t, len) - 4usize];
};
#[doc = "@brief Event structure for @ref BLE_EVT_USER_MEM_REQUEST."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_user_mem_request_t {
    #[doc = "< User memory type, see @ref BLE_USER_MEM_TYPES."]
    pub type_: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_evt_user_mem_request_t"][::core::mem::size_of::<ble_evt_user_mem_request_t>() - 1usize];
    ["Alignment of ble_evt_user_mem_request_t"][::core::mem::align_of::<ble_evt_user_mem_request_t>() - 1usize];
    ["Offset of field: ble_evt_user_mem_request_t::type_"]
        [::core::mem::offset_of!(ble_evt_user_mem_request_t, type_) - 0usize];
};
#[doc = "@brief Event structure for @ref BLE_EVT_USER_MEM_RELEASE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_user_mem_release_t {
    #[doc = "< User memory type, see @ref BLE_USER_MEM_TYPES."]
    pub type_: u8,
    #[doc = "< User memory block"]
    pub mem_block: ble_user_mem_block_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_evt_user_mem_release_t"][::core::mem::size_of::<ble_evt_user_mem_release_t>() - 12usize];
    ["Alignment of ble_evt_user_mem_release_t"][::core::mem::align_of::<ble_evt_user_mem_release_t>() - 4usize];
    ["Offset of field: ble_evt_user_mem_release_t::type_"]
        [::core::mem::offset_of!(ble_evt_user_mem_release_t, type_) - 0usize];
    ["Offset of field: ble_evt_user_mem_release_t::mem_block"]
        [::core::mem::offset_of!(ble_evt_user_mem_release_t, mem_block) - 4usize];
};
#[doc = "@brief Event structure for events not associated with a specific function module."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_common_evt_t {
    #[doc = "< Connection Handle on which this event occurred."]
    pub conn_handle: u16,
    #[doc = "< Event parameter union."]
    pub params: ble_common_evt_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_evt_t__bindgen_ty_1 {
    #[doc = "< User Memory Request Event Parameters."]
    pub user_mem_request: ble_evt_user_mem_request_t,
    #[doc = "< User Memory Release Event Parameters."]
    pub user_mem_release: ble_evt_user_mem_release_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_common_evt_t__bindgen_ty_1>() - 12usize];
    ["Alignment of ble_common_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_common_evt_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_common_evt_t__bindgen_ty_1::user_mem_request"]
        [::core::mem::offset_of!(ble_common_evt_t__bindgen_ty_1, user_mem_request) - 0usize];
    ["Offset of field: ble_common_evt_t__bindgen_ty_1::user_mem_release"]
        [::core::mem::offset_of!(ble_common_evt_t__bindgen_ty_1, user_mem_release) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_evt_t"][::core::mem::size_of::<ble_common_evt_t>() - 16usize];
    ["Alignment of ble_common_evt_t"][::core::mem::align_of::<ble_common_evt_t>() - 4usize];
    ["Offset of field: ble_common_evt_t::conn_handle"][::core::mem::offset_of!(ble_common_evt_t, conn_handle) - 0usize];
    ["Offset of field: ble_common_evt_t::params"][::core::mem::offset_of!(ble_common_evt_t, params) - 4usize];
};
#[doc = "@brief BLE Event header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_evt_hdr_t {
    #[doc = "< Value from a BLE_<module>_EVT series."]
    pub evt_id: u16,
    #[doc = "< Length in octets including this header."]
    pub evt_len: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_evt_hdr_t"][::core::mem::size_of::<ble_evt_hdr_t>() - 4usize];
    ["Alignment of ble_evt_hdr_t"][::core::mem::align_of::<ble_evt_hdr_t>() - 2usize];
    ["Offset of field: ble_evt_hdr_t::evt_id"][::core::mem::offset_of!(ble_evt_hdr_t, evt_id) - 0usize];
    ["Offset of field: ble_evt_hdr_t::evt_len"][::core::mem::offset_of!(ble_evt_hdr_t, evt_len) - 2usize];
};
#[doc = "@brief Common BLE Event type, wrapping the module specific event reports."]
#[repr(C)]
pub struct ble_evt_t {
    #[doc = "< Event header."]
    pub header: ble_evt_hdr_t,
    #[doc = "< Event union."]
    pub evt: ble_evt_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ble_evt_t__bindgen_ty_1 {
    #[doc = "< Common Event, evt_id in BLE_EVT_* series."]
    pub common_evt: __BindgenUnionField<ble_common_evt_t>,
    #[doc = "< GAP originated event, evt_id in BLE_GAP_EVT_* series."]
    pub gap_evt: __BindgenUnionField<ble_gap_evt_t>,
    #[doc = "< GATT client originated event, evt_id in BLE_GATTC_EVT* series."]
    pub gattc_evt: __BindgenUnionField<ble_gattc_evt_t>,
    #[doc = "< GATT server originated event, evt_id in BLE_GATTS_EVT* series."]
    pub gatts_evt: __BindgenUnionField<ble_gatts_evt_t>,
    #[doc = "< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series."]
    pub l2cap_evt: __BindgenUnionField<ble_l2cap_evt_t>,
    pub bindgen_union_field: [u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_evt_t__bindgen_ty_1"][::core::mem::size_of::<ble_evt_t__bindgen_ty_1>() - 44usize];
    ["Alignment of ble_evt_t__bindgen_ty_1"][::core::mem::align_of::<ble_evt_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: ble_evt_t__bindgen_ty_1::common_evt"]
        [::core::mem::offset_of!(ble_evt_t__bindgen_ty_1, common_evt) - 0usize];
    ["Offset of field: ble_evt_t__bindgen_ty_1::gap_evt"]
        [::core::mem::offset_of!(ble_evt_t__bindgen_ty_1, gap_evt) - 0usize];
    ["Offset of field: ble_evt_t__bindgen_ty_1::gattc_evt"]
        [::core::mem::offset_of!(ble_evt_t__bindgen_ty_1, gattc_evt) - 0usize];
    ["Offset of field: ble_evt_t__bindgen_ty_1::gatts_evt"]
        [::core::mem::offset_of!(ble_evt_t__bindgen_ty_1, gatts_evt) - 0usize];
    ["Offset of field: ble_evt_t__bindgen_ty_1::l2cap_evt"]
        [::core::mem::offset_of!(ble_evt_t__bindgen_ty_1, l2cap_evt) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_evt_t"][::core::mem::size_of::<ble_evt_t>() - 48usize];
    ["Alignment of ble_evt_t"][::core::mem::align_of::<ble_evt_t>() - 4usize];
    ["Offset of field: ble_evt_t::header"][::core::mem::offset_of!(ble_evt_t, header) - 0usize];
    ["Offset of field: ble_evt_t::evt"][::core::mem::offset_of!(ble_evt_t, evt) - 4usize];
};
#[doc = " @brief Version Information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_version_t {
    #[doc = "< Link Layer Version number. See https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer for assigned values."]
    pub version_number: u8,
    #[doc = "< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708)."]
    pub company_id: u16,
    #[doc = "< Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID)."]
    pub subversion_number: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_version_t"][::core::mem::size_of::<ble_version_t>() - 6usize];
    ["Alignment of ble_version_t"][::core::mem::align_of::<ble_version_t>() - 2usize];
    ["Offset of field: ble_version_t::version_number"][::core::mem::offset_of!(ble_version_t, version_number) - 0usize];
    ["Offset of field: ble_version_t::company_id"][::core::mem::offset_of!(ble_version_t, company_id) - 2usize];
    ["Offset of field: ble_version_t::subversion_number"]
        [::core::mem::offset_of!(ble_version_t, subversion_number) - 4usize];
};
#[doc = " @brief Configuration parameters for the PA and LNA."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_pa_lna_cfg_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_pa_lna_cfg_t"][::core::mem::size_of::<ble_pa_lna_cfg_t>() - 1usize];
    ["Alignment of ble_pa_lna_cfg_t"][::core::mem::align_of::<ble_pa_lna_cfg_t>() - 1usize];
};
impl ble_pa_lna_cfg_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn active_high(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active_high(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_high_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_active_high_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn gpio_pin(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_pin(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn gpio_pin_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_gpio_pin_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8, active_high: u8, gpio_pin: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let active_high: u8 = unsafe { ::core::mem::transmute(active_high) };
            active_high as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let gpio_pin: u8 = unsafe { ::core::mem::transmute(gpio_pin) };
            gpio_pin as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief PA & LNA GPIO toggle configuration\n\n This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or\n a low noise amplifier.\n\n Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided\n by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.\n\n @note  @ref sd_ble_opt_get is not supported for this option.\n @note  Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences\n and must be avoided by the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_pa_lna_t {
    #[doc = "< Power Amplifier configuration"]
    pub pa_cfg: ble_pa_lna_cfg_t,
    #[doc = "< Low Noise Amplifier configuration"]
    pub lna_cfg: ble_pa_lna_cfg_t,
    #[doc = "< PPI channel used for radio pin setting"]
    pub ppi_ch_id_set: u8,
    #[doc = "< PPI channel used for radio pin clearing"]
    pub ppi_ch_id_clr: u8,
    #[doc = "< GPIOTE channel used for radio pin toggling"]
    pub gpiote_ch_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_opt_pa_lna_t"][::core::mem::size_of::<ble_common_opt_pa_lna_t>() - 5usize];
    ["Alignment of ble_common_opt_pa_lna_t"][::core::mem::align_of::<ble_common_opt_pa_lna_t>() - 1usize];
    ["Offset of field: ble_common_opt_pa_lna_t::pa_cfg"]
        [::core::mem::offset_of!(ble_common_opt_pa_lna_t, pa_cfg) - 0usize];
    ["Offset of field: ble_common_opt_pa_lna_t::lna_cfg"]
        [::core::mem::offset_of!(ble_common_opt_pa_lna_t, lna_cfg) - 1usize];
    ["Offset of field: ble_common_opt_pa_lna_t::ppi_ch_id_set"]
        [::core::mem::offset_of!(ble_common_opt_pa_lna_t, ppi_ch_id_set) - 2usize];
    ["Offset of field: ble_common_opt_pa_lna_t::ppi_ch_id_clr"]
        [::core::mem::offset_of!(ble_common_opt_pa_lna_t, ppi_ch_id_clr) - 3usize];
    ["Offset of field: ble_common_opt_pa_lna_t::gpiote_ch_id"]
        [::core::mem::offset_of!(ble_common_opt_pa_lna_t, gpiote_ch_id) - 4usize];
};
#[doc = " @brief Configuration of extended BLE connection events.\n\n When enabled the SoftDevice will dynamically extend the connection event when possible.\n\n The connection event length is controlled by the connection configuration as set by @ref ble_gap_conn_cfg_t::event_length.\n The connection event can be extended if there is time to send another packet pair before the start of the next connection interval,\n and if there are no conflicts with other BLE roles requesting radio time.\n\n @note @ref sd_ble_opt_get is not supported for this option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_conn_evt_ext_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_opt_conn_evt_ext_t"][::core::mem::size_of::<ble_common_opt_conn_evt_ext_t>() - 1usize];
    ["Alignment of ble_common_opt_conn_evt_ext_t"][::core::mem::align_of::<ble_common_opt_conn_evt_ext_t>() - 1usize];
};
impl ble_common_opt_conn_evt_ext_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Enable/disable extended RC calibration.\n\n If extended RC calibration is enabled and the internal RC oscillator (@ref NRF_CLOCK_LF_SRC_RC) is used as the SoftDevice\n LFCLK source, the SoftDevice as a peripheral will by default try to increase the receive window if two consecutive packets\n are not received. If it turns out that the packets were not received due to clock drift, the RC calibration is started.\n This calibration comes in addition to the periodic calibration that is configured by @ref sd_softdevice_enable(). When\n using only peripheral connections, the periodic calibration can therefore be configured with a much longer interval as the\n peripheral will be able to detect and adjust automatically to clock drift, and calibrate on demand.\n\n If extended RC calibration is disabled and the internal RC oscillator is used as the SoftDevice LFCLK source, the\n RC oscillator is calibrated periodically as configured by @ref sd_softdevice_enable().\n\n @note @ref sd_ble_opt_get is not supported for this option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_opt_extended_rc_cal_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_opt_extended_rc_cal_t"][::core::mem::size_of::<ble_common_opt_extended_rc_cal_t>() - 1usize];
    ["Alignment of ble_common_opt_extended_rc_cal_t"]
        [::core::mem::align_of::<ble_common_opt_extended_rc_cal_t>() - 1usize];
};
impl ble_common_opt_extended_rc_cal_t {
    #[inline]
    pub fn enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(enable: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "@brief Option structure for common options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_opt_t {
    #[doc = "< Parameters for controlling PA and LNA pin toggling."]
    pub pa_lna: ble_common_opt_pa_lna_t,
    #[doc = "< Parameters for enabling extended connection events."]
    pub conn_evt_ext: ble_common_opt_conn_evt_ext_t,
    #[doc = "< Parameters for enabling extended RC calibration."]
    pub extended_rc_cal: ble_common_opt_extended_rc_cal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_opt_t"][::core::mem::size_of::<ble_common_opt_t>() - 5usize];
    ["Alignment of ble_common_opt_t"][::core::mem::align_of::<ble_common_opt_t>() - 1usize];
    ["Offset of field: ble_common_opt_t::pa_lna"][::core::mem::offset_of!(ble_common_opt_t, pa_lna) - 0usize];
    ["Offset of field: ble_common_opt_t::conn_evt_ext"]
        [::core::mem::offset_of!(ble_common_opt_t, conn_evt_ext) - 0usize];
    ["Offset of field: ble_common_opt_t::extended_rc_cal"]
        [::core::mem::offset_of!(ble_common_opt_t, extended_rc_cal) - 0usize];
};
#[doc = "@brief Common BLE Option type, wrapping the module specific options."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_opt_t {
    #[doc = "< COMMON options, opt_id in @ref BLE_COMMON_OPTS series."]
    pub common_opt: ble_common_opt_t,
    #[doc = "< GAP option, opt_id in @ref BLE_GAP_OPTS series."]
    pub gap_opt: ble_gap_opt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_opt_t"][::core::mem::size_of::<ble_opt_t>() - 8usize];
    ["Alignment of ble_opt_t"][::core::mem::align_of::<ble_opt_t>() - 4usize];
    ["Offset of field: ble_opt_t::common_opt"][::core::mem::offset_of!(ble_opt_t, common_opt) - 0usize];
    ["Offset of field: ble_opt_t::gap_opt"][::core::mem::offset_of!(ble_opt_t, gap_opt) - 0usize];
};
#[doc = "@brief BLE connection configuration type, wrapping the module specific configurations, set with\n @ref sd_ble_cfg_set.\n\n @note Connection configurations don't have to be set.\n In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,\n the default connection configuration will be automatically added for the remaining connections.\n When creating connections with the default configuration, @ref BLE_CONN_CFG_TAG_DEFAULT should be used in\n place of @ref ble_conn_cfg_t::conn_cfg_tag.\n\n @sa sd_ble_gap_adv_start()\n @sa sd_ble_gap_connect()\n\n @mscs\n @mmsc{@ref BLE_CONN_CFG}\n @endmscs\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_conn_cfg_t {
    #[doc = "< The application chosen tag it can use with the\n@ref sd_ble_gap_adv_start() and @ref sd_ble_gap_connect() calls\nto select this configuration when creating a connection.\nMust be different for all connection configurations added and not @ref BLE_CONN_CFG_TAG_DEFAULT."]
    pub conn_cfg_tag: u8,
    #[doc = "< Connection configuration union."]
    pub params: ble_conn_cfg_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_conn_cfg_t__bindgen_ty_1 {
    #[doc = "< GAP connection configuration, cfg_id is @ref BLE_CONN_CFG_GAP."]
    pub gap_conn_cfg: ble_gap_conn_cfg_t,
    #[doc = "< GATTC connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTC."]
    pub gattc_conn_cfg: ble_gattc_conn_cfg_t,
    #[doc = "< GATTS connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTS."]
    pub gatts_conn_cfg: ble_gatts_conn_cfg_t,
    #[doc = "< GATT connection configuration, cfg_id is @ref BLE_CONN_CFG_GATT."]
    pub gatt_conn_cfg: ble_gatt_conn_cfg_t,
    #[doc = "< L2CAP connection configuration, cfg_id is @ref BLE_CONN_CFG_L2CAP."]
    pub l2cap_conn_cfg: ble_l2cap_conn_cfg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_conn_cfg_t__bindgen_ty_1"][::core::mem::size_of::<ble_conn_cfg_t__bindgen_ty_1>() - 8usize];
    ["Alignment of ble_conn_cfg_t__bindgen_ty_1"][::core::mem::align_of::<ble_conn_cfg_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: ble_conn_cfg_t__bindgen_ty_1::gap_conn_cfg"]
        [::core::mem::offset_of!(ble_conn_cfg_t__bindgen_ty_1, gap_conn_cfg) - 0usize];
    ["Offset of field: ble_conn_cfg_t__bindgen_ty_1::gattc_conn_cfg"]
        [::core::mem::offset_of!(ble_conn_cfg_t__bindgen_ty_1, gattc_conn_cfg) - 0usize];
    ["Offset of field: ble_conn_cfg_t__bindgen_ty_1::gatts_conn_cfg"]
        [::core::mem::offset_of!(ble_conn_cfg_t__bindgen_ty_1, gatts_conn_cfg) - 0usize];
    ["Offset of field: ble_conn_cfg_t__bindgen_ty_1::gatt_conn_cfg"]
        [::core::mem::offset_of!(ble_conn_cfg_t__bindgen_ty_1, gatt_conn_cfg) - 0usize];
    ["Offset of field: ble_conn_cfg_t__bindgen_ty_1::l2cap_conn_cfg"]
        [::core::mem::offset_of!(ble_conn_cfg_t__bindgen_ty_1, l2cap_conn_cfg) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_conn_cfg_t"][::core::mem::size_of::<ble_conn_cfg_t>() - 10usize];
    ["Alignment of ble_conn_cfg_t"][::core::mem::align_of::<ble_conn_cfg_t>() - 2usize];
    ["Offset of field: ble_conn_cfg_t::conn_cfg_tag"][::core::mem::offset_of!(ble_conn_cfg_t, conn_cfg_tag) - 0usize];
    ["Offset of field: ble_conn_cfg_t::params"][::core::mem::offset_of!(ble_conn_cfg_t, params) - 2usize];
};
#[doc = " @brief Configuration of Vendor Specific base UUIDs, set with @ref sd_ble_cfg_set.\n\n @retval ::NRF_ERROR_INVALID_PARAM Too many UUIDs configured."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_common_cfg_vs_uuid_t {
    #[doc = "< Number of 128-bit Vendor Specific base UUID bases to allocate memory for.\nDefault value is @ref BLE_UUID_VS_COUNT_DEFAULT. Maximum value is\n@ref BLE_UUID_VS_COUNT_MAX."]
    pub vs_uuid_count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_cfg_vs_uuid_t"][::core::mem::size_of::<ble_common_cfg_vs_uuid_t>() - 1usize];
    ["Alignment of ble_common_cfg_vs_uuid_t"][::core::mem::align_of::<ble_common_cfg_vs_uuid_t>() - 1usize];
    ["Offset of field: ble_common_cfg_vs_uuid_t::vs_uuid_count"]
        [::core::mem::offset_of!(ble_common_cfg_vs_uuid_t, vs_uuid_count) - 0usize];
};
#[doc = "@brief Common BLE Configuration type, wrapping the common configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_common_cfg_t {
    #[doc = "< Vendor Specific base UUID configuration, cfg_id is @ref BLE_COMMON_CFG_VS_UUID."]
    pub vs_uuid_cfg: ble_common_cfg_vs_uuid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_common_cfg_t"][::core::mem::size_of::<ble_common_cfg_t>() - 1usize];
    ["Alignment of ble_common_cfg_t"][::core::mem::align_of::<ble_common_cfg_t>() - 1usize];
    ["Offset of field: ble_common_cfg_t::vs_uuid_cfg"][::core::mem::offset_of!(ble_common_cfg_t, vs_uuid_cfg) - 0usize];
};
#[doc = "@brief BLE Configuration type, wrapping the module specific configurations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_cfg_t {
    #[doc = "< Connection specific configurations, cfg_id in @ref BLE_CONN_CFGS series."]
    pub conn_cfg: ble_conn_cfg_t,
    #[doc = "< Global common configurations, cfg_id in @ref BLE_COMMON_CFGS series."]
    pub common_cfg: ble_common_cfg_t,
    #[doc = "< Global GAP configurations, cfg_id in @ref BLE_GAP_CFGS series."]
    pub gap_cfg: ble_gap_cfg_t,
    #[doc = "< Global GATTS configuration, cfg_id in @ref BLE_GATTS_CFGS series."]
    pub gatts_cfg: ble_gatts_cfg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ble_cfg_t"][::core::mem::size_of::<ble_cfg_t>() - 12usize];
    ["Alignment of ble_cfg_t"][::core::mem::align_of::<ble_cfg_t>() - 4usize];
    ["Offset of field: ble_cfg_t::conn_cfg"][::core::mem::offset_of!(ble_cfg_t, conn_cfg) - 0usize];
    ["Offset of field: ble_cfg_t::common_cfg"][::core::mem::offset_of!(ble_cfg_t, common_cfg) - 0usize];
    ["Offset of field: ble_cfg_t::gap_cfg"][::core::mem::offset_of!(ble_cfg_t, gap_cfg) - 0usize];
    ["Offset of field: ble_cfg_t::gatts_cfg"][::core::mem::offset_of!(ble_cfg_t, gatts_cfg) - 0usize];
};

#[doc = "@brief Enable the BLE stack\n\n @param[in, out] p_app_ram_base   Pointer to a variable containing the start address of the\n                                  application RAM region (APP_RAM_BASE). On return, this will\n                                  contain the minimum start address of the application RAM region\n                                  required by the SoftDevice for this configuration.\n\n @note The memory requirement for a specific configuration will not increase between SoftDevices\n       with the same major version number.\n\n @note At runtime the IC's RAM is split into 2 regions: The SoftDevice RAM region is located\n       between 0x20000000 and APP_RAM_BASE-1 and the application's RAM region is located between\n       APP_RAM_BASE and the start of the call stack.\n\n @details This call initializes the BLE stack, no BLE related function other than @ref\n          sd_ble_cfg_set can be called before this one.\n\n @mscs\n @mmsc{@ref BLE_COMMON_ENABLE}\n @endmscs\n\n @retval ::NRF_SUCCESS              The BLE stack has been initialized successfully.\n @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized and cannot be reinitialized.\n @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied.\n @retval ::NRF_ERROR_NO_MEM         One or more of the following is true:\n                                    - The amount of memory assigned to the SoftDevice by *p_app_ram_base is not\n                                      large enough to fit this configuration's memory requirement. Check *p_app_ram_base\n                                      and set the start address of the application RAM region accordingly.\n                                    - Dynamic part of the SoftDevice RAM region is larger then 64 kB which\n                                      is currently not supported.\n @retval ::NRF_ERROR_RESOURCES      The total number of L2CAP Channels configured using @ref sd_ble_cfg_set is too large."]
#[inline(always)]
pub unsafe fn sd_ble_enable(p_app_ram_base: *mut u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 96",
        inout("r0") to_asm(p_app_ram_base) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add configurations for the BLE stack\n\n @param[in] cfg_id              Config ID, see @ref BLE_CONN_CFGS, @ref BLE_COMMON_CFGS, @ref\n                                BLE_GAP_CFGS or @ref BLE_GATTS_CFGS.\n @param[in] p_cfg               Pointer to a ble_cfg_t structure containing the configuration value.\n @param[in] app_ram_base        The start address of the application RAM region (APP_RAM_BASE).\n                                See @ref sd_ble_enable for details about APP_RAM_BASE.\n\n @note The memory requirement for a specific configuration will not increase between SoftDevices\n       with the same major version number.\n\n @note If a configuration is set more than once, the last one set is the one that takes effect on\n       @ref sd_ble_enable.\n\n @note Any part of the BLE stack that is NOT configured with @ref sd_ble_cfg_set will have default\n       configuration.\n\n @note @ref sd_ble_cfg_set may be called at any time when the SoftDevice is enabled (see @ref\n       sd_softdevice_enable) while the BLE part of the SoftDevice is not enabled (see @ref\n       sd_ble_enable).\n\n @note Error codes for the configurations are described in the configuration structs.\n\n @mscs\n @mmsc{@ref BLE_COMMON_ENABLE}\n @endmscs\n\n @retval ::NRF_SUCCESS              The configuration has been added successfully.\n @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized.\n @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM  Invalid cfg_id supplied.\n @retval ::NRF_ERROR_NO_MEM         The amount of memory assigned to the SoftDevice by app_ram_base is not\n                                    large enough to fit this configuration's memory requirement."]
#[inline(always)]
pub unsafe fn sd_ble_cfg_set(cfg_id: u32, p_cfg: *const ble_cfg_t, app_ram_base: u32) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 105",
        inout("r0") to_asm(cfg_id) => ret,
        inout("r1") to_asm(p_cfg) => _,
        inout("r2") to_asm(app_ram_base) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get an event from the pending events queue.\n\n @param[out] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length.\n                    This buffer <b>must be aligned to the extend defined by @ref BLE_EVT_PTR_ALIGNMENT</b>.\n                    The buffer should be interpreted as a @ref ble_evt_t struct.\n @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length.\n\n @details This call allows the application to pull a BLE event from the BLE stack. The application is signaled that\n an event is available from the BLE stack by the triggering of the SD_EVT_IRQn interrupt.\n The application is free to choose whether to call this function from thread mode (main context) or directly from the\n Interrupt Service Routine that maps to SD_EVT_IRQn. In any case however, and because the BLE stack runs at a higher\n priority than the application, this function should be called in a loop (until @ref NRF_ERROR_NOT_FOUND is returned)\n every time SD_EVT_IRQn is raised to ensure that all available events are pulled from the BLE stack. Failure to do so\n could potentially leave events in the internal queue without the application being aware of this fact.\n\n Sizing the p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to\n be copied into application memory. If the buffer provided is not large enough to fit the entire contents of the event,\n @ref NRF_ERROR_DATA_SIZE will be returned and the application can then call again with a larger buffer size.\n The maximum possible event length is defined by @ref BLE_EVT_LEN_MAX. The application may also \"peek\" the event length\n by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return:\n\n     \\code\n     uint16_t len;\n     errcode = sd_ble_evt_get(NULL, &len);\n     \\endcode\n\n @mscs\n @mmsc{@ref BLE_COMMON_IRQ_EVT_MSC}\n @mmsc{@ref BLE_COMMON_THREAD_EVT_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.\n @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.\n @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer."]
#[inline(always)]
pub unsafe fn sd_ble_evt_get(p_dest: *mut u8, p_len: *mut u16) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 97",
        inout("r0") to_asm(p_dest) => ret,
        inout("r1") to_asm(p_len) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Add a Vendor Specific base UUID.\n\n @details This call enables the application to add a Vendor Specific base UUID to the BLE stack's table, for later\n use with all other modules and APIs. This then allows the application to use the shorter, 24-bit @ref ble_uuid_t\n format when dealing with both 16-bit and 128-bit UUIDs without having to check for lengths and having split code\n paths. This is accomplished by extending the grouping mechanism that the Bluetooth SIG standard base UUID uses\n for all other 128-bit UUIDs. The type field in the @ref ble_uuid_t structure is an index (relative to\n @ref BLE_UUID_TYPE_VENDOR_BEGIN) to the table populated by multiple calls to this function, and the UUID field\n in the same structure contains the 2 bytes at indexes 12 and 13. The number of possible 128-bit UUIDs available to\n the application is therefore the number of Vendor Specific UUIDs added with the help of this function times 65536,\n although restricted to modifying bytes 12 and 13 for each of the entries in the supplied array.\n\n @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by\n the 16-bit uuid field in @ref ble_uuid_t.\n\n @note If a UUID is already present in the BLE stack's internal table, the corresponding index will be returned in\n p_uuid_type along with an @ref NRF_SUCCESS error code.\n\n @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific base UUID disregarding\n                          bytes 12 and 13.\n @param[out] p_uuid_type  Pointer to a uint8_t where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.\n\n @retval ::NRF_SUCCESS Successfully added the Vendor Specific base UUID.\n @retval ::NRF_ERROR_INVALID_ADDR If p_vs_uuid or p_uuid_type is NULL or invalid.\n @retval ::NRF_ERROR_NO_MEM If there are no more free slots for VS UUIDs."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_vs_add(p_vs_uuid: *const ble_uuid128_t, p_uuid_type: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 98",
        inout("r0") to_asm(p_vs_uuid) => ret,
        inout("r1") to_asm(p_uuid_type) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Remove a Vendor Specific base UUID.\n\n @details This call removes a Vendor Specific base UUID that has been added with @ref sd_ble_uuid_vs_add. This function allows\n the application to reuse memory allocated for Vendor Specific base UUIDs.\n\n @note Currently this function can only be called with a p_uuid_type set to @ref BLE_UUID_TYPE_UNKNOWN or the last added UUID type.\n\n @param[inout] p_uuid_type Pointer to a uint8_t where its value matches the UUID type in @ref ble_uuid_t::type to be removed.\n                           If the type is set to @ref BLE_UUID_TYPE_UNKNOWN, or the pointer is NULL, the last Vendor Specific\n                           base UUID will be removed. If the function returns successfully, the UUID type that was removed will\n                           be written back to @p p_uuid_type. If function returns with a failure, it contains the last type that\n                           is in use by the ATT Server.\n\n @retval ::NRF_SUCCESS Successfully removed the Vendor Specific base UUID.\n @retval ::NRF_ERROR_INVALID_ADDR If p_uuid_type is invalid.\n @retval ::NRF_ERROR_INVALID_PARAM If p_uuid_type points to a non-valid UUID type.\n @retval ::NRF_ERROR_FORBIDDEN If the Vendor Specific base UUID is in use by the ATT Server."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_vs_remove(p_uuid_type: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 106",
        inout("r0") to_asm(p_uuid_type) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.\n\n @details The raw UUID bytes excluding bytes 12 and 13 (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared\n to the corresponding ones in each entry of the table of Vendor Specific base UUIDs populated with @ref sd_ble_uuid_vs_add\n to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index\n relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type.\n\n @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.\n\n @param[in]   uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).\n @param[in]   p_uuid_le   Pointer pointing to little endian raw UUID bytes.\n @param[out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.\n\n @retval ::NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_LENGTH Invalid UUID length.\n @retval ::NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_decode(uuid_le_len: u8, p_uuid_le: *const u8, p_uuid: *mut ble_uuid_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 99",
        inout("r0") to_asm(uuid_le_len) => ret,
        inout("r1") to_asm(p_uuid_le) => _,
        inout("r2") to_asm(p_uuid) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = " @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).\n\n @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validity and size of p_uuid is computed.\n\n @param[in]   p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.\n @param[out]  p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).\n @param[out]  p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.\n\n @retval ::NRF_SUCCESS Successfully encoded into the buffer.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid UUID type."]
#[inline(always)]
pub unsafe fn sd_ble_uuid_encode(p_uuid: *const ble_uuid_t, p_uuid_le_len: *mut u8, p_uuid_le: *mut u8) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 100",
        inout("r0") to_asm(p_uuid) => ret,
        inout("r1") to_asm(p_uuid_le_len) => _,
        inout("r2") to_asm(p_uuid_le) => _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get Version Information.\n\n @details This call allows the application to get the BLE stack version information.\n\n @param[out] p_version Pointer to a ble_version_t structure to be filled in.\n\n @retval ::NRF_SUCCESS  Version information stored successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY The BLE stack is busy (typically doing a locally-initiated disconnection procedure)."]
#[inline(always)]
pub unsafe fn sd_ble_version_get(p_version: *mut ble_version_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 101",
        inout("r0") to_asm(p_version) => ret,
        lateout("r1") _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Provide a user memory block.\n\n @note This call can only be used as a response to a @ref BLE_EVT_USER_MEM_REQUEST event issued to the application.\n\n @param[in] conn_handle Connection handle.\n @param[in] p_block Pointer to a user memory block structure or NULL if memory is managed by the application.\n\n @mscs\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_PEER_CANCEL_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_NOAUTH_MSC}\n @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}\n @endmscs\n\n @retval ::NRF_SUCCESS Successfully queued a response to the peer.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_LENGTH Invalid user memory block length supplied.\n @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no user memory request pending."]
#[inline(always)]
pub unsafe fn sd_ble_user_mem_reply(conn_handle: u16, p_block: *const ble_user_mem_block_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 102",
        inout("r0") to_asm(conn_handle) => ret,
        inout("r1") to_asm(p_block) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Set a BLE option.\n\n @details This call allows the application to set the value of an option.\n\n @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.\n @param[in] p_opt Pointer to a ble_opt_t structure containing the option value.\n\n @retval ::NRF_SUCCESS  Option set successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.\n @retval ::NRF_ERROR_INVALID_STATE Unable to set the parameter at this time.\n @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed."]
#[inline(always)]
pub unsafe fn sd_ble_opt_set(opt_id: u32, p_opt: *const ble_opt_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 103",
        inout("r0") to_asm(opt_id) => ret,
        inout("r1") to_asm(p_opt) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}

#[doc = "@brief Get a BLE option.\n\n @details This call allows the application to retrieve the value of an option.\n\n @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.\n @param[out] p_opt Pointer to a ble_opt_t structure to be filled in.\n\n @retval ::NRF_SUCCESS  Option retrieved successfully.\n @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.\n @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.\n @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.\n @retval ::NRF_ERROR_INVALID_STATE Unable to retrieve the parameter at this time.\n @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed.\n @retval ::NRF_ERROR_NOT_SUPPORTED This option is not supported.\n"]
#[inline(always)]
pub unsafe fn sd_ble_opt_get(opt_id: u32, p_opt: *mut ble_opt_t) -> u32 {
    let ret: u32;
    core::arch::asm!("svc 104",
        inout("r0") to_asm(opt_id) => ret,
        inout("r1") to_asm(p_opt) => _,
        lateout("r2") _,
        lateout("r3") _,
        lateout("r12") _,
    );
    ret
}
